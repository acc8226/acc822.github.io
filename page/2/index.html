<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"DNTEG3O773","apiKey":"dbae86bf58ba49b0e9f250a3983ac7ff","indexName":"likaiailei","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="personal website">
<meta property="og:type" content="website">
<meta property="og:title" content="ac86&#39;s blog">
<meta property="og:url" content="/page/2/index.html">
<meta property="og:site_name" content="ac86&#39;s blog">
<meta property="og:description" content="personal website">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ac86&#39;s blog">
<meta name="twitter:description" content="personal website">

<link rel="canonical" href="/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>ac86's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ac86's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">---</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/acc8226" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/ant/2018/09/15/ant简介.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/ant/2018/09/15/ant简介.html" class="post-title-link" itemprop="url">Ant简介</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-15 11:30:00" itemprop="dateCreated datePublished" datetime="2018-09-15T11:30:00+08:00">2018-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ant/" itemprop="url" rel="index"><span itemprop="name">ant</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Apache Ant 是由 Java 语言开发的工具，由 Apache 软件基金会所提供。Apache Ant 的配置文件写成 XML 容易维护和书写，而且结构很清晰。本教程将以简单的方式会向你展示如何利用 Apache ANT 来自动地构建和部署过程。</p>
</blockquote>
<ol>
<li>找到安装路径<code>C:\L_Executable\apache-ant-1.10.5</code></li>
<li><p>配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANT_HOME C:\L_Executable\apache-ant-1.10.5</span><br><span class="line">Path %ANT_HOME%\bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>ant -version</code>查看是否安装成功<code>Apache Ant(TM) version 1.10.5 compiled on July 10 2018</code></p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- copy --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拷贝文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">".\build.xml"</span> <span class="attr">tofile</span>=<span class="string">"newBuild.xml"</span> /&gt;</span>	</span><br><span class="line"><span class="comment">&lt;!-- 拷贝文件夹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"build/dest_dir"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"origin_dir"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- delete --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除单个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"test.txt"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除整个目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"someDir"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- zip --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将当前目录包含文件压缩 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">zip</span> <span class="attr">destfile</span>=<span class="string">"project.zip"</span> <span class="attr">basedir</span>=<span class="string">"."</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="插播Java教程"><a href="#插播Java教程" class="headerlink" title="插播Java教程"></a>插播Java教程</h2><h3 id="javac的官方说法："><a href="#javac的官方说法：" class="headerlink" title="javac的官方说法："></a>javac的官方说法：</h3><p><code>-classpath:</code><br>设置用户类路径，它将覆盖CLASSPATH 环境变量中的用户类路径。若既未指定CLASSPATH 又未指定-classpath，则用户类路径由当前目录构成。<br><code>-sourcepath:</code><br>指定用以查找类或接口定义的源代码路径。与用户类路径一样，源路径项用分号 (;)进行分隔，它们可以是目录、JAR 归档文件或 ZIP 归档文件。如果使用包，那么目录或归档文件中的本地路径名必须反映包名。</p>
<blockquote>
<p>注意：通过类路径查找的类，如果找到了其源文件，则可能会自动被重新编译。</p>
</blockquote>
<p><code>-d</code>用于指定.class文件的生成目录, 将目录 <code>src/com/tt</code>下Hello.Java类编译到<code>bin</code>目录下<br>美中不足的是-d需要指定已经存在的目录，不能自动创建。<br><code>javac -sourcepath src -classpath . -d bin src/com/tt/Hello.java</code><br>如果没什么其他类的依赖可简写为 <code>javac -d bin src/com/tt/Hello.java</code>   </p>
<p>java会基于提供的classpath（缩写成cp）路径去搜索。<br><code>java -classpath bin com.tt.Hello</code></p>
<p>将 <code>bin/</code>目录中的所有文件归档到 ‘classes.jar’ 中:</p>
<ul>
<li><p>方法一: 指定<code>MANIFEST.MF</code>文件的命令:  <code>jar vcfm classes.jar MANIFEST.MF -C bin/ .</code></p>
</li>
<li><p>方法二: 先直接生成<br><code>jar vcf classes.jar -C bin/ .</code><br>再winRAR直接修改<code>MANIFEST.MF</code><img src="https://upload-images.jianshu.io/upload_images/1662509-1948d6b4264b6e63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>或者拿出<code>MANIFEST.MF</code>文件后命令<code>jar vufm classes.jar MANIFEST.MF</code>, 这里注意要空两个空行, 如果遇到<code>Duplicate name in Manifest: Created-By.</code>这种语句直接忽略就好, 因为字段有重名而已。</p>
</li>
</ul>
<blockquote>
<p>之所以加’v’是为了生成详细输出</p>
</blockquote>
<h3 id="关于Classpath一些笔记"><a href="#关于Classpath一些笔记" class="headerlink" title="关于Classpath一些笔记"></a>关于Classpath一些笔记</h3><p><code>Classpath</code>可以用3种不同的方式设置：</p>
<ul>
<li>如果没有设置——那么classpath参数就会被忽略，环境变量中的CLASSPATH就会被使用到</li>
<li>如果环境变量CLASSPATH没找到，那么就是默认使用当前目录（”.”）</li>
<li>如果classpath作为命令行参数显示设置了，那么它就是覆盖所有其他的值。 当设置覆盖默认值（当前目录）时，classpath会造成不可预料的结果。 所以要么省略, 要么<code>-cp .;lib/aaa.jar</code>例如为<code>javac -cp .;lib/aaa.jar bbb.java</code></li>
</ul>
<p>入门小案例<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"MyProject"</span> <span class="attr">default</span>=<span class="string">"dist"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">		simple example build file</span><br><span class="line">	<span class="tag">&lt;/<span class="name">description</span>&gt;</span>	</span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">file</span>=<span class="string">"build.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- set global properties for this build --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">location</span>=<span class="string">"src"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">location</span>=<span class="string">"build/classes"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist"</span> <span class="attr">location</span>=<span class="string">"dist"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Create the time stamp --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tstamp</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">format</span> <span class="attr">property</span>=<span class="string">"DSTAMP"</span> <span class="attr">pattern</span>=<span class="string">"yyMMdd"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tstamp</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- Create the build directory structure used by compile --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">description</span>=<span class="string">"compile the source"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Compile the Java code from $&#123;src&#125; into $&#123;build&#125; --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build&#125;"</span> <span class="attr">includeantruntime</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"dist"</span> <span class="attr">depends</span>=<span class="string">"compile"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">description</span>=<span class="string">"generate the distribution"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Create the distribution directory --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist&#125;/lib"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Put everything in $&#123;build&#125; into the jar file --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;dist&#125;/lib/$&#123;jar.filename&#125;-$&#123;DSTAMP&#125;.jar"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;build&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"Main-class"</span> <span class="attr">value</span>=<span class="string">"$&#123;jar.manifest.main-class&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jar</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span> <span class="attr">description</span>=<span class="string">"clean up"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Delete the $&#123;build&#125; and $&#123;dist&#125; directory trees --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build&#125;"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/09-java异常.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/09-java异常.html" class="post-title-link" itemprop="url">09 Java异常</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 22:00:00" itemprop="dateCreated datePublished" datetime="2018-09-09T22:00:00+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>异常指的是程序运行时出现的不正常情况</p>
</blockquote>
<p>程序运行过程中难免会发生异常，发生异常并不可怕，程序员应该考虑到有可能发生这些异常，编程时应该捕获并进行处理异常，不能让程序发生终止，这就是健壮的程序。</p>
<h2 id="异常的层次"><a href="#异常的层次" class="headerlink" title="异常的层次"></a>异常的层次</h2><p>Java的异常类是处理运行时的特殊类,每一种异常对应一种特定的运行错误.所有Java异常类都是系统类库中Exception类的子类<br><img src="https://upload-images.jianshu.io/upload_images/1662509-0c6dd4e9db1d694e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常类继承层次图"></p>
<h2 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h2><p>所有的异常类都直接或间接地继承于java.lang.Throwable类，在Throwable类有几个非常重要的方法：</p>
<ul>
<li>String getMessage()：获得发生异常的详细消息。</li>
<li>void printStackTrace()：打印异常堆栈跟踪信息。<br><code>printStackTrace(PrintStream s)</code>  通常用该方法将异常内容保存在日志文件中，以便查阅。</li>
<li>String toString()：获得获取异常类名和异常信息的描述。　　</li>
</ul>
<h2 id="Error和Exception"><a href="#Error和Exception" class="headerlink" title="Error和Exception"></a>Error和Exception</h2><p>Throwable有两个直接子类：Error和Exception。</p>
<ol>
<li><p>Error<br>Error是程序无法恢复的严重错误，程序员根本无能为力，程序中不能对其编程处理， 对Error一般不编写针对性的代码对其进行处理   只能让程序终止。例如：JVM内部错误、内存溢出和资源耗尽等严重情况。</p>
</li>
<li><p>Exception<br>Exception是程序可以恢复的异常，它是程序员所能掌控的。例如：除零异常、空指针访问、网络连接中断和读取不存在的文件等。本章所讨论的异常处理就是对Exception及其子类的异常处理。</p>
</li>
</ol>
<h2 id="受检查异常和运行时异常"><a href="#受检查异常和运行时异常" class="headerlink" title="受检查异常和运行时异常"></a>受检查异常和运行时异常</h2><p>Java 的异常处理机制会区分两种不同的异常类型：已检异常checked和未检异常unchecked(运行时异常)。</p>
<h3 id="已检异常"><a href="#已检异常" class="headerlink" title="已检异常"></a>已检异常</h3><p>在明确的特定情况下抛出，经常是应用<strong>能部分或完全恢复的情况</strong>。例如，某段代码要在多个可能的目录中寻找配置文件。如果试图打开的文件不在某个目录中，就会抛出 FileNotFoundException 异常。在这个例子中，我们想捕获这个异常，然后在文件可能出现的下一个位置继续尝试。也就是说，虽然文件不存在是异常状况，但可以从中恢复，这是意料之中的失败。</p>
<h3 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h3><p>在Java 环境中有些失败是无法预料的，这些失败可能是由运行时条件或滥用库代码导致的。例如把无效的 null 传给使用对象或数组的方法，会抛出 NullPointerException 异常。基本上任何方法在任何时候都可能抛出未检异常。这是 Java 环境中的墨菲定律：“会出错的事总会出错。”从未检异常中恢复，虽说不是不可能，但往往很难，因为完全不可预知。运行时异常往往是程序员所犯错误导致的，<strong>健壮的程序不应该发生运行时异常</strong>。</p>
<p>若想区分已检异常和未检异常，记住两点：异常是 Throwable 对象，而且异常主要分为两类，通过 Error 和 Exception 子类标识。只要异常对象是 Error 类，就是未检异常。Exception 类还有一个子类 RuntimeException ， RuntimeException 类的所有子类都属于未检异常。除此之外，都是已检异常。</p>
<blockquote>
<p>提示　对于运行时异常通常不采用抛出或捕获处理方式，而是<strong>应该提前预判</strong>，防止这种发生异常，做到未雨绸缪。例如在进行除法运算之前应该判断除数是非零的，修改代码进行提前预判这样处理要比通过try-catch捕获异常要友好的多。</p>
</blockquote>
<h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p>Exception类有若干子类,每个子类代表一种特定的运行错误,这些子类有的是系统事先定义好并包含在Java类库中的,成为系统定义的运行异常.</p>
<ul>
<li>ClassNotFoundException 未找到要装载的类</li>
<li>ArrayIndexOutOfBoundsException 数组越界访问</li>
<li>FileNotFoundException 文件找不到, checked异常</li>
<li>IOException 输入, 输出错误, checked异常</li>
<li>NullPointerException 空指针异常, unchecked异常</li>
<li>ArithmeticException 算术运算错误</li>
<li>InterruptedException 中断异常, 线程在进行暂停处理时(如睡眠)被调度打断将引发该一场     </li>
</ul>
<h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><ul>
<li>对待受检查异常。如果当前方法有能力解决，则捕获异常进行处理；没有能力解决，则抛出给上层调用方法处理。</li>
<li>涉及了五个关键字<code>try catch finally throw throws</code></li>
<li><p>try…catch..finally 或者 try-with-resources<strong>(Java7增加)</strong>语句结构进行捕获</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;语句块;&#125; </span><br><span class="line"><span class="keyword">catch</span> (异常类名   参变量名) &#123;语句块;&#125;   </span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">  &#123;语句块;&#125; <span class="comment">//定义一定执行的代码:通常用于关闭资源</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>try必须带有 ‘catch’, ‘finally’ 或资源声明才可以使用</p>
</li>
<li>一个try可以引导多个catch块。但是不要定义多余的catch块，多个catch块的异常出现继承关系，父类异常catch块放在最后面。</li>
<li>异常发生后，try块中的剩余语句将不再执行。 </li>
<li>catch块中的代码要执行的条件是，首先在try块中发生了异常，其次异常的类型与catch要捕捉的一致。 建议声明更为具体的异常，这样处理的可以更具体。当捕获的多个异常类之间存在父子关系时，捕获异常顺序与catch代码块的顺序有关。一般先捕获子类，后捕获父类，否则子类捕获不到。</li>
<li>可以无finally部分，但如果存在，则无论异常发生否，finally部分的语句均要执行。即便是try或catch块中含有退出方法的语句return，也不能阻止finally代码块的执行; 除非执行System.exit(0)等导致程序停止运行的语句。  </li>
</ul>
<blockquote>
<p>try-catch不仅可以嵌套在try代码块中，还可以嵌套在catch代码块或finally代码块，finally代码块后面会详细介绍。try-catch嵌套会使程序流程变的复杂，<strong>如果能用多catch捕获的异常，尽量不要使用try-catch嵌套</strong>。特别对于初学者不要简单地使用Eclipse的语法提示不加区分地添加try-catch嵌套，要梳理好程序的流程再考虑try-catch嵌套的必要性。</p>
</blockquote>
<p>Java 7推出了多重捕获（multi-catch）技术, 可以把这些异常合并处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ParseException e) &#123;</span><br><span class="line">    <span class="comment">//调用方法methodA处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>有时在try-catch语句中会占用一些非Java资源，如：打开文件、网络连接、打开数据库连接和使用数据结果集等，这些资源并非Java资源，不能通过JVM的垃圾收集器回收，需要程序员释放。为了确保这些资源能够被释放可以使用finally代码块或Java 7之后提供自动资源管理（Automatic Resource Management）技术。</p>
<h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>try-catch语句后面还可以跟有一个finally代码块，try-catch-finally语句语法如下</p>
<blockquote>
<p>注意　为了代码简洁等目的，可能有的人会将finally代码中的多个嵌套的try-catch语句合并。每一个close()方法对应关闭一个资源，如果某一个close()方法关闭时发生了异常，那么后面的也不会关闭，因此这种代码是有缺陷的。</p>
</blockquote>
<h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>使用finally代码块释放资源会导致程序代码大量增加，一个finally代码块往往比正常执行的程序还要多。在Java 7之后提供自动资源管理（Automatic Resource Management）技术，可以替代finally代码块，优化代码结构，提高程序可读性。</p>
<p>自动资源管理是在try语句上的扩展，语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明或初始化资源语句) &#123;</span><br><span class="line">    <span class="comment">//可能会生成异常语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e1)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e2)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable eN)&#123;</span><br><span class="line">    <span class="comment">//处理异常eN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在try语句后面添加一对小括号“()”，其中是声明或初始化资源语句，可以有多条语句语句之间用分号“;”分隔。</p>
<p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">… …</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = readDate();</span><br><span class="line">        System.out.println(<span class="string">"读取的日期  = "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">readDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动资源管理</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream readfile = <span class="keyword">new</span> FileInputStream(<span class="string">"readme.txt"</span>);     </span><br><span class="line">                InputStreamReader ir = <span class="keyword">new</span> InputStreamReader(readfile);        </span><br><span class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(ir)) &#123;                  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            Date date = df.parse(str);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理IOException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理ParseException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意　所有可以自动管理的资源需要实现AutoCloseable接口，上述代码中三个输入流FileInputStream、InputStreamReader和BufferedReader从Java 7之后实现AutoCloseable接口，具体哪些资源实现AutoCloseable接口需要查询API文档。</p>
</blockquote>
<h2 id="throws与声明方法抛出异常"><a href="#throws与声明方法抛出异常" class="headerlink" title="throws与声明方法抛出异常"></a>throws与声明方法抛出异常</h2><p>在一个方法中如果能够处理异常，则需要捕获并处理。但是本方法没有能力处理该异常，捕获它没有任何意义，则需要在方法后面声明抛出该异常，通知上层调用者该方法有可以发生异常。</p>
<blockquote>
<p>注意　如果声明抛出的多个异常类之间有父子关系，可以只声明抛出父类。但如果没有父子关系情况下，最好明确声明抛出每一个异常，因为上层调用者会根据这些异常信息进行相应的处理。假如一个方法中有可能抛出IOException和ParseException两个异常，那么声明抛出IOException和ParseException呢？还是只声明抛出Exception呢？因为Exception是IOException和ParseException的父类，只声明抛出Exception从语法是允许的，但是声明抛出IOException和ParseException更好一些。</p>
</blockquote>
<ul>
<li>使用<code>throw</code>抛出异常. 异常的本质是对象,因为<code>throw</code>关键词后跟的是<code>new</code>运算符来创建的一个异常对象.</li>
<li>使用<code>throws</code>关键字抛出一个或多个异常</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>有些公司为了提高代码的可重用性，自己开发了一些Java类库或框架，其中少不了自己编写了一些异常类。实现自定义异常类需要继承Exception类或其子类，如果自定义运行时异常类需继承RuntimeException类或其子类。</p>
<p>自定义异常就很简单，主要是提供两个构造方法就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="throw与显式抛出异常"><a href="#throw与显式抛出异常" class="headerlink" title="throw与显式抛出异常"></a>throw与显式抛出异常</h2><p>通过throw语句显式抛出异常, 显式抛出异常目的有很多，例如不想某些异常传给上层调用者，可以捕获之后重新显式抛出另外一种异常给调用者。</p>
<blockquote>
<p>注意　throw显式抛出的异常与系统生成并抛出的异常，在处理方式上没有区别，就是两种方法：要么捕获自己处理，要么抛出给上层调用者。在本例中是声明抛出，所以在readDate()方法后面要声明抛出MyException异常。</p>
</blockquote>
<h2 id="设计良好异常机制"><a href="#设计良好异常机制" class="headerlink" title="设计良好异常机制"></a>设计良好异常机制</h2><ul>
<li>考虑要在异常中存储什么额外状态——记住，异常也是对象；</li>
<li>Exception 类有四个公开的构造方法，一般情况下，自定义异常类时这四个构造方法都要实现，可用于初始化额外的状态，或者定制异常消息；</li>
<li>不要在你的 API 中自定义很多细致的异常类——Java I/O 和反射 API 都因为这么做了而受人诟病，所以别让使用这些包时的情况变得更糟；</li>
<li>别在一个异常类型中描述太多状况——例如，实现 JavaScript 的 Nashorn 引擎（Java 8新功能）一开始有超多粗制滥造的异常，不过在发布之前修正了。</li>
</ul>
<h3 id="异常在子类覆盖中的体现"><a href="#异常在子类覆盖中的体现" class="headerlink" title="异常在子类覆盖中的体现:"></a>异常在子类覆盖中的体现:</h3><ol>
<li>子类覆盖父类时, 如果父类的方法抛出的异常,那么子类只能抛出父类异常或该异常的子类.          </li>
<li>如果父类方法抛出多个异常, 那么子类在覆盖方法时,只能抛出父类异常的子集.          </li>
<li>如果父类或借口的方法中没有异常抛出, 那么子类在覆盖方法时,也不可能抛出异常.如果子类方法发生异常,就必须进行try处理,绝对不能抛.</li>
</ol>
<h3 id="避免使用两种处理异常的反模式："><a href="#避免使用两种处理异常的反模式：" class="headerlink" title="避免使用两种处理异常的反模式："></a>避免使用两种处理异常的反模式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要捕获异常而不处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要捕获，记录日志后再重新抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SpecificException e)&#123;</span><br><span class="line">    log(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个反模式直接忽略近乎一定需要处理的异常状况（甚至没有在日志中记录）。这么做会增大系统其他地方出现问题的可能性——出现问题的地方可能会离原来的位置很远。</p>
<p>第二个反模式只会增加干扰——虽然记录了错误消息，但没真正处理发生的问题——在系统高层的某部分代码中还是要处理这个问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/08-抽象类与接口.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/08-抽象类与接口.html" class="post-title-link" itemprop="url">08 抽象类与接口</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 20:49:50" itemprop="dateCreated datePublished" datetime="2018-09-09T20:49:50+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p><strong>抽象类</strong>代表了一种优化了的概念组织方式,来描述事物的一般状态和行为,然后在子类中去实现这些状态和行为,以适应对象的多样性. </p>
</blockquote>
<h3 id="抽象类声明和实现"><a href="#抽象类声明和实现" class="headerlink" title="抽象类声明和实现"></a>抽象类声明和实现</h3><p>在Java中抽象类和抽象方法的修饰符是<code>abstract</code>, 注意抽象方法中只有方法的声明，没有方法的实现</p>
<ul>
<li>抽象类不能被实例化,只有具体类才能被实例化。</li>
<li>抽象类中是有默认的构造函数, 只供子类实例化调用。 </li>
<li>抽象类中可以包含具体方法和抽象方法</li>
</ul>
<pre><code class="java"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名称</span>{           
    member var;  
    method（）{…}       <span class="comment">//一般方法</span>
    <span class="function"><span class="keyword">abstract</span> <span class="title">method</span><span class="params">()</span>；  <span class="comment">//抽象方法, 抽象方法在后直接跟分号          </span></span>
<span class="function">  }</span>
</code></pre>
<p>普通类加上abstract关键字就变成了抽象类,没有任何条件限制.但是有抽象方法的类必须定义为抽象类,否则会提示<strong><code>The type XXX must be an abstract class to define abstract methods</code> </strong><br>　　<br>Q: 抽象关键字abstract不可以和哪些关键字共存？ 　　　　<br>A: <code>private</code>  私有内容子类继承不到，所以，不能重写. 但是，abstract修饰的方法，要求被重写。两者冲突。<br><code>final</code>   final修饰的方法不能被重写。而abstract修饰的方法，要求被重写。两者冲突。<br><code>static</code> 假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。 </p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>比抽象类更加抽象的是接口，在接口中所有的方法都是抽象的。</p>
<blockquote>
<p>提示　Java 8之后接口中新增加了默认方法，因此“接口中所有的方法都是抽象的”这个提法在Java 8之后是有待商榷。</p>
</blockquote>
<ul>
<li>Java中不支持多继承,而是通过接口实现比多重继承更强的功能,java通过接口可以使出于不同层次,甚至不相关的类具有相同的行为.</li>
<li>接口可以认为是特殊的抽象类, 不能用于直接创建对象.接口的作用在于规定一些功能框架,具体功能的实现则通过该接口约束的类完成. </li>
</ul>
<p>接口的定义:由常量和抽象方法组成  </p>
<pre><code class="java">[public] interface 接口名 [extends 父接口名列表 ]  {                 
    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 域类型 域名 = 常量值 ;                 
    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值 方法名(参数列表) [<span class="keyword">throw</span> 异常列表]；           
 }
</code></pre>
<ol>
<li>声明接口可给出访问控制符；  </li>
<li>一个接口还可以继承多个父接口，父接口间用逗号分隔。   </li>
<li>系统默认接口中所有属性的修饰都是public static final,毕老师说的全局常量.   </li>
<li>系统默认接口中所有方法的修饰都是public abstract;即抽象方法.  </li>
</ol>
<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><ul>
<li>定义了一套行为规范,一个类实现这个接口就是要遵守接口的定义规范,要实现接口中定义的所有方法.          </li>
<li>一个类可以实现多个接口。接口间用逗号分隔；  </li>
<li>如果实现某接口的类不是抽象类,则在类的定义部分必须实现指定接口的所有抽象方法;否则编译时会指示该类只能为抽象类是不能创建对象的.   </li>
<li>接口的抽象方法的访问限制符默认为public</li>
</ul>
<h3 id="Java-8新特性默认方法和静态方法"><a href="#Java-8新特性默认方法和静态方法" class="headerlink" title="Java 8新特性默认方法和静态方法"></a>Java 8新特性默认方法和静态方法</h3><p>Java 8在接口中提供了声明默认方法和静态方法的能力。接口示例代码如下：<br><code>`</code> java</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/07-java的继承与多态.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/07-java的继承与多态.html" class="post-title-link" itemprop="url">07 Java的继承与多态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 20:48:50" itemprop="dateCreated datePublished" datetime="2018-09-09T20:48:50+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java继承的实现(只支持单继承,而不是多继承,称为接口的多实现)<br>　　　　<br>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类. 定义类时直接通过extends关键字指明要继承的父类.<br>子类对象除了可以访问子类中直接定义的成员外,可直接访问父类的所有非私有成员.
　　</p>
<h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul>
<li>继承提高了代码的复用性。</li>
<li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li>
<li>不要仅为了获取其他类中某个功能而去继承,  类与类之间要有所属( “ is a “ )关系)。
　　<h3 id="How-如何使用一个继承体系中的功能"><a href="#How-如何使用一个继承体系中的功能" class="headerlink" title="How 如何使用一个继承体系中的功能:　　　　"></a>How 如何使用一个继承体系中的功能:　　　　</h3></li>
<li>查阅父类功能(定义了共性的功能)　　　　</li>
<li>创建子类对象使用功能(因为父类可能不能创建对象, 而且子类提供了更丰富的功能)</li>
<li>继承中自子类变量的特点:如果子类出现非私有的同名变量时, 子类访问本类变量用this, 子类访问父类中的同名变量用super.</li>
</ul>
<h3 id="成员变量隐藏"><a href="#成员变量隐藏" class="headerlink" title="成员变量隐藏"></a>成员变量隐藏</h3><p>子类成员变量与父类一样，会屏蔽父类中的成员变量，称为“成员变量隐藏”。</p>
<h3 id="方法的覆盖（Override）"><a href="#方法的覆盖（Override）" class="headerlink" title="方法的覆盖（Override）"></a>方法的覆盖（Override）</h3><p>如果子类方法完全与父类方法相同，即：相同的方法名、相同的参数列表和相同的返回值，只是方法体不同，这称为子类覆盖（Override）父类方法。</p>
<p>在声明方法时最后添加<code>@Override</code>注解，<code>@Override</code>注解不是方法覆盖必须的，它只是锦上添花，但添加@Override注解有两个好处：</p>
<ul>
<li>提高程序的可读性。</li>
<li>编译器检查@Override注解的方法在父类中是否存在，如果不存在则报错。</li>
</ul>
<h4 id="方法覆盖时应遵循的原则："><a href="#方法覆盖时应遵循的原则：" class="headerlink" title="方法覆盖时应遵循的原则："></a>方法覆盖时应遵循的原则：</h4><blockquote>
<ol>
<li>覆盖后的方法不能比原方法有更严格的访问控制（可以相同）。例如将代码第②行访问控制public修改private，那么会发生编译错误，因为父类原方法是protected。</li>
<li>覆盖后的方法不能比原方法产生更多的异常。</li>
<li>父类中的私有方法不可以被覆盖。</li>
</ol>
</blockquote>
<h4 id="覆盖的应用："><a href="#覆盖的应用：" class="headerlink" title="覆盖的应用："></a>覆盖的应用：</h4><ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以复写父类中的方法，这样也沿袭了父类的功能</li>
<li>构造方法在类继承中的作用<br> 构造方法不能继承.由于子类对象要对来自父类的成员进行初始化,因此,在创建子类对象时除了执行子类的构造方法外,还需要调用父类的构造方法.具体遵循如下原则:<ol>
<li>当子类未定义构造方法时,创建对象时将无条件地调用父类的空构造方法,以为每行第一条super(); </li>
<li>对于父类的含参数构造方法,子类可以在自己构造方法中使用关键字super来调用它, 但super调用语句必须是子类构造方法中的<strong>第一个</strong>可执行语句； </li>
<li>子类在自己定义构造方法中如果没有用super明确调用父类的构造方法，则在创建对象时,将自动先执行父类的无参构造方法,然后再执行自己定义的构造方法。<br>所以在一个类的设计时如果有构造方法,最好提供一个无参构造方法.因此,系统类库中的类大多提供了无参构造方法,用户编程时最好也要养成此习惯.     <blockquote>
<p>【注意】使用this查找匹配的方法时首先在本类查找，找不到时再到其父类和祖先类查找；使用 super 查找匹配方法时，首先到直接父类查找，如果不存在，则继续到其祖先类逐级往高层查找。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>体现在父类或者接口的引用指向或者接收自己的子类对象<br>作用：多态的存在提高了程序的扩展性和后期可维护性.</p>
<p>发生多态要有三个前提条件：</p>
<ol>
<li>继承。多态发生一定要子类和父类之间。</li>
<li>覆盖。子类覆盖了父类的方法。</li>
<li>声明的变量类型是父类类型，但实例则指向子类实例。</li>
</ol>
<h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><p>并不是所有的引用类型都能互相转换，只有属于同一棵继承层次树中的引用类型才可以转换。</p>
<p>类型转换有两个方向：</p>
<ul>
<li>将父类引用类型变量转换为子类类型，这种转换称为向下转型（downcast）；</li>
<li>将子类引用类型变量转换为父类类型，这种转换称为向上转型（upcast）。向下转型需要强制转换，而<strong>向上转型是自动的</strong>。</li>
</ul>
<p>将父类引用赋值给子类变量时要进行强制转换，强制转换在编译时总是认可的，但运行时的情况取决于对象的值.如果父类对象引用指向的就是该子类的一个对象,则转换是成功的.否则会抛出<code>ClassCastException</code>. 如果不能确定实例是哪一种类型，可以在转型之前使用<code>instanceof</code>运算符判断一下。</p>
<h2 id="UML图简介"><a href="#UML图简介" class="headerlink" title="UML图简介"></a>UML图简介</h2><blockquote>
<p>UML是Unified Modeling Language的缩写，即统一标准建模语言。它集成了各种优秀的建模方法学发展而来的。UML图常用的有例图、协作图、活动图、序列图、部署图、构件图、类图、状态图。</p>
</blockquote>
<p>面向对象分析与设计（OOAD）时，会用到UML图，其中类图非常重要，用来描述系统静态结构。Student继承Person的类图如图12-1所示。类图中的各个元素说明如图12-2所示，类用矩形表示，一般分为上、中、下三个部分，上部分是类名，中部分是成员变量，下部分是成员方法。实线+空心箭头表示继承关系，箭头指向父类，箭头末端是子类。UML类图中还有很多关系，如图12-3所示，如图虚线＋空心箭头表示实线关系，箭头指向接口，箭头末端是实线类。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-a3e3088cc59363cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图中的元素"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/06-常用java类.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/06-常用java类.html" class="post-title-link" itemprop="url">06 常用Java类</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 20:43:50" itemprop="dateCreated datePublished" datetime="2018-09-09T20:43:50+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>Java中的字符串是由双引号括起来的多个字符，下面示例都是表示<strong>字符串常量</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello World"</span>                                                             </span><br><span class="line"><span class="string">"\u0048\u0065\u006c\u006c\u006f\u0020\u0057\u006f\u0072\u006c\u0064"</span>      </span><br><span class="line"><span class="string">"世界你好"</span>                                                                 </span><br><span class="line"><span class="string">"A"</span>                                                                       </span><br><span class="line"><span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Java中的字符采用Unicode编码，所以Java字符串可以包含中文等亚洲字符<br>字符串还有一个极端情况，就代码第⑤行的””表示空字符串，双引号中没有任何内容，空字符串不是null，空字符串是分配内存空间，而null是没有分配内存空间。</p>
</blockquote>
<p>Java SE提供了三个字符串类：String、StringBuffer和StringBuilder。String是不可变字符串，StringBuffer和StringBuilder是可变字符串。</p>
<h3 id="String常用的构造方法"><a href="#String常用的构造方法" class="headerlink" title="String常用的构造方法"></a>String常用的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String()：使用空字符串创建并初始化一个新的String对象。</span><br><span class="line"></span><br><span class="line">String(String original)：使用另外一个字符串创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(StringBuffer buffer)：使用可变字符串对象（StringBuffer）创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(StringBuilder builder)：使用可变字符串对象（StringBuilder）创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes)：使用平台的默认字符集解码指定的<span class="keyword">byte</span>数组，通过<span class="keyword">byte</span>数组创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">char</span>[] value)：通过字符数组创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)：通过字符数组的子数组创建并初始化一个新的 String 对象；offset参数是子数组第一个字符的索引，count参数指定子数组的长度。</span><br></pre></td></tr></table></figure>
<h3 id="String的查找"><a href="#String的查找" class="headerlink" title="String的查找"></a>String的查找</h3><p>在给定的字符串中查找字符或字符串是比较常见的操作。在String类中提供了indexOf和lastIndexOf方法用于查找字符或字符串，返回值是查找的字符或字符串所在的位置，-1表示没有找到。这两个方法有多个重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>：从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>：从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="String的比较"><a href="#String的比较" class="headerlink" title="String的比较"></a>String的比较</h3><ol>
<li>比较相等<br>String提供的比较字符串相等的方法：</li>
</ol>
<ul>
<li>boolean equals(Object anObject)：比较两个字符串中内容是否相等。</li>
<li>boolean equalsIgnoreCase(String anotherString)：类似equals方法，只是忽略大小写。</li>
</ul>
<ol start="2">
<li>比较大小<br>有时不仅需要知道是否相等，还要知道大小，String提供的比较大小的方法：</li>
</ol>
<ul>
<li>int compareTo(String anotherString)：按字典顺序比较两个字符串(字典中顺序事实上就<strong>它的Unicode编码</strong>)。如果参数字符串等于此字符串，则返回值 0；如果此字符串小于字符串参数，则返回一个小于 0 的值；如果此字符串大于字符串参数，则返回一个大于 0 的值。</li>
<li>int compareToIgnoreCase(String str)：类似compareTo，只是忽略大小写。</li>
</ul>
<ol start="3">
<li>比较前缀和后缀</li>
</ol>
<ul>
<li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li>
<li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li>
</ul>
<h3 id="String的字符串截取方法"><a href="#String的字符串截取方法" class="headerlink" title="String的字符串截取方法"></a>String的字符串截取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：从指定索引beginIndex开始截取一直到字符串结束的子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span>：从指定索引beginIndex开始截取直到索引endIndex - 1处的字符，注意包括索引为beginIndex处的字符，但不包括索引为endIndex处的字符。</span></span><br></pre></td></tr></table></figure>
<p>另外，String还提供了字符串分割方法<code>split(&quot; &quot;)</code>方法，参数是分割字符串，返回值String[]。</p>
<h2 id="可变字符串-StringBuffer和StringBuilder"><a href="#可变字符串-StringBuffer和StringBuilder" class="headerlink" title="可变字符串 StringBuffer和StringBuilder"></a>可变字符串 StringBuffer和StringBuilder</h2><blockquote>
<p>Java提供了两个可变字符串类StringBuffer和StringBuilder，中文翻译为“字符串缓冲区”。<br>StringBuffer是线程安全的，它的方法是支持线程同步，线程同步会操作串行顺序执行，在单线程环境下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它的执行效率很高。</p>
</blockquote>
<p>StringBuffer和StringBuilder具有完全相同的API，即构造方法和方法等内容一样。StringBuilder的中构造方法有4个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder()：创建字符串内容是空的StringBuilder对象，初始容量默认为<span class="number">16</span>个字符。</span><br><span class="line"></span><br><span class="line">StringBuilder(CharSequence seq)：指定CharSequence字符串创建StringBuilder对象。CharSequence接口类型，它的实现类有：String、StringBuffer和StringBuilder等，所以参数seq可以是String、StringBuffer和StringBuilder等类型。</span><br><span class="line"></span><br><span class="line">StringBuilder(<span class="keyword">int</span> capacity)：创建字符串内容是空的StringBuilder对象，初始容量由参数capacity指定的。</span><br><span class="line"></span><br><span class="line">StringBuilder(String str)：指定String字符串创建StringBuilder对象。</span><br></pre></td></tr></table></figure></p>
<h3 id="StringBuffer的追加、插入、删除和替换"><a href="#StringBuffer的追加、插入、删除和替换" class="headerlink" title="StringBuffer的追加、插入、删除和替换"></a>StringBuffer的追加、插入、删除和替换</h3><ul>
<li>字符串追加方法是append，append有很多重载方法，可以追加任何类型数据。</li>
<li>StringBuilder insert(int offset, String str)：在字符串缓冲区中索引为offset的字符位置之前插入str，insert有很多重载方法，可以插入任何类型数据。</li>
<li>StringBuffer delete(int start, int end)：在字符串缓冲区中删除子字符串，要删除的子字符串从指定索引start开始直到索引end - 1处的字符。start和end两个参数与substring(int beginIndex, int endIndex)方法中的两个参数含义一样。</li>
<li>StringBuffer replace(int start, int end, String str)字符串缓冲区中用str替换子字符串，子字符串从指定索引start开始直到索引end - 1处的字符。start和end同delete(int start, int end)方法。</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>所有Java类的最终祖先,编译系统默认继承Object类,Object类包含了所有Java类的公共属性和方法</p>
<p>按道理应该熟悉Object的每个方法<br><code>getClass():Class&lt;?&gt;</code><br><code>public boolean equals(Object obj)</code> :该方法本意用于两个对象的“深度”比较，也就是比较两对象封装的数据是否相等；而比较运算符“==”在比较两对象变量时，只有当两个对象引用指向同一对象时才为真值。但在Object类中，equals方法是采用“==”运算进行比较；<br><code>hashCode()</code><br><code>public String toString()</code>:该方法返回对象的字符串描述,<strong>建议所有子类都重写此方法</strong>。<br><code>notify(), notifyAll, wait(), wait(long), wait(long, int),</code>       </p>
<p><code>protected  Object clone()</code>: 克隆<br><code>protected  void  finalize()</code>: 该方法Java垃圾回收程序在删除对象前自动执行。目前不建议开发者直接调用.      </p>
<h2 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">的主要方法 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ceil</span><span class="params">(<span class="keyword">int</span> i1,<span class="keyword">int</span> i2)</span>      大于等于d的最大整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> d)</span> 小于等于d的最大整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">random</span><span class="params">()</span>         返回大于等于 0.0 且小于 1.0的 <span class="keyword">double</span> 值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>   <span class="title">round</span><span class="params">(<span class="keyword">double</span> d)</span>  最靠近d的长整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> d)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p> /<em>由于让系统产生随机数使用<br>0~9的随机数 (int)(Math.random()</em>10);<br>0~999的随机数 (int)(Math.random()<em>1000);<br>a~b的随机数 (int)(Math.random()</em>(b-a));<br>其实Math的random方法用的就是util包中的Random类<br>因此可以Random.nextDouble()替换Math.random()<br>*/</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/05-类和对象.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/05-类和对象.html" class="post-title-link" itemprop="url">05 类和对象</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 20:30:25" itemprop="dateCreated datePublished" datetime="2018-09-09T20:30:25+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>面向对象是Java最重要的特性。Java是彻底的、纯粹的面向对象语言，在Java中“一切都是对象”。本章将介绍面向对象基础知识。</p>
</blockquote>
<p>面向对象</p>
<ul>
<li>相对面向过程而言, 面向对象和面向过程都是一种思想</li>
<li>将功能封装进对象，强调具备了功能的对象。</li>
<li>是一种符合人们思考习惯的思想, 可以将复杂的事情简单化, 将程序员从执行者转换成了指挥者.</li>
</ul>
<p>面向对象的开发过程: 其实就是不断的创建对象，使用对象，指挥对象做事情。<br>面向对象的设计过程: 其实就是在管理和维护对象之间的关系。</p>
<p>面向对象的特征：</p>
<ul>
<li>封装(encapsulation): 封装能够使外部访问者不能随意存取对象的内部数据，隐藏了对象的内部细节，只保留有限的对外接口。外部访问者不用关心对象的内部细节，使得操作对象变得简单。</li>
<li>继承(inheritance)</li>
<li>多态(polymorphism): 指在父类中成员变量和成员方法被子类继承之后，可以具有不同的状态或表现行为。</li>
</ul>
<h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>Java中用类<code>Class</code>来描述事物.是具体事物的抽象，概念上的定义。</p>
<ul>
<li>属性：对应类中的成员变量。</li>
<li>行为：对应类中的成员函数。</li>
</ul>
<p>类定义包括类声明和类体两部分,类定义的语法格式如下:<br><code>[public][abstract|final] class className [extends superclassName] [implements interfaceNameList]  {类体}</code></p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>创建对象及访问对象成员　　</p>
<ol>
<li>声明对象与声明普通变量没有区别 ，格式：<code>type objectName;</code>　<br>声明并不为对象分配内存空间，而只是<strong>分配一个引用</strong></li>
<li>实例化对象。分为两个阶段：为对象分配内存空间和初始化对象，首先使用<strong>new运算符</strong>为对象分配内存空间，然后再<strong>调用构造方法</strong>初始化对象。格式如下：<code>new 类的构造方法();</code>             </li>
<li>通过引用变量访问对象成员               </li>
</ol>
<ul>
<li>引用变量名.属性               </li>
<li>引用变量名.方法名（实参表）  </li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法　"></a>构造方法　</h3><p>作用: 给对象进行初始化</p>
<h4 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h4><ul>
<li>构造方法的名称必须与类名同名；                     </li>
<li>构造方法没有返回类型, 包括void, 所以不可以写return语句; </li>
<li>构造方法只能与new运算符结合使用;</li>
<li>通常一个类可提供多个构造方法，这些方法的参数不同。在创建对象<br>时，系统自动调用参数匹配的构造方法为对象初始化</li>
<li>如果一个类未指定构造方法，则系统自动提供的无参构造方法，但如果自定义了构造方法，则系统不再提供无参构造方法。<br>无参构造方法形式如下： public Person() { } , 所以自己最好还要默默的加入无参构造方法 </li>
<li>什么时候定义构造方法: 当分析事物时, 该事物具备一定特性或行为, 可以将这些内容定义在构造方法中.</li>
</ul>
<blockquote>
<p>一个类默认有一个空参数的构造函数,这个构造函数的权限与所属类一致. 如果类被public修饰,则默认的构造函数也被public修饰.总之<strong>默认构造函数的权限是随着类</strong>而变化.</p>
</blockquote>
<h4 id="对象的初始化和构造方法"><a href="#对象的初始化和构造方法" class="headerlink" title="对象的初始化和构造方法"></a>对象的初始化和构造方法</h4><p>在创建对象时，要给对象的属性成员分配内存空间，同时进行初始化。 </p>
<ol>
<li>如果定义属性成员时没有指定初值，则系统自动指定初值.在定义属性成员时也可以指定初值.public class Point {private int x=10;    ……</li>
<li>指定初值的另一种办法是通过初始化块来设置对象的初值(也叫做构造代码块,它是给所有对象进行统一初始化)。<br>//注意首先是按照属性定义的初值,然后是初始化块,</li>
<li>最后是构造方法:构造方法是给对相关设置初值的规范方法,构造方法是根据方法参数给对象属性赋不同的值</li>
</ol>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>声明类体中成员变量语法格式如下：<br><code>[public | protected | private ] [static] [final] type variableName;    //成员变量</code></p>
<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p><code>[public | protected | private ] [static] [final | abstract] [native] [synchronized] type methodName([paramList]) [throws exceptionList] {
                         //方法体
}</code></p>
<h3 id="静态-static-方法"><a href="#静态-static-方法" class="headerlink" title="静态(static)方法"></a>静态(static)方法</h3><p>用static修饰的属性是属于类的静态属性, 相应的成员变量为类变量         </p>
<ol>
<li><p>类变量的访问形式               </p>
<ul>
<li>在本类中直接访问：count </li>
<li>通过类名访问：User.count                </li>
<li>不建议通过类的一个对象访问，如：x1.count, 实际上还是通过类名的方式访问</li>
</ul>
</li>
<li><p>给类变量赋初值<br>默认赋值即可,也可以用静态初始化代码块 static{count=100;}<br>//静态初始化代码的执行是在main方法执行前完成。
　　　</p>
</li>
<li>被static修饰的类成员特点：是共享数据, 随着类的加载而加载, 优先于对象存在, 被所有对象所共享, 可以直接被类名调用.</li>
</ol>
<h3 id="静态方法-当功能内部没访问对象特有数据时使用"><a href="#静态方法-当功能内部没访问对象特有数据时使用" class="headerlink" title="静态方法 (当功能内部没访问对象特有数据时使用)"></a>静态方法 (当功能内部没访问对象特有数据时使用)</h3><p>用 static修饰的方法称为静态方法，也叫类方法. 在static方法中只能处理类变量，也可访问其它static方法，但绝不能直接访问任何归属对象空间的变量或方法.　</p>
<ul>
<li>静态方法中不可以写this，super关键字</li>
<li>主函数是静态方法. </li>
</ul>
<p>tip: 创建某个工具类, 只提供相应的静态方法, 为了让某个类不能创建对象, 可以私有化构造函数.</p>
<h2 id="理解this和super"><a href="#理解this和super" class="headerlink" title="理解this和super"></a>理解this和super</h2><p>出现在类的实例方法或构造方法中，this代表所在函数所属对象的引用 .用this作前缀可访问当前对象的实例变量或成员方法.          </p>
<ol>
<li>this.实例变量;          </li>
<li>this.成员方法;          </li>
<li>this(参数),用来调用同类其他构造方法.注意this语句只能定义在构造函数的第一行,因为初始化要先执行.</li>
</ol>
<p>而super和this差不多,都是一个引用指向自身和上一级父类罢了  </p>
<h3 id="对象初始化过程总结"><a href="#对象初始化过程总结" class="headerlink" title="对象初始化过程总结　　"></a>对象初始化过程总结　　</h3><ol>
<li>new 用到了class文件,所以先回找到class文件并加载到内存　　</li>
<li>执行类的static {}代码块　　</li>
<li>在堆内存中开辟空间,分配内存地址　　</li>
<li>在堆内存中建立对象的特有属性,病默认初始化　</li>
<li>对属性显示初始化;　　</li>
<li>构造代码快初始化{};　　</li>
<li>构造函数初始化;　　</li>
<li>将内存地址赋给栈内存变量.</li>
</ol>
<h2 id="使用包组织类"><a href="#使用包组织类" class="headerlink" title="使用包组织类"></a>使用包组织类</h2><blockquote>
<p>在Java中为了防止类、接口、枚举和注释等命名冲突引用了包（package）概念，包本质上命名空间（namespace）。在包中可以定义一组相关的类型（类、接口、枚举和注释），并为它们提供访问保护和命名空间管理。</p>
</blockquote>
<p>package语句定义包，package语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句，并且package语句适用于所有类型（类、接口、枚举和注释）的文件。定义包语法格式如下：<code>package pkg1[.pkg2[.pkg3…]];</code></p>
<p>Java API简介: Java中按包来组织类.包的组织采用分层结构,与文件系统中的目录的组织对应一致.通常将逻辑相关的类放在同一个包中.<br>包将类的命名空间进行有效划分,同一包中不能有两个同名的类. Java系统提供的类库也成为Java API, 是系统提供的已实现的标准类的集合.  </p>
<h3 id="建立包"><a href="#建立包" class="headerlink" title="建立包"></a>建立包</h3><p>创建包就是在指定目录路径下创建一个 子文件夹 ,这个包中所有类的字节码文件将存放在该文件夹下.</p>
<p>方法1: 创建一个test子目录，将源程序文件存放到该目录，在该目录下利用javac编译源代码，或者在别处编译完程序后将字节码文件拷贝到该目录即可。<br>方法2: 采用带路径指示的编译命令： 格式：<code>javac –d  destpath Point.java</code>  </p>
<p>编译器将自动在destpath指定的目录下建一个test子目录，并将产生的字节码文件保存到该子目录下 </p>
<p>典型用法是源程序放在当前目录下,<br>用如下命令编译 <code>javac –d . Point.java</code><br>编译后将在当前目录自动创建test子目录</p>
<h3 id="包的引用"><a href="#包的引用" class="headerlink" title="包的引用"></a>包的引用</h3><ol>
<li>在引用类时使用包名作前缀例 ：new java.util.Date() </li>
<li>用import语句加载需要使用的类。例:import java.util.Date; 然后在程序中可以直接通过类名创建对象, 如：new Date(); </li>
<li>用import语句加载整个包, 用<code>*</code>号代替类名位置。 它将加载包中的所有的类。例：<code>import java.util.*;</code></li>
</ol>
<blockquote>
<p>小知识:使用javadoc制作帮助文档　<br><code>javadoc -d destpath -version -author Tools.java</code></p>
</blockquote>
<h2 id="封装性与访问控制"><a href="#封装性与访问控制" class="headerlink" title="封装性与访问控制"></a>封装性与访问控制</h2><p>Java面向对象的封装性是通过对成员变量和方法进行访问控制实现的，访问控制分为4个等级：私有、默认、保护和公有<br><img src="https://upload-images.jianshu.io/upload_images/1662509-496751fa2a911c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java类成员的访问控制"></p>
<ul>
<li>公有级别的关键字是public，公有级别的成员变量和方法可以在任何场合被直接访问，是最宽松的一种访问控制等级。</li>
<li>保护级别的关键字是protected，保护级别在同一包中完全与默认访问级别一样，但是不同包中子类能够继承父类中的protected变量和方法，这就是所谓的保护级别，“保护”就是保护某个类的子类都能继承该类的变量和方法。</li>
<li>默认级别没有关键字，也就是没有访问修饰符，默认级别的成员变量和方法，可以在其所在类内部和同一个包的其他类中被直接访问，但在不同包的类中则不允许直接访问。</li>
<li>私有级别的关键字是private，私有级别的成员变量和方法只能在其所在类的内部自由使用，在其他的类中则不允许直接访问。</li>
</ul>
<blockquote>
<p>提示　访问类成员时，在能满足使用的前提下，应尽量限制类中成员的可见性，访问级别顺序是：私有级别→默认级别→保护级别→公有级别。</p>
</blockquote>
<h2 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h2><p>对象不再使用时应该销毁。C++语言对象是通过delete语句手动释放，Java语言对象是由垃圾回收器（Garbage Collection）收集然后释放，程序员不用关心释放的细节。自动内存管理是现代计算机语言发展趋势，例如：C#语言的垃圾回收，Objective-C和Swift语言的ARC（内存自动引用计数管理）。</p>
<p>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/04-java数组.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/04-java数组.html" class="post-title-link" itemprop="url">04 Java数组</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 20:18:36" itemprop="dateCreated datePublished" datetime="2018-09-09T20:18:36+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在计算机语言中数组是非常重要的集合类型，大部分计算机语言中数组具有如下三个基本特性：</p>
<ol>
<li>一致性：数组只能保存<strong>相同数据类型</strong>元素，元素的数据类型可以是任何相同的数据类型。</li>
<li>有序性：数组中的元素是有序的，通过下标访问。</li>
<li><p>不可变性：数组一旦初始化，则<strong>长度（数组中预分配的元素个数）不可变</strong>。</p>
<h2 id="一维数组-声明数组-创建数组空间-初始化三步"><a href="#一维数组-声明数组-创建数组空间-初始化三步" class="headerlink" title="一维数组: 声明数组,创建数组空间,初始化三步."></a>一维数组: 声明数组,创建数组空间,初始化三步.</h2></li>
</ol>
<p>格式1： 元素类型[]  数组名(推荐采用) ;<br>格式2： 元素类型  数组名[] ;<br> 其中，数组元素的类型可以是基本类型，也可以是类或接口。   </p>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>声明完成就要对数组进行初始化，数组初始化的过程就是为数组每一个元素分配内存空间，并为每一个元素提供初始值。初始化之后数组的长度就确定下来不能再变化了。 </p>
<p>数组初始化可以分为静态初始化和动态初始化。</p>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>静态初始化就是<strong>将数组的元素放到大括号中</strong>，元素之间用逗号（,）分隔。<br>使用场景: 在已知数组的每一个元素内容情况下使用的，这样一次到位。<br>示例代码如下：<code>String[] strArray = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;}; //静态初始化Stirng数组</code></p>
<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>动态初始化使用new运算符分配指定长度的内存空间，<br>语法如下：<code>new 元素数据类型[数组长度] ;</code></p>
<p>new分配数组内存空间后，不同类型都会有默认值，如下图。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-4087e8f4537c5156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据类型默认值"></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组声明"><a href="#二维数组声明" class="headerlink" title="二维数组声明"></a>二维数组声明</h3><p>当数组中每个元素又可以带有多个下标时，这种数组就是“多维数组”。<br>Java中声明二维数组需要有两个中括号，具体有三种语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">元素数据类型[][] 数组变量名;</span><br><span class="line">元素数据类型 数组变量名[][];</span><br><span class="line">元素数据类型[] 数组变量名[];</span><br></pre></td></tr></table></figure></p>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的初始化也可以分为静态初始化和动态初始化。</p>
<h4 id="静态初始化-1"><a href="#静态初始化-1" class="headerlink" title="静态初始化"></a>静态初始化</h4><p><code>int intArray[][] = { { 1, 2, 3 }, { 11, 12, 13 }, { 21, 22, 23 }, { 31, 32, 33 } };</code></p>
<blockquote>
<p>提示　严格意义上说Java中并不存在真正意义上的多维数组，只是一维数组，不过数组中的元素也是数组，以此类推三维数组就是数组的数组的数组了，例如{ { {1, 2}, {3} }, { {21}, {22, 23} } }表示一个三维数组。</p>
</blockquote>
<h4 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>语法: <code>new 元素数据类型[高维数组长度] [低维数组长度] ;</code></p>
<h2 id="3-不规则数组"><a href="#3-不规则数组" class="headerlink" title="3. 不规则数组"></a>3. 不规则数组</h2><p>由于Java多维数组是数组的数组，因此会衍生出一种不规则数组<br>动态初始化不规则数组比较麻烦，不能使用new int[4][3]语句，而是先初始化高维数组，然后再分别逐个初始化低维数组。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//先初始化高维数组为4</span></span><br><span class="line"><span class="comment">//逐一初始化低维数组</span></span><br><span class="line">intArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">intArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">intArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">intArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1662509-e1054034bc816264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="4-其它"><a href="#4-其它" class="headerlink" title="4. 其它"></a>4. 其它</h2><p> <img src="http://upload-images.jianshu.io/upload_images/1662509-961f0a169874ae4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组的内存结构"></p>
<p>数组中常见的Exception:</p>
<ul>
<li>访问到不存在的角标: ArrayIndexOutOfBoundsException　　</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/03-java流程控制语句.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/03-java流程控制语句.html" class="post-title-link" itemprop="url">03 Java流程控制语句</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 12:48:50" itemprop="dateCreated datePublished" datetime="2018-09-09T12:48:50+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java中的控制语句有以下三类：</p>
<ol>
<li>分支语句：if和switch</li>
<li>循环语句：while、do-while和for</li>
<li>跳转语句：break、continue、return和throw</li>
</ol>
<h2 id="条件选择语句"><a href="#条件选择语句" class="headerlink" title="条件选择语句:"></a>条件选择语句:</h2><h3 id="if型-if-else型-if-else嵌套型-之间可以相互嵌套"><a href="#if型-if-else型-if-else嵌套型-之间可以相互嵌套" class="headerlink" title="if型,if else型,if else嵌套型 (之间可以相互嵌套)"></a>if型,if else型,if else嵌套型 (之间可以相互嵌套)</h3><p>如果条件体只有一句话,大括号可以省略但不建议, 极短的可以写成一行, 例如<code>if (flag) doSomeThing();</code></p>
<blockquote>
<p>else-if结构实际上是if-else结构的多层嵌套，它明显的特点就是在多个分支中只执行一个语句组，而其他分支都不执行，所以这种结构可以用于有多种判断结果的分支中。</p>
</blockquote>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul>
<li>其中expression必须为<code>byte</code>,<code>short</code>,<code>char</code>, <code>int</code>, JDK1.5新增<code>enum</code>枚举,  JDK1.5新增<code>String</code>类型 </li>
<li>default实现所有case都没捕获到的情况 </li>
<li>case 0: case 1: case 2: { } 实现了多个case对应一种情况. </li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul>
<li>共3种while, do while, for</li>
<li>for和while循环是在执行循环体之前测试循环条件</li>
<li>Java 5之后推出for-each循环语句，for-each循环是for循环的变形，它是专门为集合遍历而设计的，注意for-each并不是一个关键字。</li>
<li>循环体内部必须通过语句更改循环变量的值，否则将会发生死循环。</li>
</ul>
<h3 id="while-和-do-while"><a href="#while-和-do-while" class="headerlink" title="while 和 do while"></a>while 和 do while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do while</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125; <span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for语句是应用最广泛、功能最强的一种循环语句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 循环条件; 迭代) &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个无限循环</span></span><br><span class="line"><span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示　初始化、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。代码如下：</p>
</blockquote>
<h3 id="for-each语句"><a href="#for-each语句" class="headerlink" title="for-each语句"></a>for-each语句</h3><p>Java 5之后提供了一种专门用于遍历集合的for循环——for-each循环。使用for-each循环不必按照for的标准套路编写代码，只需要提供一个<strong>集合</strong>或<strong>数组</strong>就可以遍历。</p>
<blockquote>
<p>item不是循环变量，它保存了集合中的元素, 他只是一个临时变量, 因此不能做删除元素和替换元素的工作</p>
</blockquote>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>break、continue、throw和return。本节重点介绍break和continue语句的使用。</p>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句可用于上一节介绍的while、repeat-while和for循环结构，它的作用是强行退出循环体，不再执行循环体中剩余的语句。</p>
<p>在循环体中使用break语句有两种方式：带有标签和不带标签。语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;           <span class="comment">//不带标签</span></span><br><span class="line"><span class="keyword">break</span> label;     <span class="comment">//带标签，label是标签名, 例如 label: for循环</span></span><br></pre></td></tr></table></figure></p>
<h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue语句用来结束本次循环，跳过循环体中尚未执行的语句，接着进行终止条件的判断，以决定是否继续循环。对于for语句，在进行终止条件的判断前，还要先执行迭代语句。</p>
<p>在循环体中使用continue语句有两种方式可以带有标签，也可以不带标签。语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;          <span class="comment">//不带标签</span></span><br><span class="line"><span class="keyword">continue</span> label;    <span class="comment">//带标签，label是标签名 , 例如 label: while循环</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>break添加标签的意义，添加标签对于多层嵌套循环是很有必要的，适当使用可以提高程序的执行效率。</p>
</blockquote>
<blockquote>
<p>break和continue关键字比较:</p>
<ul>
<li>break既用在循环语句中,也可用在条件选择语句中的switch语句. </li>
<li>contine只用在循环语句中,作用是结束本次循环,接着继续进行条件判断</li>
<li>break只会跳出最近的内循环</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/09/02-java的运算符、表达式.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/09/02-java的运算符、表达式.html" class="post-title-link" itemprop="url">02 Java的运算符、表达式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 09:10:25" itemprop="dateCreated datePublished" datetime="2018-09-09T09:10:25+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Java语言中的运算符（也称操作符）在风格和功能上都与C 和C++极为相似。</p>
</blockquote>
<ul>
<li>按操作数分为一元,二元和三元</li>
<li>按照功能: 包含算术,关系,逻辑,位,赋值组合等几种运算符.</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-e82822fe9eda987f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运算符优先级从高到低"></p>
<blockquote>
<p>总结　运算符优先级大体顺序，从高到低是：算术运算符→位运算符→关系运算符→逻辑运算符→赋值运算符。</p>
</blockquote>
<ul>
<li>==和!=可以应用于基本数据类型和引用数据类型。当用于引用数据类型比较时，比较的是两个引用是否指向同一个对象，但在当时实际开发过程中多数情况下，只是比较对象的内容是否相当，不需要比较是否为同一个对象。</li>
<li>提示　短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程时，应该优先考虑使用短路与和短路或。</li>
<li>有符号右移n位，相当于操作数除以2n。另外，左位移n位，相当于操作数乘以2n。</li>
<li>比较运算符得到的结果是true or false布尔常量</li>
<li>位运算符注意 <strong>异或</strong> <code>^</code>是不同为真，相同为假。<code>10为1</code> <code>11为0</code>; 若一个数异或2次或2次的倍数有还原的效果</li>
<li>三元运算符格式: <code>(条件表达式) ? 表达式1 : 表达式2;</code></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1662509-484dff3540e98375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="位运算符"></p>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><ul>
<li>除了前面介绍的主要运算符，Java还有一些其他运算符。<br>三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。</li>
<li>小括号。起到改变表达式运算顺序的作用，它的优先级最高。<br>中括号。数组下标。</li>
<li>引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符。</li>
<li>赋值号（=）。赋值是用等号运算符（=）进行的。</li>
<li>instanceof。判断某个对象是否为属于某个类。</li>
<li>new。对象内存分配运算符。</li>
<li>箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。</li>
<li>双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。</li>
</ul>
<h2 id="考考你"><a href="#考考你" class="headerlink" title="考考你"></a>考考你</h2><p>Q: “6+6”+6+6 的输出结果<br>A: 是 6+666, 这是”+”字符连接符导致.</p>
<p>Q: -2%5<br>A: 为-2(算术运算符中除法符号看左边就行。)</p>
<p>关于<code>instance of</code>关键字<br><code>(Integer)null</code>编译和运行完美通过, 结果为null<br><code>null instanceof 任意类</code> 都为false</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java语言程序设计》华东交大版 丁振凡 主编</p>
<p>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></p>
<p>Java从小白到大牛-图书-图灵社区<br><a href="http://www.ituring.com.cn/book/2480" target="_blank" rel="noopener">http://www.ituring.com.cn/book/2480</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/09/08/01-java的数据类型.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/html/java/2018/09/08/01-java的数据类型.html" class="post-title-link" itemprop="url">01 Java的数据类型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-08 23:41:24" itemprop="dateCreated datePublished" datetime="2018-09-08T23:41:24+08:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>在声明变量或常量时会用到数据类型，在前面已经用到一些数据类型，例如int、double和String等。Java语言的数据类型分为：八种基本类型和三种引用类型(数组, class, interface)。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1662509-ee14eb10d52d0d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="几种数据类型"><a href="#几种数据类型" class="headerlink" title="几种数据类型"></a>几种数据类型</h2><h3 id="整型-整数类型"><a href="#整型-整数类型" class="headerlink" title="整型(整数类型)"></a>整型(整数类型)</h3><ul>
<li>整型分为long、int、short和byte四种类型</li>
<li><strong>默认为int</strong>, byte、short、int和long ，它们之间的区别仅仅是<strong>宽度和范围</strong>的不同。</li>
<li>Java中整数都是有符号，与C不同没有无符号的整数类型。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-fe7aad922e691e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<h3 id="浮点型-小数类型"><a href="#浮点型-小数类型" class="headerlink" title="浮点型(小数类型)"></a>浮点型(小数类型)</h3><ul>
<li>浮点型常量后面加后缀修饰, Float类型以F/f结尾，double类型以D/d结尾。</li>
<li>如果浮点常量不带后缀，则默认为<strong>双精度</strong>常量<br><img src="https://upload-images.jianshu.io/upload_images/1662509-1fa1a7780e9f9ff2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<h4 id="数字表示方式"><a href="#数字表示方式" class="headerlink" title="数字表示方式"></a>数字表示方式</h4><h5 id="进制数字表示"><a href="#进制数字表示" class="headerlink" title="进制数字表示"></a>进制数字表示</h5><p>Java中对整型数据的表示有以下三种形式：  </p>
<pre><code>- 二进制：数据以`0b`或`0B`开头，例如：`4`，`-15`
- 八进制：数据以`0`开头，例如：`054`，`012`
- 十六进制：数据以`0x`或`0X`开头，例如：`0x11`，`0xAD00 `
</code></pre><h5 id="指数表示"><a href="#指数表示" class="headerlink" title="指数表示"></a>指数表示</h5><p>进行数学计算时往往会用到指数表示的数值。如果采用<strong>十进制</strong>表示指数，需要使用大写或小写的e表示幂，e2表示102。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> myMoney = <span class="number">3.36e2</span>;</span><br><span class="line"><span class="keyword">double</span> interestRate = <span class="number">1.56e-2</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul>
<li>Java中char声明字符类型</li>
<li>必须用单引号括起来的单个字符</li>
<li>双字节国际统一标准Unicode编码，占两个字节（16位），因而可用十六进制（无符号的）编码形式表示, 所以’A’字符也可以用Unicode编码’\u0041’表示<blockquote>
<p>提示　字符类型也属于是数值类型，可以与<strong>int等数值类型</strong>进行数学计算或进行转换。这是因为字符类型在计算机中保存的是Unicode编码，双字节Unicode的存储范围在\u0000~\uFFFF，所以char类型取值范围<code>0 ~ 65535</code>。</p>
</blockquote>
</li>
</ul>
<p>在Java中，为了表示一些特殊字符，前面要加上反斜杠（\），这称为字符转义。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-2e0d430b87f4873f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>在Java语言中声明布尔类型的关键字是boolean，它只有两个值：true和false。     </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-fd7793bd9fe09607.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="取值范围"></p>
<h2 id="数值类型相互转换"><a href="#数值类型相互转换" class="headerlink" title="数值类型相互转换"></a>数值类型相互转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>自动类型转换就是需要类型之间转换是自动的，不需要采取其他手段，总的原则是小范围数据类型可以自动转换为大范围数据类型，列类型转换顺序如图所示，从左到右是自动。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-5bcdc9e4501cb800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<blockquote>
<p>注意　如图所示，char类型比较特殊，char自动转换为int、long、float和double，但byte和short不能自动转换为char，而且char也不能自动转换为byte或short。</p>
</blockquote>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在数值类型转换过程中，除了需要自动类型转换外，有时还需要强制类型转换，强制类型转换是在变量或常量之前加上“(目标类型)”实现。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote>
<p>变量和常量是构成表达式的重要部分，变量所代表的内部是可以被修改的。</p>
<ul>
<li>一定要注意变量属于哪个类型和它的取值范围                  </li>
<li>强制类型转换(小能默认转大,大转小要用强转) </li>
<li>强转可以取某个实数的整数部分(int a = (int)12.34)</li>
</ul>
</blockquote>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li>定义在类中，在整个类中都可以被访问。</li>
<li>成员变量随着对象的建立而建立，存在于对象所在的<strong>堆内存</strong>中。</li>
<li>成员变量有默认初始化值。</li>
</ul>
<h3 id="静态成员变量-类变量"><a href="#静态成员变量-类变量" class="headerlink" title="静态成员变量(类变量)"></a>静态成员变量(类变量)</h3><p>加了static关键字</p>
<h3 id="局部变量-自动变量-："><a href="#局部变量-自动变量-：" class="headerlink" title="局部变量(自动变量) ："></a>局部变量(自动变量) ：</h3><ul>
<li>局部变量只定义在局部范围内，如：方法内，语句内等。 </li>
<li>局部变量存在于<strong>栈内存</strong>中。</li>
<li>作用的范围结束，变量空间会自动释放。</li>
<li>局部变量<strong>没有默认初始化值</strong></li>
<li>在方法体内可以定义本方法所使用的变量，这种变量是局部变量，它的生存期与作用域是在本方法内。</li>
<li>方法体内定义变量时，变量前不能加修饰符。</li>
<li>局部变量在使用前必须明确赋值，因为它没有默认值，否则编译时会出错。</li>
<li>在语句块中定义的变量它只在语句块中有效；</li>
<li>方法参数:作用域是整个方法.</li>
<li>异常处理参数:catch跟随的异常处理块.</li>
</ul>
<h3 id="变量的作用域总结"><a href="#变量的作用域总结" class="headerlink" title="变量的作用域总结"></a>变量的作用域总结</h3><p>变量的作用域也称变量的有效范围，它是程序的一个区域，变量在其作用域内可以通过它的名字来引用。作用域也决定系统什么时候为变量创建和清除内存。根据变量在程序声明的位置，可以将变量分为4类情形。</p>
<ul>
<li>成员变量 / 类变量(静态成员变量)<br>成员变量可添加修饰符，包括访问权限修饰符<code>public</code>、<code>private</code>、<code>protected</code>和非访问权限修饰符<code>static</code>、<code>final</code>、<code>native</code>等。</li>
<li>如果没有给对象属性赋初值，则对象属性的初始值由相应数据类型的默认值决定，如数值型数据的默认值为0，boolean的默认值为false，字符串的默认值为null。成员变量的作用域是在类的范围。 </li>
</ul>
<h3 id="成员变量和静态成员变量-类变量-的区别"><a href="#成员变量和静态成员变量-类变量-的区别" class="headerlink" title="成员变量和静态成员变量(类变量)的区别"></a>成员变量和静态成员变量(类变量)的区别</h3><ol>
<li>两个变量的生命周期不同。  　　<br>成员变量随着对象的创建而存在，随着对象的被回收而释放。   　　<br>静态变量随着类的加载而存在，随着类的消失而消失。　</li>
<li>调用方式不同。　　     <ul>
<li>成员变量只能被对象调用。　　     </li>
<li>静态变量可以被对象调用，还可以被类名调用。　　</li>
</ul>
</li>
<li>数据存储位置不同。     　　<ul>
<li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据  　　</li>
<li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据. </li>
</ul>
</li>
</ol>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量事实上是那些内容不能被修改的变量，常量与变量类似也需要初始化，即在声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。它的声明格式为：<code>final 数据类型 变量名 = 初始值;</code></p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>Java编码规范命名方法采用驼峰法，下面分类说明一下。</p>
<ul>
<li>包名：包名是全小写字母，中间可以由点分隔开。作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2。但Java核心库包名不采用域名的倒置命名，如java.awt.event。</li>
<li>类和接口名：采用大驼峰法，如SplitViewController。</li>
<li>文件名：采用大驼峰法，如BlockOperation.java。</li>
<li>变量：采用小驼峰法，如studentNumber。</li>
<li>常量名：全大写，如果是由多个单词构成，可以用下划线隔开，如YEAR和WEEK_OF_MONTH。</li>
<li>方法名：采用小驼峰法，如balanceAccount、isButtonPressed等。</li>
</ul>
<p>命名规范示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gitee.kailee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> YEAR_LENGTH = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MONTH_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstDash;</span><br><span class="line">        <span class="keyword">int</span> secondDash;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="keyword">super</span>.getYear() + <span class="number">1900</span>;</span><br><span class="line">        <span class="keyword">int</span> month = <span class="keyword">super</span>.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="keyword">super</span>.getDate();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></p>
<p>Java从小白到大牛-图书-图灵社区<br><a href="http://www.ituring.com.cn/book/2480" target="_blank" rel="noopener">http://www.ituring.com.cn/book/2480</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leiTKai</p>
  <div class="site-description" itemprop="description">personal website</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leiTKai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
