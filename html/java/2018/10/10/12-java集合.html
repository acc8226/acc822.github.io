<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"DNTEG3O773","apiKey":"dbae86bf58ba49b0e9f250a3983ac7ff","indexName":"likaiailei","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="集合框架体系概述 为什么出现集合类?方便多个对象的操作,就对对象进行存储,集合就是存储对象最常用的一种方法.  数组和集合类同时容器, 有何不可?            数组虽然也可存储对象,但长度固定; 而集合长度可变  集合只用于存储对象,集合长度是可变的,集合可以存储不同类型的对象.    Java 集合定义了两种基本的数据结构，一种是 Collection，表示一组对象的集合；另一种是Ma">
<meta property="og:type" content="article">
<meta property="og:title" content="12 Java集合">
<meta property="og:url" content="/html/java/2018/10/10/12-java集合.html">
<meta property="og:site_name" content="ac86&#39;s blog">
<meta property="og:description" content="集合框架体系概述 为什么出现集合类?方便多个对象的操作,就对对象进行存储,集合就是存储对象最常用的一种方法.  数组和集合类同时容器, 有何不可?            数组虽然也可存储对象,但长度固定; 而集合长度可变  集合只用于存储对象,集合长度是可变的,集合可以存储不同类型的对象.    Java 集合定义了两种基本的数据结构，一种是 Collection，表示一组对象的集合；另一种是Ma">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1662509-f4b8b26cdd6913d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1662509-a5d8c54b79194c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1662509-3d428eb64ebde6b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1662509-b110af462059037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1662509-92c52521c7ccf138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2020-03-04T15:59:09.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="12 Java集合">
<meta name="twitter:description" content="集合框架体系概述 为什么出现集合类?方便多个对象的操作,就对对象进行存储,集合就是存储对象最常用的一种方法.  数组和集合类同时容器, 有何不可?            数组虽然也可存储对象,但长度固定; 而集合长度可变  集合只用于存储对象,集合长度是可变的,集合可以存储不同类型的对象.    Java 集合定义了两种基本的数据结构，一种是 Collection，表示一组对象的集合；另一种是Ma">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1662509-f4b8b26cdd6913d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="canonical" href="/html/java/2018/10/10/12-java集合.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>12 Java集合 | ac86's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ac86's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">---</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/acc8226" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="/html/java/2018/10/10/12-java集合.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="leiTKai">
      <meta itemprop="description" content="personal website">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ac86's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          12 Java集合
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-10 22:20:00" itemprop="dateCreated datePublished" datetime="2018-10-10T22:20:00+08:00">2018-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-04 23:59:09" itemprop="dateModified" datetime="2020-03-04T23:59:09+08:00">2020-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="集合框架体系概述"><a href="#集合框架体系概述" class="headerlink" title="集合框架体系概述"></a>集合框架体系概述</h2><ol>
<li><p>为什么出现集合类?<br>方便多个对象的操作,就对对象进行存储,集合就是存储对象最常用的一种方法.</p>
</li>
<li><p>数组和集合类同时容器, 有何不可?          </p>
<ul>
<li>数组虽然也可存储对象,但长度固定; 而集合长度可变 </li>
<li>集合只用于存储对象,集合长度是可变的,集合可以存储不同类型的对象.</li>
</ul>
</li>
</ol>
<p>Java 集合定义了两种基本的数据结构，一种是 <code>Collection</code>，表示一组对象的集合；另一种是<code>Map</code>，表示对象间的一系列映射或关联关系。Java 集合的基本架构如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-f4b8b26cdd6913d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集合类及其继承关系"></p>
<p>在这种架构中，<code>Set</code> 是一种 <code>Collection</code>，不过其中没有重复的对象； <code>List</code> 也是一种<code>Collection</code> ，其中的元素按顺序排列（不过可能有重复）。<br><code>SortedSet</code> 和 <code>SortedMap</code> 是特殊的集和映射，其中的元素按顺序排列。<br><code>Collection</code>、<code>Set</code> 、<code>List</code> 、<code>Map</code> 、<code>SortedSet</code>和 <code>SortedMap</code> 都是接口，不过 java.util 包定义了多个具体实现，例如基于数组和链表的列表，基于哈希表或二叉树的映射和集。除此之外，还有两个重要的接口， Iterator 和 Iterable ，用于遍历集合中的对象，稍后会介绍。</p>
<h2 id="Collection共性方法"><a href="#Collection共性方法" class="headerlink" title="Collection共性方法"></a>Collection共性方法</h2><blockquote>
<p>注意: 集合存储的都是对象的引用(地址)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>添加指定的元素<span class="params">(可选操作)</span>     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。 </span></span><br><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span>: 清空集合中所有元素     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> 是否包含指定元素     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> 只判断参数中的集合是否都包含在A集合内,最终A集合没有任何变化.     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 判断是否为空     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   移除单个实例     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>  取差集    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>  取交集     </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>:返回collection中的元素     </span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span> 这个可以理解     </span></span><br><span class="line"><span class="function">&lt;T&gt; T[]  <span class="title">toArray</span><span class="params">(T[] a)</span>  <span class="comment">//应这么写String[] y =  c.toArray(new String[collection.size()])较好</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建几个集合，供后面的代码使用</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 一个空集</span></span><br><span class="line">Collection&lt;String&gt; d = Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>);</span><br><span class="line">Collection&lt;String&gt; e = Collections.singleton(<span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合中添加一些元素</span></span><br><span class="line"><span class="comment">// 如果集合的内容变化了，这些方法返回true</span></span><br><span class="line"><span class="comment">// 这种表现对不允许重复的Set类型很有用</span></span><br><span class="line">c.add(<span class="string">"zero"</span>);           <span class="comment">// 添加单个元素</span></span><br><span class="line">c.addAll(d);             <span class="comment">// 添加d中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制集合：多数实现都有副本构造方法</span></span><br><span class="line">Collection&lt;String&gt; copy = <span class="keyword">new</span> ArrayList&lt;String&gt;(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把元素从集合中移除。</span></span><br><span class="line"><span class="comment">// 除了clear()方法之外，如果集合的内容变化了，都返回true</span></span><br><span class="line">c.remove(<span class="string">"zero"</span>);        <span class="comment">// 移除单个元素</span></span><br><span class="line">c.removeAll(e);          <span class="comment">// 移除一组元素</span></span><br><span class="line">c.retainAll(d);          <span class="comment">// 移除不在集合d中的所有元素</span></span><br><span class="line">c.clear();               <span class="comment">// 移除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的大小</span></span><br><span class="line"><span class="keyword">boolean</span> b = c.isEmpty(); <span class="comment">// c是空的，所以返回true</span></span><br><span class="line"><span class="keyword">int</span> s = c.size();        <span class="comment">// 现在c的大小是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前面创建的副本复原集合</span></span><br><span class="line">c.addAll(copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试元素是否在集合中。测试基于equals()方法，而不是==运算符</span></span><br><span class="line">b = c.contains(<span class="string">"zero"</span>);  <span class="comment">// true</span></span><br><span class="line">b = c.containsAll(d);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多数Collection实现都有toString()方法</span></span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用集合中的元素创建一个数组。</span></span><br><span class="line"><span class="comment">// 如果迭代器能保证特定的顺序，数组就有相同的顺序</span></span><br><span class="line"><span class="comment">// 得到的数组是个副本，而不是内部数据结构的引用</span></span><br><span class="line">Object[] elements = c.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想把集合中的元素存入String[]类型的数组，必须在参数中指定这个类型</span></span><br><span class="line">String[] strings = c.toArray(<span class="keyword">new</span> String[c.size()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者传入一个类型为String[]的空数组，指定所需的类型</span></span><br><span class="line"><span class="comment">// toArray()方法会为这个数组分配空间</span></span><br><span class="line">strings = c.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>记住，上述各个方法都能用于 Set、List 或 Queue。这几个子接口可能会对集合中的元素做些限制或有顺序上的约束，但都提供了相同的基本方法。</p>
<blockquote>
<p>修改集合的方法，例如 add()、remove()、clear() 和 retainAll()，是可选的 API。不过，这个规则在很久以前就定下了，那时认为如果不提供这些方法，明智的做法是抛出 UnsupportedOperationException 异常。因此，某些实现（尤其是只读方法）可能会抛出未检异常。</p>
</blockquote>
<ul>
<li><code>Collection</code> (集合)和 <code>Map</code>(映射) 及其子接口都没扩展 Cloneable 或 Serializable 接口。不过，在 Java 集合框架中，实现集合和映射的所有类都实现了这两个接口。</li>
<li>有些集合对其可以包含的元素做了限制。例如，有的集合禁止使用 null 作为元素。EnumSet 要求其中的元素只能是特定的枚举类型。</li>
<li>如果尝试把禁止使用的元素添加到集合中，会抛出未检异常，例如 <code>NullPointerException</code> 或 <code>ClassCastException</code>。检查集合中是否包含禁止使用的元素，可能也会抛出这种异常，或者仅仅返回 false。</li>
</ul>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>List 是一组<strong>有序的对象集合</strong>。列表中的每个元素都有特定的位置，而且 List 接口定义了一些方法，用于查询或设定特定位置（或叫索引）的元素。从这个角度来看，List 对象和数组类似，不过列表的大小能按需变化，以适应其中元素的数量。和<code>Set</code>不同，列表允许出现重复的元素。</p>
<p>除了基于索引的 get() 和 set() 方法之外，List 接口还定义了一些方法，用于把元素添加到特定的索引，把元素从特定的索引移除，或者返回指定值在列表中首次出现或最后出现的索引。从 Collection 接口继承的 add() 和 remove() 方法，前者把元素添加到列表末尾，后者把指定值从列表中首次出现的位置移除。继承的 addAll() 方法把指定集合中的所有元素添加到列表的末尾，或者插入指定的索引。retainAll() 和 removeAll() 方法的表现与其他 Collection 对象一样，如果需要，会保留或删除多个相同的值。</p>
<p>List 接口没有定义操作索引范围的方法，但是定义了一个 subList() 方法。这个方法返回一个 List 对象，表示原列表指定范围内的元素。子列表会回馈父列表，只要修改了子列表，父列表立即就能察觉到变化。下述代码演示了 subList() 方法和其他操作 List 对象的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个列表，供后面的代码使用</span></span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(args));</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引查询和设定元素</span></span><br><span class="line">String first = l.get(<span class="number">0</span>);        <span class="comment">// 列表的第一个元素</span></span><br><span class="line">String last = l.get(l.size -<span class="number">1</span>); <span class="comment">// 列表的最后一个元素</span></span><br><span class="line">l.set(<span class="number">0</span>, last);                 <span class="comment">// 把最后一个元素变成第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加和插入元素</span></span><br><span class="line"><span class="comment">// add()方法既可以把元素添加到列表末尾，也可以把元素插入指定索引</span></span><br><span class="line">l.add(first);       <span class="comment">// 把第一个词添加到列表末尾</span></span><br><span class="line">l.add(<span class="number">0</span>, first);    <span class="comment">// 再把第一个词添加到列表的开头</span></span><br><span class="line">l.addAll(words);    <span class="comment">// 把一个集合添加到列表末尾</span></span><br><span class="line">l.addAll(<span class="number">1</span>, words); <span class="comment">// 在第一个词之后插入一个集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子列表：回馈原列表</span></span><br><span class="line">List&lt;String&gt; sub = l.subList(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 第二个和第三个元素</span></span><br><span class="line">sub.set(<span class="number">0</span>, <span class="string">"hi"</span>);                  <span class="comment">// 修改l的第二个元素</span></span><br><span class="line"><span class="comment">// 子列表可以把操作限制在原列表索引的子范围内</span></span><br><span class="line">String s = Collections.min(l.subList(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">Collections.sort(l.subList(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 子列表的独立副本不影响父列表</span></span><br><span class="line">List&lt;String&gt; subcopy = <span class="keyword">new</span> ArrayList&lt;String&gt;(l.subList(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索列表</span></span><br><span class="line"><span class="keyword">int</span> p = l.indexOf(last); <span class="comment">// 最后一个词在哪个位置？</span></span><br><span class="line">p = l.lastIndexOf(last); <span class="comment">// 反向搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印last在l中出现的所有索引。注意，使用了子列表</span></span><br><span class="line"><span class="keyword">int</span> n = l.size();</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个列表，只包含尚未搜索的元素</span></span><br><span class="line">    List&lt;String&gt; list = l.subList(p, n);</span><br><span class="line">    <span class="keyword">int</span> q = list.indexOf(last);</span><br><span class="line">    <span class="keyword">if</span> (q == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    System.out.printf(<span class="string">"Found '%s' at index %d%n"</span>, last, p+q);</span><br><span class="line">    p += q+<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(p &lt; n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从列表中删除元素</span></span><br><span class="line">l.remove(last);         <span class="comment">// 把指定元素从首次出现的位置上删除</span></span><br><span class="line">l.remove(<span class="number">0</span>);            <span class="comment">// 删除指定索引对应的元素</span></span><br><span class="line">l.subList(<span class="number">0</span>,<span class="number">2</span>).clear(); <span class="comment">// 使用subList()方法，删除一个范围内的元素</span></span><br><span class="line">l.retainAll(words);     <span class="comment">// 删除所有不在words中的元素</span></span><br><span class="line">l.removeAll(words);     <span class="comment">// 删除所有在words中的元素</span></span><br><span class="line">l.clear();              <span class="comment">// 删除所有元素</span></span><br></pre></td></tr></table></figure></p>
<p>重点讲讲用于查找的Iterator迭代器接口<br>Iterator it = al.iterator();<br>实际上是集合类在List和Set都包含的iterator方法,返回Iterator对象,具体实现方式是内部类.可以认为是继承了AbstractList,实现了Iterable接口.把取出方式定义成内部类,每个容器的数据结构不同,取出的动作细节也不一样.但是都用共性的判断和取出,可以将共性方法抽取.对外提供了Iterator方法.</p>
<h5 id="集合中的迭代器"><a href="#集合中的迭代器" class="headerlink" title="集合中的迭代器"></a>集合中的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//老外为了节省空间,写成这样</span></span><br><span class="line"><span class="keyword">for</span>(Iterator it = al.iterator(); it.hasNext(); )&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="List共性方法"><a href="#List共性方法" class="headerlink" title="List共性方法"></a>List共性方法</h5><p>(List也被成为序列, 它的对象的元素有序可重复,正因为有序,所以操作角标的方法都是该体系特有的方法)</p>
<ul>
<li>增 void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。  </li>
<li>删 E remove(int index)   移除列表中指定位置的元素（可选操作）。</li>
<li>改 E set(int index, E element)   用指定元素替换列表中指定位置的元素（可选操作）。      </li>
<li>查 ListIterator<e> listIterator()  返回此列表元素的列表迭代器（按适当顺序）。</e></li>
<li>获取 E get(int index)  返回列表中指定位置的元素。  　　　　 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于get(index)方法, list因此多了一种取出所有元素的方法. 但还是常用迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;al.size();i++)&#123;                　　</span><br><span class="line">    输出al.get(i);          　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>获取<e> subList(int fromIndex, int toIndex)  返回列表中指定的 fromIndex(包括)和 toIndex（不包括）之间的部分视图。      </e></p>
<h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><p>List有自己更强功能的的ListIterator是Iterator的子接口,是带下标的.</p>
<p>集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现ConcurrentModificationException异常情况。ListIterator列表迭代器接口具备了对元素的增、删、改、查的动作。</p>
<p>原 查 next() 但是 增加了previous()<br>原 删 void remove()<br>增加了特有了           　　</p>
<ul>
<li>增void add(E e)            　　</li>
<li>改 void set(E e)           　　</li>
<li>和独有的int nextIndex(), int previousIndex() 和 int nextIndex()</li>
</ul>
<h5 id="List集合的三个常见子类对象-List有序可重复-因为体系有索引"><a href="#List集合的三个常见子类对象-List有序可重复-因为体系有索引" class="headerlink" title="List集合的三个常见子类对象(List有序可重复,因为体系有索引)"></a>List集合的三个常见子类对象(List有序可重复,因为体系有索引)</h5><ul>
<li>ArrayList: 底层使用<strong>数组结构</strong>, 查询块,增删稍慢. 线程不同步, JDK1.2以上     </li>
<li>LinkedList: 底层是<strong>链表结构</strong>, 增删块,查询稍慢, 线程不同步, JDK1.2以上     </li>
<li>Vector: 底层使用<strong>数组结构</strong>, 查询块,增删慢. 线程同步.被ArrayList替代了. 枚举就是Vector特有的取出方式.</li>
</ul>
<p>ArrayList详解:拥有角标的方法是其特有方法<br>可变长度数组的原理 ：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。      </p>
<ul>
<li>ArrayList：是按照原数组的 <strong>50%</strong>延长构造一个初始容量为10的空列表。      </li>
<li>Vector：是按照原数组的 <strong>100%</strong>延长       </li>
</ul>
<p>LinkedList详解:<br>特有的add,get,remove方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1.6后新方法        </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span>                </span></span><br><span class="line"><span class="function">在此列表的开头插入指定的元素。      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span>                </span></span><br><span class="line"><span class="function">在此列表末尾插入指定的元素。 </span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span>           </span></span><br><span class="line"><span class="function">获取但不移除此列表的头（第一个元素）。</span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。           </span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span>           </span></span><br><span class="line"><span class="function">获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。            </span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。           </span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。 </span></span><br><span class="line"><span class="function">```   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Vector</span><span class="params">(过时)</span>详解          </span></span><br><span class="line"><span class="function">枚举是Vector特有的取出方式<span class="title">hasMoreElements</span><span class="params">()</span>和<span class="title">nextElement</span><span class="params">()</span>方法,发现枚举和迭代器很像.其实枚举和迭代一样的.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; 在List下的ArrayList和LinkedList的contains和remove方法都是使用了Object的**equals**方法. 可以自己重写equals方法判断集合内两对象是否"一致"</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">##### 随机访问列表中的元素</span></span><br><span class="line"><span class="function">我们一般期望实现 List 接口的类能高效迭代，而且所用时间和列表的大小成正比。然而，不是所有列表都能高效地随机访问任意索引上的元素。按顺序访问的列表，例如 LinkedList 类，提供了高效的插入和删除操作，但降低了随机访问性能。提供高效随机访问的类都实现了标记接口 RandomAccess，因此，如果需要确定是否能高效处理列表，可以使用 <span class="keyword">instanceof</span> 运算符测试是否实现了这个接口：</span></span><br><span class="line"><span class="function">``` java</span></span><br><span class="line"><span class="function"><span class="comment">// 随便创建一个列表，供后面的代码处理</span></span></span><br><span class="line"><span class="function">List&lt;?&gt; l </span>= ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试能否高效随机访问</span></span><br><span class="line"><span class="comment">// 如果不能，先使用副本构造方法创建一个支持高效随机访问的副本，然后再处理</span></span><br><span class="line"><span class="keyword">if</span> (!(l <span class="keyword">instanceof</span> RandomAccess)) l = <span class="keyword">new</span> ArrayList&lt;?&gt;(l);</span><br></pre></td></tr></table></figure></p>
<p>在 List 对象上调用 iterator() 方法会得到一个 Iterator 对象，这个对象按照元素在列表中的顺序迭代各元素。List 实现了 Iterable 接口，因此列表可以像其他集合一样使用遍历循环迭代。</p>
<p>下表总结了 Java 平台中五种通用的 List 实现。Vector 和 Stack 类已经过时，别再用了。<strong>CopyOnWriteArrayList</strong> 类在 java.util.concurrent 包中，只适合在多线程环境中使用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-a5d8c54b79194c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现List接口的类"></p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>Set集合的方法和Collection一致,不用多讲, 但对这些方法做了限制, 是无重复对象组成的集合</li>
</ul>
<p>下表列出了实现 Set 接口的类，而且总结了各个类的内部表示方式、排序特性、对成员的限制，以及 add()、remove()、contains 等基本操作和迭代的性能。这些类的详细信息，请参见各自的文档。注意，CopyOnWriteArraySet 类在 java.util.concurrent 包中，其他类则在 java.util 包中。还要注意，java.util.BitSet 类没有实现 Set 接口，这个类过时了，用于紧凑而高效地表示布尔值组成的列表，但不是 Java 集合框架的一部分。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-3d428eb64ebde6b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现Set接口的类"></p>
<h5 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet(接口)"></a>SortedSet(接口)</h5><p>SortedSet 接口提供了多个有趣的方法，这些方法都考虑到了元素是有顺序的，如下述代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSortedSet</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个SortedSet对象</span></span><br><span class="line">    SortedSet&lt;String&gt; s = <span class="keyword">new</span> TreeSet&lt;&gt;(Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代集：元素已经自动排序</span></span><br><span class="line">    <span class="keyword">for</span> (String word : s) &#123;</span><br><span class="line">        System.out.println(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特定的元素</span></span><br><span class="line">    String first = s.first(); <span class="comment">// 第一个元素</span></span><br><span class="line">    String last = s.last();   <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除第一个元素之外的其他所有元素</span></span><br><span class="line">    SortedSet&lt;String&gt; tail = s.tailSet(first + <span class="string">'\0'</span>);</span><br><span class="line">    System.out.println(tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除最后一个元素之外的其他所有元素</span></span><br><span class="line">    SortedSet&lt;String&gt; head = s.headSet(last);</span><br><span class="line">    System.out.println(head);</span><br><span class="line"></span><br><span class="line">    SortedSet&lt;String&gt; middle = s.subSet(first+<span class="string">'\0'</span>, last);</span><br><span class="line">    System.out.println(middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>　必须加上 \0 字符，因为 tailSet() 等方法要使用某个元素后面的元素，对字符串来说，要在后面加上 NULL 字符（对应于 ASCII 中的 0）。</p>
</blockquote>
<h5 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet(类)"></a>TreeSet(类)</h5><p>TreeSet 类使用红黑树数据结构维护集，这个集中的元素按照 Comparable 对象的自然顺序升序迭代，或者按照 Comparator 对象指定的顺序迭代。其实，TreeSet 实现的是 Set 的子接口，SortedSet 接口。</p>
<p>TreeSet排序               </p>
<ul>
<li>第一种方式: 需要比较的对象实现Comparable接口,覆盖int compareTo()方法,让元素自身具备比较性  </li>
<li>第二种方式:构造实现java.util.Comparator接口,覆盖int compare(T o1, T o2)方法,将比较器对象作为参数传递给TreeSet集合的构造函数.</li>
</ul>
<h5 id="HashSet-线程不同步"><a href="#HashSet-线程不同步" class="headerlink" title="HashSet(线程不同步)"></a>HashSet(线程不同步)</h5><ul>
<li>底层数据结构是哈希表,线程非同步.          </li>
<li>通过hasHashCode()和equals()来完成          </li>
<li>如果元素的HashCode相同,才会判断equals是否为true         </li>
<li>如果元素的HashCode不同,不会调用equals,直接是不等.   </li>
</ul>
<blockquote>
<p>注意,对于判断元素是否存在,以及删除等操作,依赖的方法依次是hashcode和equals方法. 在使用HashSet,一定要覆盖int hashCode()和boolean equals (Object obj)方法.</p>
</blockquote>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>将键映射到值的对象,一对一对往里存,而且要保证键的唯一性.</p>
<p>映射（map）是一系列键值对，一个键对应一个值。Map 接口定义了用于定义和查询映射的 API。Map 接口属于 Java 集合框架，但没有扩展 Collection 接口，<strong>因此 Map 只是一种集合</strong>，而<strong>不是 Collection</strong> 类型。Map 是参数化类型，有两个类型变量。类型变量 K 表示映射中键的类型，类型变量 V 表示键对应的值的类型。例如，如果有个映射，其键是 String 类型，对应的值是 Integer 类型，那么这个映射可以表示为 Map&lt;String,Integer&gt;。</p>
<p>Map 接口定义了几个最有用的方法：put() 方法定义映射中的一个键值对，get() 方法查询指定键对应的值，remove() 方法把指定的键及对应的值从映射中删除。一般来说，实现 Map 接口的类都要能高效执行这三个基本方法：一般应该运行在常数时间中，而且绝不能比在对数时间中运行的性能差。</p>
<p>Map 的重要特性之一是，可以视作集合。虽然 Map 对象不是 Collection 类型，但映射的键可以看成 Set 对象(因此<strong>不能有重复元素</strong>。)，映射的值可以看成 Collection 对象，而映射的键值对可以看成由 Map.Entry 对象组成的 Set 对象。（Map.Entry 是 Map 接口中定义的嵌套接口，表示一个键值对。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">添加               </span><br><span class="line">    put(K key, V value)               </span><br><span class="line">    putAll(Map&lt;? extends K, ? extends V&gt; m)         </span><br><span class="line">删除                 </span><br><span class="line">    clear()               </span><br><span class="line">    remove(Object key)          </span><br><span class="line">判断               </span><br><span class="line">    containsKey(Object key)               </span><br><span class="line">    containsValue(Object value)               </span><br><span class="line">    isEmpty()          </span><br><span class="line">获取               </span><br><span class="line">    get(Object key)               </span><br><span class="line">    size()               </span><br><span class="line">    values()               </span><br><span class="line">    entrySet()               </span><br><span class="line">    keySet()</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">下述示例代码展示了如何使用 get()、put() 和 remove() 等方法操作 Map 对象，还演示了把 Map 对象视作集合后的一些常见用法：</span><br><span class="line">``` java</span><br><span class="line"><span class="comment">// 新建一个空映射</span></span><br><span class="line">Map&lt;String,Integer&gt; m = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变的映射，只包含一个键值对</span></span><br><span class="line">Map&lt;String,Integer&gt; singleton = Collections.singletonMap(<span class="string">"test"</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，极少使用下述句法显式指定通用方法emptyMap()的参数类型</span></span><br><span class="line"><span class="comment">// 得到的映射不可变</span></span><br><span class="line">Map&lt;String,Integer&gt; empty = Collections.&lt;String,Integer&gt;emptyMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用put()方法填充映射，把数组中的元素映射到元素的索引上</span></span><br><span class="line">String[] words = &#123; <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"test"</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    m.put(words[i], i); <span class="comment">// 注意，int会自动装包成Integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个键只能映射一个值</span></span><br><span class="line"><span class="comment">// 不过，多个键可以映射同一个值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    m.put(words[i].toUpperCase(), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// putAll()方法从其他映射中复制键值对</span></span><br><span class="line">m.putAll(singleton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get()方法查询映射</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m.get(words[i]) != i) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试映射中是否有指定的键和值</span></span><br><span class="line">m.containsKey(words[<span class="number">0</span>]);       <span class="comment">// true</span></span><br><span class="line">m.containsValue(words.length); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射的键、值和键值对都可以看成集合</span></span><br><span class="line">Set&lt;String&gt; keys = m.keySet();</span><br><span class="line">Collection&lt;Integer&gt; values = m.values();</span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = m.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射和上述几个集合都有有用的toString()方法</span></span><br><span class="line">System.out.printf(<span class="string">"Map: %s%nKeys: %s%nValues: %s%nEntries: %s%n"</span>,</span><br><span class="line">                  m, keys, values, entries);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以迭代这些集合</span></span><br><span class="line"><span class="comment">// 多数映射都没定义迭代的顺序（不过SortedMap定义了）</span></span><br><span class="line"><span class="keyword">for</span>(String key : m.keySet()) System.out.println(key);</span><br><span class="line"><span class="keyword">for</span>(Integer value: m.values()) System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map.Entry&lt;K,V&gt;类型表示映射中的一个键值对</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; pair : m.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    System.out.printf(<span class="string">"'%s' ==&gt; %d%n"</span>, pair.getKey(), pair.getValue());</span><br><span class="line">    <span class="comment">// 然后把每个Entry对象的值增加1</span></span><br><span class="line">    pair.setValue(pair.getValue() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">m.put(<span class="string">"testing"</span>, <span class="keyword">null</span>);   <span class="comment">// 映射到null上可以“擦除”一个键值对</span></span><br><span class="line">m.get(<span class="string">"testing"</span>);         <span class="comment">// 返回null</span></span><br><span class="line">m.containsKey(<span class="string">"testing"</span>); <span class="comment">// 返回true：键值对仍然存在</span></span><br><span class="line">m.remove(<span class="string">"testing"</span>);      <span class="comment">// 删除键值对</span></span><br><span class="line">m.get(<span class="string">"testing"</span>);         <span class="comment">// 还是返回null</span></span><br><span class="line">m.containsKey(<span class="string">"testing"</span>); <span class="comment">// 这次返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以把映射视作集合，然后再删除</span></span><br><span class="line"><span class="comment">// 不过，向集合中添加键值对时不能这么做</span></span><br><span class="line">m.keySet().remove(words[<span class="number">0</span>]); <span class="comment">// 等同于m.remove(words[0]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个值为2的键值对——这种方式一般效率不高，用途有限</span></span><br><span class="line">m.values().remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 删除所有值为4的键值对</span></span><br><span class="line">m.values().removeAll(Collections.singleton(<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 只保留值为2和3的键值对</span></span><br><span class="line">m.values().retainAll(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以通过迭代器删除</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter = m.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; e = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (e.getValue() == <span class="number">2</span>) iter.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出两个映射中都有的值</span></span><br><span class="line"><span class="comment">// 一般来说，addAll()和retainAll()配合keySet()和values()使用，可以获取交集和并集</span></span><br><span class="line">Set&lt;Integer&gt; v = <span class="keyword">new</span> HashSet&lt;Integer&gt;(m.values());</span><br><span class="line">v.retainAll(singleton.values());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法</span></span><br><span class="line">m.clear();                <span class="comment">// 删除所有键值对</span></span><br><span class="line">m.size();                 <span class="comment">// 返回键值对的数量：目前为0</span></span><br><span class="line">m.isEmpty();              <span class="comment">// 返回true</span></span><br><span class="line">m.equals(empty);          <span class="comment">// true：实现Map接口的类覆盖了equals()方法</span></span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1662509-b110af462059037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现Map接口的类"></p>
<p>java.util.concurrent 包中的 ConcurrentHashMap 和 ConcurrentSkipListMap 两个类实现了同一个包中的 ConcurrentMap 接口。ConcurrentMap 接口扩展 Map 接口，而且定义了一些对多线程编程很重要的原子操作方法。例如，putIfAbsent() 方法，它的作用和 put() 方法类似，不过，仅当指定的键没有映射到其他值上时，才会把键值对添加到映射中。</p>
<p>TreeMap 类实现 SortedMap 接口。这个接口扩展 Map 接口，添加了一些方法，利用这种映射的有序特性。SortedMap 接口和 SortedSet 接口非常相似。firstKey() 和 lastKey() 方法分别返回 keySet() 所得集的第一个和最后一个键。而 headMap()、tailMap() 和 subMap() 方法都返回一个新映射，由原映射特定范围内的键值对组成。</p>
<h5 id="Map集合的共性方法注意"><a href="#Map集合的共性方法注意" class="headerlink" title="Map集合的共性方法注意"></a>Map集合的共性方法注意</h5><ol>
<li>添加元素,如果出现相同的键,那么后添加的值会覆盖原有键对应的值, put方法会会返回被覆盖的值     </li>
<li>可通过get方法的返回值来判断一个键是否存在,通过返回null判断.     </li>
<li>获取map集合中所有的值</li>
</ol>
<p>两个重要的获取方法:  keySet()和entrySet()     </p>
<ol>
<li>通过keyset()获取key的Set集合,然后Iterator获取key,最终get(Object key) 获取.     </li>
<li>通过entryset()获取关系,然后Iterator获取键值对,最终Map.Entry的getKey和getValue方法获取. (其实Map.Entry也是一个接口,它是Map接口中的一个内部接口)</li>
</ol>
<blockquote>
<p>Map和Set很像,其实Set底层就是使用了Map集合. </p>
</blockquote>
<p>练习TreeMap</p>
<ul>
<li>key: 学生Student, value: 地址addr     </li>
<li>学生属性:姓名和年龄,注意姓名和年龄相同视为同一个学生,需保证学生的唯一性<br><img src="http://upload-images.jianshu.io/upload_images/1662509-92c52521c7ccf138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<h3 id="Queue接口和BlockingQueue接口"><a href="#Queue接口和BlockingQueue接口" class="headerlink" title="Queue接口和BlockingQueue接口"></a>Queue接口和BlockingQueue接口</h3><p>队列（queue）是一组有序的元素，提取元素时按顺序从队头读取。队列一般按照插入元素的顺序实现，因此分成两类：先进先出（first-in, first-out，FIFO）队列和后进先出（last-in, first-out，LIFO）队列。</p>
<blockquote>
<p>LIFO 队列也叫栈（stack），Java 提供了 Stack 类，但强烈不建议使用——应该使用实现 Deque 接口的类。</p>
</blockquote>
<p>队列也可以使用其他顺序：优先队列（priority queue）根据外部 Comparator 对象或 Comparable 类型元素的自然顺序排序元素。与 Set 不同的是，Queue 的实现往往允许出现重复的元素。而与 List 不同的是，Queue 接口没有定义处理任意索引位元素的方法，只有队列的头一个元素能访问。Queue 的所有实现都要具有一个固定的容量：队列已满时，不能再添加元素。类似地，队列为空时，不能再删除元素。很多基于队列的算法都会用到满和空这两个状态，所以 Queue 接口定义的方法通过返回值表明这两个状态，而不会抛出异常。具体而言，peek() 和 poll() 方法返回 null 表示队列为空。因此，多数 Queue 接口的实现不允许用 null 作元素。</p>
<p>阻塞式队列（blocking queue）是一种定义了阻塞式 put() 和 take() 方法的队列。put() 方法的作用是把元素添加到队列中，如果需要，这个方法会一直等待，直到队列中有存储元素的空间为止。而 take() 方法的作用是从队头移除元素，如果需要，这个方法会一直等待，直到队列中有元素可供移除为止。阻塞式队列是很多多线程算法的重要组成部分，因此 BlockingQueue 接口（扩展 Queue 接口）在 java.util.concurrent 包中定义。</p>
<p>队列不像集、列表和映射那么常用，只在特定的多线程编程风格中会用到。这里，我们不举实例，而是试着厘清一些令人困惑的队列插入和移除操作。</p>
<p><strong>1. 把元素添加到队列中</strong><br>add()<strong>方法</strong><br>这个方法在 Collection 接口中定义，只是使用常规的方式添加元素。对有界的队列来说，如果队列已满，这个方法可能会抛出异常。</p>
<p>offer()<strong>方法</strong><br>这个方法在 Queue 接口中定义，但是由于有界的队列已满而无法添加元素时，这个方法返回 false，而不会抛出异常。<br>BlockingQueue 接口定义了一个超时版 offer() 方法，如果队列已满，会在指定的时间内等待空间。这个版本和基本版一样，成功插入元素时返回 true，否则返回 false。</p>
<p>put()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，会阻塞操作：如果因为队列已满而无法插入元素，put() 方法会一直等待，直到其他线程从队列中移除元素，有空间插入新元素为止。</p>
<p><strong>2. 把元素从队列中移除</strong><br>remove()<strong>方法</strong><br>Collection 接口中定义了 remove() 方法，把指定的元素从队列中移除。除此之外，Queue接口还定义了一个没有参数的 remove() 方法，移除并返回队头的元素。如果队列为空，这个方法会抛出 NoSuchElementException 异常。</p>
<p>poll()<strong>方法</strong><br>这个方法在 Queue 接口中定义，作用和 remove() 方法类似，移除并返回队头的元素，不过，如果队列为空，这个方法会返回 null，而不抛出异常。<br>BlockingQueue 接口定义了一个超时版 poll() 方法，在指定的时间内等待元素添加到空队列中。</p>
<p>take()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，用于删除并返回队头的元素。如果队列为空，这个方法会等待，直到其他线程把元素添加到队列中为止。</p>
<p>drainTo()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，作用是把队列中的所有元素都移除，然后把这些元素添加到指定的 Collection 对象中。这个方法不会阻塞操作，等待有元素添加到队列中。这个方法有个变体，接受一个参数，指定最多移除多少个元素。</p>
<p><strong>3. 查询</strong><br>就队列而言，“查询”的意思是访问队头的元素，但不将其从队列中移除。<br>element()<strong>方法</strong><br>这个方法在 Queue 接口中定义，其作用是返回队头的元素，但不将其从队列中移除。如果队列为空，这个方法抛出 NoSuchElementException 异常。</p>
<p>peek()<strong>方法</strong><br>这个方法在 Queue 接口中定义，作用和 element() 方法类似，但队列为空时，返回 null。</p>
<blockquote>
<p>使用队列时，最好选定一种处理失败的方式。例如，如果想在操作成功之前一直阻塞，应该选择 put() 和 take() 方法；如果想检查方法的返回值，判断操作是否成功，应该选择 offer() 和 poll() 方法。</p>
</blockquote>
<p>LinkedList 类也实现了 Queue 接口，提供的是无界 FIFO 顺序，插入和移除操作需要常数时间。LinkedList 对象可以使用 null 作元素，不过，当列表用作队列时不建议使用 null。</p>
<p>java.util 包中还有另外两个 Queue 接口的实现。一个是 PriorityQueue<br> 类，这种队列根据Comparator 对象排序元素，或者根据 Comparable<br> 类型元素的 compareTo() 方法排序元素。PriorityQueue 对象的队头始终是根据指定排序方式得到的最小值。另外一个是 ArrayDeque类，实现的是双端队列，一般在需要用到栈的情况下使用。</p>
<p>java.util.concurrent 包中也包含一些 BlockingQueue 接口的实现，目的是在多线程编程环境中使用。有些实现很高级，甚至无需使用同步方法。</p>
<h3 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h3><p>java.util.Collections 类定义了一些静态实用方法，用于处理集合。其中有一类方法很重要，是集合的包装方法：这些方法包装指定的集合，返回特殊的集合。包装集合的目的是把集合本身没有提供的功能绑定到集合上。包装集合能提供的功能有：线程安全性、写保护和运行时类型检查。包装集合都以原来的集合为后盾，因此，在包装集合上调用的方法其实会分派给原集合的等效方法完成。这意味着，通过包装集合修改集合后，改动也会体现在原集合身上；反之亦然。</p>
<p>第一种包装方法为包装的集合提供线程安全性。java.util 包中的集合实现，除了过时的 Vector 和 Hashtable 类之外，都没有 synchronized 方法，不能禁止多个线程并发访问。如果需要使用线程安全的集合，而且不介意同步带来的额外开销，可以像下面这样创建集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =</span><br><span class="line">    Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">Set&lt;Integer&gt; set =</span><br><span class="line">    Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">Map&lt;String,Integer&gt; map =</span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br></pre></td></tr></table></figure></p>
<p>第二种包装方法创建的集合对象不能修改底层集合，得到的集合是只读的，只要试图修改集合的内容，就会抛出 UnsupportedOperationException 异常。如果要把集合传入方法，但不允许修改集合，也不允许使用任何方式改变集合的内容，就可以使用这种包装集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; readonly = Collections.unmodifiableList(primes);</span><br><span class="line"><span class="comment">// 可以修改primes列表</span></span><br><span class="line">primes.addAll(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>));</span><br><span class="line"><span class="comment">// 但不能修改只读的包装集合</span></span><br><span class="line">readonly.add(<span class="number">23</span>); <span class="comment">// 抛出UnsupportedOperationException异常</span></span><br></pre></td></tr></table></figure></p>
<p>java.util.Collections 类还定义了用来操作集合的方法。其中最值得关注的是排序和搜索集合元素的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line"><span class="comment">// 必须先排序列表中的元素</span></span><br><span class="line"><span class="keyword">int</span> pos = Collections.binarySearch(list, <span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Collections 类中还有些方法值得关注：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把list2中的元素复制到list1中，覆盖list1</span></span><br><span class="line">Collections.copy(list1, list2);</span><br><span class="line"><span class="comment">// 使用对象o填充list</span></span><br><span class="line">Collections.fill(list, o);</span><br><span class="line"><span class="comment">// 找出集合c中最大的元素</span></span><br><span class="line">Collections.max(c);</span><br><span class="line"><span class="comment">// 找出集合c中最小的元素</span></span><br><span class="line">Collections.min(c);</span><br><span class="line"></span><br><span class="line">Collections.reverse(list); <span class="comment">// 反转列表</span></span><br><span class="line">Collections.shuffle(list); <span class="comment">// 打乱列表</span></span><br></pre></td></tr></table></figure></p>
<p>你最好全面熟悉 Collections 和 Arrays 类中的实用方法，这样遇到常见任务时就不用自己动手实现了。</p>
<p><strong>特殊的集合</strong><br>除了包装方法之外，java.util.Collections 类还定义了其他实用方法，一些用于创建只包含一个元素的不可变集合实例，一些用于创建空集合。singleton()、singletonList() 和 singletonMap() 方法分别返回不可变的 Set、List 和 Map 对象，而且只包含一个指定的对象或键值对。如果要把单个对象当成集合传入方法，可以使用这些方法。</p>
<p>Collections 类还定义了一些返回空集合的方法。如果你编写的方法要返回一个集合，遇到没有返回值的情况时，一般最好返回空集合，而不要返回 null 等特殊的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; si = Collections.emptySet();</span><br><span class="line">List&lt;String&gt; ss = Collections.emptyList();</span><br><span class="line">Map&lt;String,Integer&gt; m = Collections.emptyMap();</span><br></pre></td></tr></table></figure></p>
<p>最后还有个 nCopies() 方法。这个方法返回一个不可变的 List 对象，包含指定数量个指定对象的副本：<br><code>List&lt;Integer&gt; tenzeros = Collections.nCopies(10, 0);</code></p>
<p><strong>数组和辅助方法</strong><br>由对象组成的数组和集合的作用类似，而且二者之间可以相互转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String[] a =&#123; <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"test"</span> &#125;; <span class="comment">// 一个数组</span></span><br><span class="line"><span class="comment">// 把数组当成大小不可变的列表</span></span><br><span class="line">List&lt;String&gt; l = Arrays.asList(a);</span><br><span class="line"><span class="comment">// 创建一个大小可变的副本</span></span><br><span class="line">List&lt;String&gt; m = <span class="keyword">new</span> ArrayList&lt;String&gt;(l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// asList()是个变长参数方法，所以也可以这么做：</span></span><br><span class="line">Set&lt;Character&gt; abc = <span class="keyword">new</span> HashSet&lt;Character&gt;(Arrays.asList(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));</span><br><span class="line"><span class="comment">// Collection接口定义了toArray()方法。不传入参数时，这个方法创建</span></span><br><span class="line"><span class="comment">// Object[]类型的数组，把集合中的元素复制到数组中，然后返回这个数组</span></span><br><span class="line"><span class="comment">// 把set中的元素存入数组</span></span><br><span class="line">Object[] members = set.toArray();</span><br><span class="line"><span class="comment">// 把list中的元素存入数组</span></span><br><span class="line">Object[] items = list.toArray();</span><br><span class="line"><span class="comment">// 把map的键存入数组</span></span><br><span class="line">Object[] keys = map.keySet().toArray();</span><br><span class="line"><span class="comment">// 把map的值存入数组</span></span><br><span class="line">Object[] values = map.values().toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想返回Object[]类型的值，可以把一个所需类型的数组传入toArray()方法</span></span><br><span class="line"><span class="comment">// 如果传入的数组不够大，会再创建一个相同类型的数组</span></span><br><span class="line"><span class="comment">// 如果传入的数组太大，复制集合元素后剩余的位置使用null填充</span></span><br><span class="line">String[] c = l.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有一些有用的辅助方法，用于处理 Java 数组。为了完整性，这里也会介绍。</p>
<p>java.lang.System 类定义了一个 arraycopy() 方法，作用是把一个数组中的指定元素复制到另一个数组的指定位置。这两个数组的类型必须相同，甚至可以是同一个数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] text = <span class="string">"Now is the time"</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 从text的第4个元素开始，复制10个字符到copy中</span></span><br><span class="line"><span class="comment">// 这10个字符的位置从copy[0]开始</span></span><br><span class="line">System.arraycopy(text, <span class="number">4</span>, copy, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一些元素向后移，留出位置插入其他元素</span></span><br><span class="line">System.arraycopy(copy, <span class="number">3</span>, copy, <span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></p>
<p>Arrays 类还定义了一些有用的静态方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intarray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">3</span> &#125;; <span class="comment">// 由整数组成的数组</span></span><br><span class="line">Arrays.sort(intarray);                       <span class="comment">// 原地排序数组</span></span><br><span class="line"><span class="comment">// 在索引2找到值7</span></span><br><span class="line"><span class="keyword">int</span> pos = Arrays.binarySearch(intarray, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 未找到：返回负数</span></span><br><span class="line">pos = Arrays.binarySearch(intarray, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象组成的数组也能排序和搜索</span></span><br><span class="line">String[] strarray = <span class="keyword">new</span> String[] &#123; <span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span> &#125;;</span><br><span class="line">Arrays.sort(strarray);  <span class="comment">// 排序的结果：&#123; "is", "now", "the", "time" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.equals()方法比较两个数组中的所有元素</span></span><br><span class="line">String[] clone = (String[]) strarray.clone();</span><br><span class="line"><span class="keyword">boolean</span> b1 = Arrays.equals(strarray, clone); <span class="comment">// 是的，两个数组相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.fill()方法用于初始化数组的元素</span></span><br><span class="line"><span class="comment">// 一个空数组，所有元素都是0</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 把元素都设为-1</span></span><br><span class="line">Arrays.fill(data, (<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 把第5-9个元素设为-2</span></span><br><span class="line">Arrays.fill(data, <span class="number">5</span>, <span class="number">10</span>, (<span class="keyword">byte</span>) -<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>在 Java 中，数组可以视作对象，也可以按照对象的方法处理。假如有个对象 o，可以使用类似下面的代码判断这个对象是否为数组。如果是，则判断是什么类型的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class type = o.getClass();</span><br><span class="line"><span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">  Class elementType = type.getComponentType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在Java集合框架中使用lambda表达式"><a href="#在Java集合框架中使用lambda表达式" class="headerlink" title="在Java集合框架中使用lambda表达式"></a>在Java集合框架中使用lambda表达式</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></li>
<li><a href="http://www.ituring.com.cn/book/1554" target="_blank" rel="noopener">Java技术手册: 第6版</a></li>
<li>第 15 章　对象容器——集合-图灵社区<br><a href="http://www.ituring.com.cn/book/tupubarticle/17746" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/17746</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/html/java/2018/10/09/11-java异常.html" rel="prev" title="11 Java异常">
      <i class="fa fa-chevron-left"></i> 11 Java异常
    </a></div>
      <div class="post-nav-item">
    <a href="/html/java/2018/10/11/13-泛型.html" rel="next" title="13 泛型">
      13 泛型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架体系概述"><span class="nav-number">1.</span> <span class="nav-text">集合框架体系概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection共性方法"><span class="nav-number">2.</span> <span class="nav-text">Collection共性方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List接口"><span class="nav-number">3.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#集合中的迭代器"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">集合中的迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List共性方法"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">List共性方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ListIterator"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">ListIterator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List集合的三个常见子类对象-List有序可重复-因为体系有索引"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">List集合的三个常见子类对象(List有序可重复,因为体系有索引)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set接口"><span class="nav-number">3.1.</span> <span class="nav-text">Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SortedSet-接口"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">SortedSet(接口)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeSet-类"><span class="nav-number">3.1.0.2.</span> <span class="nav-text">TreeSet(类)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet-线程不同步"><span class="nav-number">3.1.0.3.</span> <span class="nav-text">HashSet(线程不同步)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map接口"><span class="nav-number">3.2.</span> <span class="nav-text">Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Map集合的共性方法注意"><span class="nav-number">3.2.0.1.</span> <span class="nav-text">Map集合的共性方法注意</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue接口和BlockingQueue接口"><span class="nav-number">3.3.</span> <span class="nav-text">Queue接口和BlockingQueue接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实用方法"><span class="nav-number">3.4.</span> <span class="nav-text">实用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Java集合框架中使用lambda表达式"><span class="nav-number">3.5.</span> <span class="nav-text">在Java集合框架中使用lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">leiTKai</p>
  <div class="site-description" itemprop="description">personal website</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leiTKai</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
