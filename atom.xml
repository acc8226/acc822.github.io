<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ac86&#39;s blog</title>
  
  <subtitle>---</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-03-04T15:59:09.120Z</updated>
  <id>/</id>
  
  <author>
    <name>leiTKai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iTerm2</title>
    <link href="/html/%E6%8A%80%E6%9C%AF%E8%BD%AF%E4%BB%B6/2019/12/21/iterm2.html"/>
    <id>/html/技术软件/2019/12/21/iterm2.html</id>
    <published>2019-12-21T15:20:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>iTerm2是 Terminal 的替代品，也是 iTerm 的继承者。 它适用于 macOS 10.12或更新版本的 mac 电脑。 iTerm2将终端带入了现代社会，带来了一些你从来不知道自己一直想要的功能。</p><h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h2><p>官网 <a href="https://www.iterm2.com/" target="_blank" rel="noopener">https://www.iterm2.com/</a></p><p>下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。<br>或者你可以直接使用 Homebrew 进行安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install iterm2</span><br></pre></td></tr></table></figure></p><p>安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）：</p><ul><li><p>将一个选项卡划分为多个窗格，每个窗格显示不同的会话。 您可以垂直和水平切片，并创建任何数量的窗格在任何可以想象的安排。 请注意，非活动窗格稍微变暗，因此很容易看到哪些窗格是活动的。<br><img src="https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191221152747.png" alt></p></li><li><p>注册一个热键，当您在另一个应用程序中时，它会将 iTerm2带到前台。 一个终端总是离键盘一步之遥。 您可以选择让热键打开一个专用窗口。 </p></li><li><p>Iterm2具有强大的页面查找功能。 用户界面不会碍事。 所有匹配都会立即突出显示。 甚至还提供了正则表达式支持！<br><img src="https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191221152952.png" alt></p></li></ul><h3 id="iTerm2-快速隐藏和显示"><a href="#iTerm2-快速隐藏和显示" class="headerlink" title="iTerm2 快速隐藏和显示"></a>iTerm2 快速隐藏和显示</h3><p>这个功能也非常使用，就是通过快捷键，可以快速的隐藏和打开 iTerm2，示例配置（Commond + .）：<br><img src="https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191221150103.png" alt></p><h2 id="Oh-my-zsh"><a href="#Oh-my-zsh" class="headerlink" title="Oh my zsh"></a>Oh my zsh</h2><p>通过在终端中运行以下命令之一，可以安装 myzsh。 您可以通过命令行使用 curl 或 wget 来安装它。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure></p><p>安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）：<br>To update your account to use zsh, please run <code>chsh -s /bin/zsh</code>.</p><p>You’ll need to remove <code>/Users/用户XXX/.oh-my-zsh</code> if you want to reinstall.</p><p>换主题<br>打开～/.zshrc。oh my zsh提供了数十种主题，相关文件在~/.oh-my-zsh/themes下。<br>若要使用不同的主题，只需更改值以匹配所需主题的名称。 例如:</p><p><code>vim ~/.zshrc</code>编辑<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"agnoster"</span> <span class="comment"># (this is one of the fancy ones)</span></span><br><span class="line"><span class="comment"># see https://github.com/ohmyzsh/ohmyzsh/wiki/Themes#agnoster</span></span><br></pre></td></tr></table></figure></p><p>如果你感觉精力充沛，你可以让计算机在你每次打开一个新的终端窗口时为你随机选择一个。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">"random"</span> <span class="comment"># (...please let it be pie... please be some pie..)</span></span><br></pre></td></tr></table></figure></p><p>如果你想从你最喜欢的主题列表中随机选择主题:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME_RANDOM_CANDIDATES=(</span><br><span class="line">  <span class="string">"robbyrussell"</span></span><br><span class="line">  <span class="string">"agnoster"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><blockquote><p>注意每次添加插件以后，都要进行<code>source .zshrc</code>一下，让这些插件运行起来。</p></blockquote><h3 id="Enabling-Plugins-启用插件"><a href="#Enabling-Plugins-启用插件" class="headerlink" title="Enabling Plugins 启用插件"></a>Enabling Plugins 启用插件</h3><p>一旦你发现一个插件(或者几个) ，你想用 Oh My Zsh，你需要在。 Zshrc 文件。 您将在 $HOME 目录中找到 zshrc 文件。 用你最喜欢的文本编辑器打开它，你会看到一个地方列出所有你想要加载的插件。<br><code>$ZSH/plugins</code>: oh-my-zsh 官方插件目录，该目录已经预装了很多实用的插件，只不过没激活而已；<br><code>$ZSH_CUSTOM/plugins</code>: oh-my-zsh 第三方插件目录；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br></pre></td></tr></table></figure><p>For example, this might begin to look like this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  bundler</span><br><span class="line">  dotenv</span><br><span class="line">  osx</span><br><span class="line">  rake</span><br><span class="line">  rbenv</span><br><span class="line">  ruby</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>Note that the plugins are separated by whitespace. Do not use commas between them.<br>请注意，这些插件是用空格分隔的。 不要在它们之间使用逗号。</p><h4 id="git插件"><a href="#git插件" class="headerlink" title="git插件"></a>git插件</h4><p><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git" target="_blank" rel="noopener">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/git</a></p><p>The git plugin provides many <a href="#aliases">aliases</a> and a few useful <a href="#functions">functions</a>.</p><p>To use it, add <code>git</code> to the plugins array in your zshrc file:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(... git)</span><br></pre></td></tr></table></figure><p><strong>Aliases</strong></p><table><thead><tr><th style="text-align:left">Alias</th><th style="text-align:left">Command</th></tr></thead><tbody><tr><td style="text-align:left">g</td><td style="text-align:left">git</td></tr><tr><td style="text-align:left">ga</td><td style="text-align:left">git add</td></tr><tr><td style="text-align:left">gaa</td><td style="text-align:left">git add –all</td></tr><tr><td style="text-align:left">gapa</td><td style="text-align:left">git add –patch</td></tr><tr><td style="text-align:left">gau</td><td style="text-align:left">git add –update</td></tr><tr><td style="text-align:left">gav</td><td style="text-align:left">git add –verbose</td></tr><tr><td style="text-align:left">gap</td><td style="text-align:left">git apply</td></tr><tr><td style="text-align:left">gb</td><td style="text-align:left">git branch</td></tr><tr><td style="text-align:left">gba</td><td style="text-align:left">git branch -a</td></tr><tr><td style="text-align:left">gbd</td><td style="text-align:left">git branch -d</td></tr><tr><td style="text-align:left">gbda</td><td style="text-align:left">`git branch –no-color –merged \</td><td>command grep -vE “^(+</td><td>*\</td><td>\s*(master\</td><td>develop\</td><td>dev)\s*$)” \</td><td>command xargs -n 1 git branch -d`</td></tr><tr><td style="text-align:left">gbD</td><td style="text-align:left">git branch -D</td></tr><tr><td style="text-align:left">gbl</td><td style="text-align:left">git blame -b -w</td></tr><tr><td style="text-align:left">gbnm</td><td style="text-align:left">git branch –no-merged</td></tr><tr><td style="text-align:left">gbr</td><td style="text-align:left">git branch –remote</td></tr><tr><td style="text-align:left">gbs</td><td style="text-align:left">git bisect</td></tr><tr><td style="text-align:left">gbsb</td><td style="text-align:left">git bisect bad</td></tr><tr><td style="text-align:left">gbsg</td><td style="text-align:left">git bisect good</td></tr><tr><td style="text-align:left">gbsr</td><td style="text-align:left">git bisect reset</td></tr><tr><td style="text-align:left">gbss</td><td style="text-align:left">git bisect start</td></tr><tr><td style="text-align:left">gc</td><td style="text-align:left">git commit -v</td></tr><tr><td style="text-align:left">gc!</td><td style="text-align:left">git commit -v –amend</td></tr><tr><td style="text-align:left">gcn!</td><td style="text-align:left">git commit -v –no-edit –amend</td></tr><tr><td style="text-align:left">gca</td><td style="text-align:left">git commit -v -a</td></tr><tr><td style="text-align:left">gca!</td><td style="text-align:left">git commit -v -a –amend</td></tr><tr><td style="text-align:left">gcan!</td><td style="text-align:left">git commit -v -a –no-edit –amend</td></tr><tr><td style="text-align:left">gcans!</td><td style="text-align:left">git commit -v -a -s –no-edit –amend</td></tr><tr><td style="text-align:left">gcam</td><td style="text-align:left">git commit -a -m</td></tr><tr><td style="text-align:left">gcsm</td><td style="text-align:left">git commit -s -m</td></tr><tr><td style="text-align:left">gcb</td><td style="text-align:left">git checkout -b</td></tr><tr><td style="text-align:left">gcf</td><td style="text-align:left">git config –list</td></tr><tr><td style="text-align:left">gcl</td><td style="text-align:left">git clone –recurse-submodules</td></tr><tr><td style="text-align:left">gclean</td><td style="text-align:left">git clean -id</td></tr><tr><td style="text-align:left">gpristine</td><td style="text-align:left">git reset –hard &amp;&amp; git clean -dfx</td></tr><tr><td style="text-align:left">gcm</td><td style="text-align:left">git checkout master</td></tr><tr><td style="text-align:left">gcd</td><td style="text-align:left">git checkout develop</td></tr><tr><td style="text-align:left">gcmsg</td><td style="text-align:left">git commit -m</td></tr><tr><td style="text-align:left">gco</td><td style="text-align:left">git checkout</td></tr><tr><td style="text-align:left">gcount</td><td style="text-align:left">git shortlog -sn</td></tr><tr><td style="text-align:left">gcp</td><td style="text-align:left">git cherry-pick</td></tr><tr><td style="text-align:left">gcpa</td><td style="text-align:left">git cherry-pick –abort</td></tr><tr><td style="text-align:left">gcpc</td><td style="text-align:left">git cherry-pick –continue</td></tr><tr><td style="text-align:left">gcs</td><td style="text-align:left">git commit -S</td></tr><tr><td style="text-align:left">gd</td><td style="text-align:left">git diff</td></tr><tr><td style="text-align:left">gdca</td><td style="text-align:left">git diff –cached</td></tr><tr><td style="text-align:left">gdcw</td><td style="text-align:left">git diff –cached –word-diff</td></tr><tr><td style="text-align:left">gdct</td><td style="text-align:left">git describe –tags $(git rev-list –tags –max-count=1)</td></tr><tr><td style="text-align:left">gds</td><td style="text-align:left">git diff –staged</td></tr><tr><td style="text-align:left">gdt</td><td style="text-align:left">git diff-tree –no-commit-id –name-only -r</td></tr><tr><td style="text-align:left">gdv</td><td style="text-align:left">git diff -w $@ \</td><td>view -</td></tr><tr><td style="text-align:left">gdw</td><td style="text-align:left">git diff –word-diff</td></tr><tr><td style="text-align:left">gf</td><td style="text-align:left">git fetch</td></tr><tr><td style="text-align:left">gfa</td><td style="text-align:left">git fetch –all –prune</td></tr><tr><td style="text-align:left">gfg</td><td style="text-align:left">git ls-files \</td><td>grep</td></tr><tr><td style="text-align:left">gfo</td><td style="text-align:left">git fetch origin</td></tr><tr><td style="text-align:left">gg</td><td style="text-align:left">git gui citool</td></tr><tr><td style="text-align:left">gga</td><td style="text-align:left">git gui citool –amend</td></tr><tr><td style="text-align:left">ggf</td><td style="text-align:left">git push –force origin $(current_branch)</td></tr><tr><td style="text-align:left">ggfl</td><td style="text-align:left">git push –force-with-lease origin $(current_branch)</td></tr><tr><td style="text-align:left">ggl</td><td style="text-align:left">git pull origin $(current_branch)</td></tr><tr><td style="text-align:left">ggp</td><td style="text-align:left">git push origin $(current_branch)</td></tr><tr><td style="text-align:left">ggpnp</td><td style="text-align:left">ggl &amp;&amp; ggp</td></tr><tr><td style="text-align:left">ggpull</td><td style="text-align:left">git pull origin “$(git_current_branch)”</td></tr><tr><td style="text-align:left">ggpur</td><td style="text-align:left">ggu</td></tr><tr><td style="text-align:left">ggpush</td><td style="text-align:left">git push origin “$(git_current_branch)”</td></tr><tr><td style="text-align:left">ggsup</td><td style="text-align:left">git branch –set-upstream-to=origin/$(git_current_branch)</td></tr><tr><td style="text-align:left">ggu</td><td style="text-align:left">git pull –rebase origin $(current_branch)</td></tr><tr><td style="text-align:left">gpsup</td><td style="text-align:left">git push –set-upstream origin $(git_current_branch)</td></tr><tr><td style="text-align:left">ghh</td><td style="text-align:left">git help</td></tr><tr><td style="text-align:left">gignore</td><td style="text-align:left">git update-index –assume-unchanged</td></tr><tr><td style="text-align:left">gignored</td><td style="text-align:left">git ls-files -v \</td><td>grep “^[[:lower:]]”</td></tr><tr><td style="text-align:left">git-svn-dcommit-push</td><td style="text-align:left">git svn dcommit &amp;&amp; git push github master:svntrunk</td></tr><tr><td style="text-align:left">gk</td><td style="text-align:left">gitk –all –branches</td></tr><tr><td style="text-align:left">gke</td><td style="text-align:left">gitk –all $(git log -g –pretty=%h)</td></tr><tr><td style="text-align:left">gl</td><td style="text-align:left">git pull</td></tr><tr><td style="text-align:left">glg</td><td style="text-align:left">git log –stat</td></tr><tr><td style="text-align:left">glgp</td><td style="text-align:left">git log –stat -p</td></tr><tr><td style="text-align:left">glgg</td><td style="text-align:left">git log –graph</td></tr><tr><td style="text-align:left">glgga</td><td style="text-align:left">git log –graph –decorate –all</td></tr><tr><td style="text-align:left">glgm</td><td style="text-align:left">git log –graph –max-count=10</td></tr><tr><td style="text-align:left">glo</td><td style="text-align:left">git log –oneline –decorate</td></tr><tr><td style="text-align:left">glol</td><td style="text-align:left">git log –graph –pretty=’%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’</td></tr><tr><td style="text-align:left">glols</td><td style="text-align:left">git log –graph –pretty=’%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –stat</td></tr><tr><td style="text-align:left">glod</td><td style="text-align:left">git log –graph –pretty=’%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset’</td></tr><tr><td style="text-align:left">glods</td><td style="text-align:left">git log –graph –pretty=’%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)&lt;%an&gt;%Creset’ –date=short</td></tr><tr><td style="text-align:left">glola</td><td style="text-align:left">git log –graph –pretty=’%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –all</td></tr><tr><td style="text-align:left">glog</td><td style="text-align:left">git log –oneline –decorate –graph</td></tr><tr><td style="text-align:left">gloga</td><td style="text-align:left">git log –oneline –decorate –graph –all</td></tr><tr><td style="text-align:left">glp</td><td style="text-align:left"><code>_git_log_prettily</code></td></tr><tr><td style="text-align:left">gm</td><td style="text-align:left">git merge</td></tr><tr><td style="text-align:left">gmom</td><td style="text-align:left">git merge origin/master</td></tr><tr><td style="text-align:left">gmt</td><td style="text-align:left">git mergetool –no-prompt</td></tr><tr><td style="text-align:left">gmtvim</td><td style="text-align:left">git mergetool –no-prompt –tool=vimdiff</td></tr><tr><td style="text-align:left">gmum</td><td style="text-align:left">git merge upstream/master</td></tr><tr><td style="text-align:left">gma</td><td style="text-align:left">git merge –abort</td></tr><tr><td style="text-align:left">gp</td><td style="text-align:left">git push</td></tr><tr><td style="text-align:left">gpd</td><td style="text-align:left">git push –dry-run</td></tr><tr><td style="text-align:left">gpf</td><td style="text-align:left">git push –force-with-lease</td></tr><tr><td style="text-align:left">gpf!</td><td style="text-align:left">git push –force</td></tr><tr><td style="text-align:left">gpoat</td><td style="text-align:left">git push origin –all &amp;&amp; git push origin –tags</td></tr><tr><td style="text-align:left">gpu</td><td style="text-align:left">git push upstream</td></tr><tr><td style="text-align:left">gpv</td><td style="text-align:left">git push -v</td></tr><tr><td style="text-align:left">gr</td><td style="text-align:left">git remote</td></tr><tr><td style="text-align:left">gra</td><td style="text-align:left">git remote add</td></tr><tr><td style="text-align:left">grb</td><td style="text-align:left">git rebase</td></tr><tr><td style="text-align:left">grba</td><td style="text-align:left">git rebase –abort</td></tr><tr><td style="text-align:left">grbc</td><td style="text-align:left">git rebase –continue</td></tr><tr><td style="text-align:left">grbd</td><td style="text-align:left">git rebase develop</td></tr><tr><td style="text-align:left">grbi</td><td style="text-align:left">git rebase -i</td></tr><tr><td style="text-align:left">grbm</td><td style="text-align:left">git rebase master</td></tr><tr><td style="text-align:left">grbs</td><td style="text-align:left">git rebase –skip</td></tr><tr><td style="text-align:left">grev</td><td style="text-align:left">git revert</td></tr><tr><td style="text-align:left">grh</td><td style="text-align:left">git reset</td></tr><tr><td style="text-align:left">grhh</td><td style="text-align:left">git reset –hard</td></tr><tr><td style="text-align:left">groh</td><td style="text-align:left">git reset origin/$(git_current_branch) –hard</td></tr><tr><td style="text-align:left">grm</td><td style="text-align:left">git rm</td></tr><tr><td style="text-align:left">grmc</td><td style="text-align:left">git rm –cached</td></tr><tr><td style="text-align:left">grmv</td><td style="text-align:left">git remote rename</td></tr><tr><td style="text-align:left">grrm</td><td style="text-align:left">git remote remove</td></tr><tr><td style="text-align:left">grs</td><td style="text-align:left">git restore</td></tr><tr><td style="text-align:left">grset</td><td style="text-align:left">git remote set-url</td></tr><tr><td style="text-align:left">grss</td><td style="text-align:left">git restore –source</td></tr><tr><td style="text-align:left">grt</td><td style="text-align:left">cd “$(git rev-parse –show-toplevel \</td><td>\</td><td>echo .)”</td></tr><tr><td style="text-align:left">gru</td><td style="text-align:left">git reset –</td></tr><tr><td style="text-align:left">grup</td><td style="text-align:left">git remote update</td></tr><tr><td style="text-align:left">grv</td><td style="text-align:left">git remote -v</td></tr><tr><td style="text-align:left">gsb</td><td style="text-align:left">git status -sb</td></tr><tr><td style="text-align:left">gsd</td><td style="text-align:left">git svn dcommit</td></tr><tr><td style="text-align:left">gsh</td><td style="text-align:left">git show</td></tr><tr><td style="text-align:left">gsi</td><td style="text-align:left">git submodule init</td></tr><tr><td style="text-align:left">gsps</td><td style="text-align:left">git show –pretty=short –show-signature</td></tr><tr><td style="text-align:left">gsr</td><td style="text-align:left">git svn rebase</td></tr><tr><td style="text-align:left">gss</td><td style="text-align:left">git status -s</td></tr><tr><td style="text-align:left">gst</td><td style="text-align:left">git status</td></tr><tr><td style="text-align:left">gsta</td><td style="text-align:left">git stash push</td></tr><tr><td style="text-align:left">gsta</td><td style="text-align:left">git stash save</td></tr><tr><td style="text-align:left">gstaa</td><td style="text-align:left">git stash apply</td></tr><tr><td style="text-align:left">gstc</td><td style="text-align:left">git stash clear</td></tr><tr><td style="text-align:left">gstd</td><td style="text-align:left">git stash drop</td></tr><tr><td style="text-align:left">gstl</td><td style="text-align:left">git stash list</td></tr><tr><td style="text-align:left">gstp</td><td style="text-align:left">git stash pop</td></tr><tr><td style="text-align:left">gsts</td><td style="text-align:left">git stash show –text</td></tr><tr><td style="text-align:left">gstall</td><td style="text-align:left">git stash –all</td></tr><tr><td style="text-align:left">gsu</td><td style="text-align:left">git submodule update</td></tr><tr><td style="text-align:left">gsw</td><td style="text-align:left">git switch</td></tr><tr><td style="text-align:left">gswc</td><td style="text-align:left">git switch -c</td></tr><tr><td style="text-align:left">gts</td><td style="text-align:left">git tag -s</td></tr><tr><td style="text-align:left">gtv</td><td style="text-align:left">git tag \</td><td>sort -V</td></tr><tr><td style="text-align:left">gtl</td><td style="text-align:left">gtl(){ git tag –sort=-v:refname -n -l ${1}* }; noglob gtl</td></tr><tr><td style="text-align:left">gunignore</td><td style="text-align:left">git update-index –no-assume-unchanged</td></tr><tr><td style="text-align:left">gunwip</td><td style="text-align:left">git log -n 1 \</td><td>grep -q -c “--wip--“ &amp;&amp; git reset HEAD~1</td></tr><tr><td style="text-align:left">gup</td><td style="text-align:left">git pull –rebase</td></tr><tr><td style="text-align:left">gupv</td><td style="text-align:left">git pull –rebase -v</td></tr><tr><td style="text-align:left">gupa</td><td style="text-align:left">git pull –rebase –autostash</td></tr><tr><td style="text-align:left">gupav</td><td style="text-align:left">git pull –rebase –autostash -v</td></tr><tr><td style="text-align:left">glum</td><td style="text-align:left">git pull upstream master</td></tr><tr><td style="text-align:left">gwch</td><td style="text-align:left">git whatchanged -p –abbrev-commit –pretty=medium</td></tr><tr><td style="text-align:left">gwip</td><td style="text-align:left">git add -A; git rm $(git ls-files –deleted) 2&gt; /dev/null; git commit –no-verify –no-gpg-sign -m “–wip– [skip ci]”</td></tr></tbody></table><h4 id="web-search-plugin"><a href="#web-search-plugin" class="headerlink" title="web-search plugin"></a>web-search plugin</h4><p>This plugin adds aliases for searching with Google, Wiki, Bing, YouTube and other popular services.</p><p>Open your <code>~/.zshrc</code> file and enable the <code>web-search</code> plugin:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( ... web-search)</span><br></pre></td></tr></table></figure><p>Usage 用法</p><p>You can use the <code>web-search</code> plugin in these two forms:</p><ul><li><code>web_search &lt;context&gt; &lt;term&gt; [more terms if you want]</code></li><li><code>&lt;context&gt; &lt;term&gt; [more terms if you want]</code></li></ul><p>For example, these two are equivalent:</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ web_search google oh-my-zsh</span><br><span class="line">$ google oh-my-zsh</span><br></pre></td></tr></table></figure><p>Available search contexts are:</p><table><thead><tr><th>Context</th><th>URL</th></tr></thead><tbody><tr><td><code>bing</code></td><td><code>https://www.bing.com/search?q=</code></td></tr><tr><td><code>google</code></td><td><code>https://www.google.com/search?q=</code></td></tr><tr><td><code>yahoo</code></td><td><code>https://search.yahoo.com/search?p=</code></td></tr><tr><td><code>ddg</code> or <code>duckduckgo</code></td><td><code>https://www.duckduckgo.com/?q=</code></td></tr><tr><td><code>sp</code> or <code>startpage</code></td><td><code>https://www.startpage.com/do/search?q=</code></td></tr><tr><td><code>yandex</code></td><td><code>https://yandex.ru/yandsearch?text=</code></td></tr><tr><td><code>github</code></td><td><code>https://github.com/search?q=</code></td></tr><tr><td><code>baidu</code></td><td><code>https://www.baidu.com/s?wd=</code></td></tr><tr><td><code>ecosia</code></td><td><code>https://www.ecosia.org/search?q=</code></td></tr><tr><td><code>goodreads</code></td><td><code>https://www.goodreads.com/search?q=</code></td></tr><tr><td><code>qwant</code></td><td><code>https://www.qwant.com/?q=</code></td></tr><tr><td><code>givero</code></td><td><code>https://www.givero.com/search?q=</code></td></tr><tr><td><code>stackoverflow</code></td><td><code>https://stackoverflow.com/search?q=</code></td></tr></tbody></table><h4 id="高亮插件"><a href="#高亮插件" class="headerlink" title="高亮插件"></a>高亮插件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>然后编辑配置文件，<code>$ vim ~/.zshrc</code> 添加以下内容:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></p><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>Add the plugin to the list of plugins for Oh My Zsh to load (inside ~/.zshrc):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(zsh-autosuggestions)</span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hightlight 插件前景色, 背景色, 字体配置</span></span><br><span class="line">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=<span class="string">"fg=#BABABA,bg=#66666A,bold,underline"</span></span><br></pre></td></tr></table></figure><h3 id="Powerlevel9k主题"><a href="#Powerlevel9k主题" class="headerlink" title="Powerlevel9k主题"></a>Powerlevel9k主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</span><br></pre></td></tr></table></figure><p>You then need to select this theme in your ~/.zshrc:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;</span><br></pre></td></tr></table></figure></p><p>原版配色我很不喜欢, 蓝色和绿色太纯正. 可以自己换一些配色<br><img src="https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191221230631.png" alt></p><p>如果出现乱码, 说明需要安装Powerline字体<br>mac下的直接执行命令 或者根据提供的GitHub地址手动下载并安装也行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Library/Fonts &amp;&amp; curl -fLo <span class="string">"Droid Sans Mono for Powerline Nerd Font Complete.otf"</span> https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts/DroidSansMono/complete/Droid%20Sans%20Mono%20Nerd%20Font%20Complete.otf</span><br></pre></td></tr></table></figure></p><p>启用该字体<br>After installing nerd-fonts and configuring your terminal emulator to use one, configure Powerlevel9k by putting the following in your ~/.zshrc:</p><p>尼玛不管<code>source ~/.zshrc</code>还是重启终端还是未生效, 结果需要在iTerm中设置一下就搞定了.<br><img src="https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191221175345.png" alt></p><p>去掉左侧默认的命令提示符为 user@userdemackbookPro，这样的提示符配合 powerlevel9k 主题太过冗长，因此我选择将该冗长的提示符去掉，在 ~/.zshrc 配置文件后面追加如下内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认主题 </span></span><br><span class="line"><span class="comment"># ZSH_THEME="robbyrussell"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用powerlevel9k主题</span></span><br><span class="line">ZSH_THEME=<span class="string">"powerlevel9k/powerlevel9k"</span></span><br><span class="line"><span class="comment"># Powerlevel9k主题的字体</span></span><br><span class="line">POWERLEVEL9K_MODE=<span class="string">"nerdfont-complete"</span></span><br><span class="line"><span class="comment"># 注意：DEFAULT_USER 的值必须要是系统用户名才能生效</span></span><br><span class="line">DEFAULT_USER=<span class="string">"ale"</span></span><br><span class="line"><span class="comment"># 左右元素</span></span><br><span class="line">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(ssh dir vcs)</span><br><span class="line">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(command_execution_time status background_jobs time)</span><br><span class="line"><span class="comment"># 貌似和iTerm冲突, 我也是醉了</span></span><br><span class="line"><span class="comment"># POWERLEVEL9K_COLOR_SCHEME='dark'</span></span><br><span class="line"><span class="comment"># -------------------------------- POWERLEVEL ---------------------------------</span></span><br><span class="line">POWERLEVEL9K_PROMPT_ON_NEWLINE=<span class="literal">true</span></span><br><span class="line">POWERLEVEL9K_RPROMPT_ON_NEWLINE=<span class="literal">true</span></span><br><span class="line">POWERLEVEL9K_SHORTEN_DIR_LENGTH=2</span><br><span class="line">POWERLEVEL9K=truncate_beginning</span><br><span class="line">POWERLEVEL9K_TIME_BACKGROUND=black</span><br><span class="line">POWERLEVEL9K_TIME_FOREGROUND=white</span><br><span class="line">POWERLEVEL9K_TIME_FORMAT=%D&#123;%I:%M&#125;</span><br><span class="line">POWERLEVEL9K_STATUS_VERBOSE=<span class="literal">false</span></span><br><span class="line">POWERLEVEL9K_VCS_CLEAN_FOREGROUND=black</span><br><span class="line">POWERLEVEL9K_VCS_CLEAN_BACKGROUND=green</span><br><span class="line">POWERLEVEL9K_VCS_UNTRACKED_FOREGROUND=black</span><br><span class="line">POWERLEVEL9K_VCS_UNTRACKED_BACKGROUND=yellow</span><br><span class="line">POWERLEVEL9K_VCS_MODIFIED_FOREGROUND=white</span><br><span class="line">POWERLEVEL9K_VCS_MODIFIED_BACKGROUND=black</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_BACKGROUND=black</span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_FOREGROUND=blue</span><br><span class="line">POWERLEVEL9K_FOLDER_ICON=</span><br><span class="line">POWERLEVEL9K_STATUS_OK_IN_NON_VERBOSE=<span class="literal">true</span></span><br><span class="line">POWERLEVEL9K_STATUS_VERBOSE=<span class="literal">false</span></span><br><span class="line">POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=0</span><br><span class="line">POWERLEVEL9K_VCS_UNTRACKED_ICON=●</span><br><span class="line">POWERLEVEL9K_VCS_UNSTAGED_ICON=±</span><br><span class="line">POWERLEVEL9K_VCS_INCOMING_CHANGES_ICON=↓</span><br><span class="line">POWERLEVEL9K_VCS_OUTGOING_CHANGES_ICON=↑</span><br><span class="line">POWERLEVEL9K_VCS_COMMIT_ICON=<span class="string">' '</span></span><br><span class="line">POWERLEVEL9K_MULTILINE_FIRST_PROMPT_PREFIX=<span class="string">'%F&#123;blue&#125;╭─%F&#123;red&#125;'</span></span><br><span class="line">POWERLEVEL9K_MULTILINE_LAST_PROMPT_PREFIX=<span class="string">'%F&#123;blue&#125;╰%f '</span></span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON=<span class="string">'echo   $(whoami) '</span></span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_BACKGROUND=red</span><br><span class="line">POWERLEVEL9K_CUSTOM_OS_ICON_FOREGROUND=white</span><br><span class="line"><span class="comment"># -------------------------------- POWERLEVEL ---------------------------------</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Powerlevel9k/powerlevel9k" target="_blank" rel="noopener">https://github.com/Powerlevel9k/powerlevel9k</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iTerm2是 Terminal 的替代品，也是 iTerm 的继承者。 它适用于 macOS 10.12或更新版本的 mac 电脑。 iTerm2将终端带入了现代社会，带来了一些你从来不知道自己一直想要的功能。&lt;/p&gt;
&lt;h2 id=&quot;iTerm&quot;&gt;&lt;a href=&quot;#i
      
    
    </summary>
    
      <category term="技术软件" scheme="/categories/%E6%8A%80%E6%9C%AF%E8%BD%AF%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Travis CI 构建hexo博客</title>
    <link href="/html/%E6%8C%81%E7%BB%AD%E8%BE%93%E5%87%BA/2019/12/15/travis-ci-%E6%9E%84%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2.html"/>
    <id>/html/持续输出/2019/12/15/travis-ci-构建hexo博客.html</id>
    <published>2019-12-15T05:58:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>前提条件:</p><ul><li>必须使用一个public的项目, 然后登陆<a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a> 进行关联.</li><li>已存在一个hexo的可以跑起来的项目</li></ul><p>在你的hexo源码项目, 取出master分支中 添加配置文件.travis.yml，并推送到<code>acc8226.github.io</code>项目中.</p><p>配置GH_TOKEN<br>在github添加Access Token，在右上角账号的settings-&gt;Personal access tokens.点击generate new token来生成新token<br>回到Travis官网，在设置中填入刚复制的token，取名为<code>GH_TOKEN</code>，这个名字需要写到下面的配置文件中.</p><p>配置GH_REF<br>这个家伙写在配置文件的env中</p><p>配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"Travis-CI"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"Travis-CI@feipig.fun"</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Update docs with TRAVIS-CI."</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># safelist</span></span><br><span class="line"><span class="attr">branches:</span> </span><br><span class="line"><span class="attr">  only:</span> </span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line"><span class="attr">  depth:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span> </span><br><span class="line"><span class="attr">  global:</span> </span><br><span class="line">    <span class="comment"># 使用https, 若使用ssh会出错</span></span><br><span class="line"><span class="attr">    - GH_REF:</span> <span class="string">github.com/acc8226/acc8226.github.io.git</span></span><br></pre></td></tr></table></figure></p><blockquote><p>要使用https协议的仓库地址，使用ssh仓库地址会失败。 </p></blockquote><p>配置完成后推送到仓库中，我们就能看到网站<a href="https://acc8226.github.io/" target="_blank" rel="noopener">https://acc8226.github.io/</a> 中在部署了。</p><h2 id="进一步讨论"><a href="#进一步讨论" class="headerlink" title="进一步讨论"></a>进一步讨论</h2><p>但是github慢, 所以选择了coding Pages服务</p><p>在 Coding 的”个人设置”页面中找到访问令牌，新建一个新的访问令牌，这里我们选第一个权限即可，因为我们只需要为 Travis 提供基本的读写权限，这样我们会生成一个 Token，这里注意保存 Token，因为它在这里只显示这一次，我们将 Token 填写到 Travis CI 的后台. 取名为<code>CODING_TOKEN</code></p><h3 id="coding利用令牌访问代码仓库"><a href="#coding利用令牌访问代码仓库" class="headerlink" title="coding利用令牌访问代码仓库"></a>coding利用令牌访问代码仓库</h3><p>在设置 Scope 权限选项中勾选 project:depot 后，可以用于访问代码仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://testuser:90ed7a169febb12d17e14aa5531827476f6b3a4e@test.coding.net/test/testRepo.git</span><br><span class="line">Cloning into &apos;testRepo&apos;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (7/7), done.</span><br><span class="line">remote: Total 11 (delta 2), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (11/11), done.</span><br></pre></td></tr></table></figure></p><p>由此可知需要额外配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span> </span><br><span class="line"><span class="attr">  global:</span> </span><br><span class="line">    <span class="comment"># Coding Pages</span></span><br><span class="line"><span class="attr">    - USER_NAME:</span> <span class="string">aleevz</span></span><br><span class="line"><span class="attr">    - CODING_REF:</span> <span class="string">git.dev.tencent.com/aleevz/aleevz.coding.me.git</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>travis-ci 官网<br><a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a></p><p><a href="https://blog.csdn.net/qq_36759224/article/details/100879609" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/100879609</a><br>基于Travis CI实现 Hexo 在 Github 和 Coding 的同步部署</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前提条件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须使用一个public的项目, 然后登陆&lt;a href=&quot;https://travis-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://travis-ci.org/&lt;/a&gt; 进行关联.&lt;
      
    
    </summary>
    
      <category term="持续输出" scheme="/categories/%E6%8C%81%E7%BB%AD%E8%BE%93%E5%87%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>使用GitHub搭建免费图床/网盘(CDN加速)</title>
    <link href="/html/%E6%9C%8D%E5%8A%A1%E5%99%A8/2019/11/18/%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A-%E7%BD%91%E7%9B%98-cdn%E5%8A%A0%E9%80%9F.html"/>
    <id>/html/服务器/2019/11/18/使用github搭建免费图床-网盘-cdn加速.html</id>
    <published>2019-11-18T15:41:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>当我购买了域名后, 让我想好好利用这个已有域名获取免费的图床服务. 另一方面我所有写的md文章会用到, 不想受制于目前的简书图床. </p><h3 id="自己的服务器开放图床"><a href="#自己的服务器开放图床" class="headerlink" title="自己的服务器开放图床"></a>自己的服务器开放图床</h3><p>服务器到期后就尴尬了, 排除. 到时候只能提前迁出, 非常麻烦. 另外一方面也说明文件命名非常重要.</p><h3 id="尝试阿里云-腾讯云等其他品牌的OOS"><a href="#尝试阿里云-腾讯云等其他品牌的OOS" class="headerlink" title="尝试阿里云, 腾讯云等其他品牌的OOS"></a>尝试阿里云, 腾讯云等其他品牌的OOS</h3><p>服务虽好, 可是需要付费</p><h3 id="尝试七牛图床"><a href="#尝试七牛图床" class="headerlink" title="尝试七牛图床"></a>尝试七牛图床</h3><p>存储服务创建完成后，需要配置一个融合CDN域名，融合CDN域名简单来说就是指资源对象的外链域名，七牛云提供了融合CDN的测试域名，官方提示为：七牛融合 CDN 测试域名（以 clouddn.com/qiniucdn.com/qiniudn.com/qnssl.com/qbox.me 结尾），每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动回收，仅供测试使用并且不支持 Https 访问。因此需要我们自己配置一个CDN加速域名. </p><p><strong>七牛测试域名1个月失效的问题(网友提供的解决方法)</strong><br>七牛提供的测试域名1个月就失效了，通常是够用的 。 如果失效了，也不用担心，找到原始的markdown 文件，用下面的命令对文件做个替换即可（new.bkt.clouddn域名需要按照实际进行替换）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s#//.*bkt.clouddn#//new.bkt.clouddn#g&quot; file.md</span><br></pre></td></tr></table></figure></p><p><strong>注: 目前七牛不再提供测试域名了, 只能挥手告别. 哪怕按月或年付费也是可以的, 只要服务好</strong></p><h3 id="尝试简书的免费图床"><a href="#尝试简书的免费图床" class="headerlink" title="尝试简书的免费图床"></a>尝试简书的免费图床</h3><p>这是我一直不抛弃简书的原因, 目前一直在用, 想要用到图片的地方直接ctrl + V就可以了. 可是万一哪天简书突然变政策了就不好了.</p><h3 id="最终方案-尝试使用Page服务的图床"><a href="#最终方案-尝试使用Page服务的图床" class="headerlink" title="(最终方案)尝试使用Page服务的图床"></a>(最终方案)尝试使用Page服务的图床</h3><p>腾讯旗下的coding 和 oschina旗下的码云在国内比较靠谱, 一方面空间没仔细看,空间不知道大不大.<br>想的是开启Page服务然后git上传获得外链这种解决方案. 就是整体操作起来太麻烦.</p><p>github服务器在国外, 直接访问肯定太慢. 知道看到了教程<strong><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>, <a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr</a>, <a href="https://github.com/" target="_blank" rel="noopener">github</a></strong>的组合. 令我眼前一亮.</p><blockquote><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用</p></blockquote><blockquote><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>参考教程: <a href="https://www.bilibili.com/video/av65336062?from=search&amp;seid=4753922999762898690" target="_blank" rel="noopener">视频教程</a>  / <a href="https://301technology.cn/2019/08/03/picgojsdelivrgithub/" target="_blank" rel="noopener">文字教程</a></p><p>条件就是你得拥有一个github账号, 下载一个PicGo的软件(mac还是win系统都支持)</p><p>—华丽的分割线—留存, 换行<code>784(8-26*0f9f16*bfdaaf~2e90b-193f)240-9709ffff0~5</code>—华丽的分割线—</p><h4 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h4><p>见上方参考教程.</p><h4 id="jsDelivr配置"><a href="#jsDelivr配置" class="headerlink" title="jsDelivr配置"></a>jsDelivr配置</h4><p>jsDelivr由于和PicGo搭配使用, 无需额外配置</p><h4 id="PicGo配置说明"><a href="#PicGo配置说明" class="headerlink" title="PicGo配置说明"></a>PicGo配置说明</h4><ul><li>设定仓库名：按照【用户名 / 图床仓库名】的格式填写</li><li>设定分支名：【master】</li><li>设定Token：粘贴之前生成的【Token】</li><li>指定存储路径：填写想要储存的路径，如【images/】，这样就会在仓库下创建一个名为 images 的文件夹，图片将会储存在此文件夹中</li><li>设定自定义域名：它的的作用是，在图片上传后，PicGo会按照【自定义域名+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用jsDelivr加速访问，所以可以设置为【<a href="https://cdn.jsdelivr.net/gh/用户名/图床仓库名" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/用户名/图床仓库名</a> 】<br><code>jsDelivr参考格式: The URL structure is /gh/user/repo@version/file.js</code></li></ul><p>最终成品的地址如下, 图片是我通过PicGo上传的, yml则是我直接通过github网页上传的, 都能完美预览和下载.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191117181015.png</span><br><span class="line"></span><br><span class="line">https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/20191117180214.jpg</span><br><span class="line"></span><br><span class="line">https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/img/latest-mac.yml</span><br><span class="line"></span><br><span class="line">https://cdn.jsdelivr.net/gh/acc8226/JsDelivrCDN/.travis.yml</span><br></pre></td></tr></table></figure></p><h4 id="PicGo-mac版的自定义配置"><a href="#PicGo-mac版的自定义配置" class="headerlink" title="PicGo mac版的自定义配置"></a>PicGo mac版的自定义配置</h4><p><img src="https://upload-images.jianshu.io/upload_images/1662509-63eb930b124b85ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>对于追求<a href="https://www.iplaysoft.com/tag/%E6%95%88%E7%8E%87" target="_blank" rel="noopener">效率</a>的键盘党而言，你还可以使用键盘快捷键 <code>CTRL+SHIFT+P</code> (Win / Linux) 或者 <code>Command+SHIFT+P</code> (macOS) 来快速上传剪贴板里的 (第一张) 图片。</p><h4 id="国内如何下载-GitHub-release-中的内容？"><a href="#国内如何下载-GitHub-release-中的内容？" class="headerlink" title="国内如何下载 GitHub release 中的内容？"></a>国内如何下载 GitHub release 中的内容？</h4><blockquote><p>作者：dwing<br>链接：<a href="https://www.zhihu.com/question/48480151/answer/803199369" target="_blank" rel="noopener">https://www.zhihu.com/question/48480151/answer/803199369</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>release中的下载链接虽然是<a href="https://link.zhihu.com/?target=http%3A//github.com" target="_blank" rel="noopener">http://github.com</a>开头,但会跳转到*.<a href="https://link.zhihu.com/?target=https%3A//github-production-release-asset-2e65be.s3.amazonaws.com/7190986/d5bdc4c4-93b1-11e7-918b-63a983282388%3FX-Amz-Algorithm%3DAWS4-HMAC-SHA256%26X-Amz-Credential%3DAKIAIWNJYAX4CSVEH53A%252F20170914%252Fus-east-1%252Fs3%252Faws4_request%26X-Amz-Date%3D20170914T170257Z%26X-Amz-Expires%3D300%26X-Amz-Signature%3Db375ba0ecc76ed7a6fc8f732cefbe9caff49226fda3f54e109e9a79a94673d66%26X-Amz-SignedHeaders%3Dhost%26actor_id%3D0%26response-content-disposition%3Dattachment%253B%2520filename%253Dshadowsocks-nightly-4.2.5.apk%26response-content-type%3Dapplication%252Fvnd.android.package-archive" target="_blank" rel="noopener">s3.amazonaws.com</a>这个域名, 后面带了很长的参数, 貌似是一次性的只能临时下载用, 很快就会失效, 然后只能从github.com开头的地址重新跳转取得新的实际下载链接.</p><p>至于release的下载速度, 最快只有几十KB/s, 慢的时候可能掉到十几K甚至几K. 如果把跳转后的真实下载链接中的https手动改为http开头, 则下载速度会提高到几百K甚至更高. 怀疑是https有墙在阻碍.</p><p>然而, release下载的稳定性并不好, 如果下载文件很大, 很容易在中途中断(http方式下载还经常在99%的进度中断), 然后有的下载工具还续不上</p></blockquote><p>目前找到比较好的方式是用 <strong>Free Download Manager</strong> 直接下载<a href="https://link.zhihu.com/?target=http%3A//github.com" target="_blank" rel="noopener">http://github.com</a>开头的<strong>原链接</strong>, 可以自动跳转并多线程下载. 如果中途中断, 可在右键菜单里选择”更改URL”然后之间点确定就会重新跳转新的临时下载地址并续传.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来想着那个购买的域名大做文章, 发现好用自在身边. 感谢PicGo的作者, 感谢jsdelivr提供的cdn服务, 感谢所有!</p><h2 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h2><p>Github官网<br><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>PigGo<br><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/blackboard/activity-newstar4.html?msource=caitiao" title="叮！你的笔记本电脑和季度大会员等待领取中！" target="_blank" rel="noopener">活动作品</a>关于博客的最稳定的图床方案<br><a href="https://www.bilibili.com/video/av65336062?from=search&amp;seid=4753922999762898690" target="_blank" rel="noopener">https://www.bilibili.com/video/av65336062?from=search&amp;seid=4753922999762898690</a></p><p>目前最稳定的免费图床方案 - 301技术-HuanHao<br><a href="https://301technology.cn/2019/08/03/picgojsdelivrgithub/" target="_blank" rel="noopener">https://301technology.cn/2019/08/03/picgojsdelivrgithub/</a></p><p>Github+jsDelivr+PicGo 打造稳定快速、高效免费图床<br><a href="https://blog.csdn.net/qq_36759224/article/details/98058240" target="_blank" rel="noopener">https://blog.csdn.net/qq_36759224/article/details/98058240</a></p><p>PicGo - 免费开源的图片上传与管理工具 (Markdown写作贴图 / 跨平台图床应用)<br><a href="https://www.iplaysoft.com/picgo.html" target="_blank" rel="noopener">https://www.iplaysoft.com/picgo.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我购买了域名后, 让我想好好利用这个已有域名获取免费的图床服务. 另一方面我所有写的md文章会用到, 不想受制于目前的简书图床. &lt;/p&gt;
&lt;h3 id=&quot;自己的服务器开放图床&quot;&gt;&lt;a href=&quot;#自己的服务器开放图床&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="服务器" scheme="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>16 网络编程</title>
    <link href="/html/java/2018/10/22/16-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>/html/java/2018/10/22/16-网络编程.html</id>
    <published>2018-10-22T10:00:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>Java SE提供java.net包，其中包含了网络编程所需要的最基础一些类和接口。这些类和接口面向两个不同的层次：基于Socket的低层次网络编程和基于URL的高层次网络编程，所谓高低层次就是通信协议的高低层次，Socket采用TCP、UDP等协议，这些协议属于低层次的通信协议；URL采用HTTP和HTTPS这些属于高层次的通信协议。低层次网络编程，因为它面向底层，比较复杂，但是“低层次网络编程”并不等于它功能不强大。恰恰相反，正因为层次低，Socket编程与基于URL的高层次网络编程比较，能够提供更强大的功能和更灵活的控制，但是要更复杂一些。</p><h2 id="数据交换格式"><a href="#数据交换格式" class="headerlink" title="数据交换格式"></a>数据交换格式</h2><p>数据交换格式主要分为纯文本格式、XML格式和JSON格式，其中纯文本格式是一种简单的、无格式的数据交换方式。</p><h3 id="JSON文档结构"><a href="#JSON文档结构" class="headerlink" title="JSON文档结构"></a>JSON文档结构</h3><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。所谓轻量级，是与XML文档结构相比而言的，描述项目的字符少，所以描述相同数据所需的字符个数要少，那么传输速度就会提高，而流量却会减少。</p><p>构成JSON文档的两种结构为对象和数组。对象是“名称-值”对集合，它类似于Java中Map类型，而数组是一连串元素的集合。</p><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p>对象是一个无序的“名称/值”对集合，一个对象以{（左括号）开始，}（右括号）结束。每个“名称”后跟一个:（冒号），“名称-值”对之间使用,（逗号）分隔。JSON对象的语法表如图。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-225f3bfeb8ead835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JSON对象"></p><h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p>数组是值的有序集合，以[（左中括号）开始，]（右中括号）结束，值之间使用,（逗号）分隔。JSON数组的语法表如图17-6所示。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-6a6dac608fa605fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JSON数组"></p><p>在数组中，值可以是双引号括起来的字符串、数值、true、false、null、对象或者数组，而且这些结构可以嵌套。数组中值的JSON语法结构如图所示。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-4ee3f8aa0a52e19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="使用第三方JSON库"><a href="#使用第三方JSON库" class="headerlink" title="使用第三方JSON库"></a>使用第三方JSON库</h4><h5 id="JSON-java库"><a href="#JSON-java库" class="headerlink" title="JSON-java库"></a>JSON-java库</h5><p>目前Java官方没有提供JSON编码和解码所需要的类库，所以需要使用第三方JSON库，笔者推荐JSON-java库，JSON-java库提供源代码，最重要的是不依赖于其他第三方库。</p><p>在<a href="https://github.com/stleary/JSON-java" target="_blank" rel="noopener">https://github.com/stleary/JSON-java</a>下载源代码, 然后创建<code>org.json</code>包并复制源代码文件到对应包即可。</p><h5 id="google-gson"><a href="#google-gson" class="headerlink" title="google/gson"></a><a href="https://github.com/google" target="_blank" rel="noopener">google</a>/<strong><a href="https://github.com/google/gson" target="_blank" rel="noopener">gson</a></strong></h5><h5 id="alibaba-fastjson"><a href="#alibaba-fastjson" class="headerlink" title="alibaba/fastjson"></a><a href="https://github.com/alibaba" target="_blank" rel="noopener">alibaba</a>/<strong><a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a></strong></h5><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p><h2 id="访问互联网资源"><a href="#访问互联网资源" class="headerlink" title="访问互联网资源"></a>访问互联网资源</h2><h3 id="URL概念"><a href="#URL概念" class="headerlink" title="URL概念"></a>URL概念</h3><p>Java的<code>java.net</code>包中还提供了高层次网络编程类——<code>URL</code>，通过URL类访问互联网资源。使用URL进行网络编程，不需要对协议本身有太多的了解，相对而言是比较简单的。</p><p>互联网资源是通过URL指定的，URL是Uniform Resource Locator简称，翻译过来是“一致资源定位器”，但人们都习惯URL简称。<br>URL组成格式如下：<code>协议名://资源名</code><br>例如：<code>http://www.sina.com/</code></p><h4 id="直接使用URL发送GET请求"><a href="#直接使用URL发送GET请求" class="headerlink" title="直接使用URL发送GET请求"></a>直接使用URL发送GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开到此URL的连接，并返回一个输入流。</span></span><br><span class="line">URL reqURL = <span class="keyword">new</span> URL(url);</span><br><span class="line">InputStream is = reqURL.openStream();  <span class="comment">// = openConnection().getInputStream();</span></span><br></pre></td></tr></table></figure><h4 id="使用HttpURLConnection发送GET请求"><a href="#使用HttpURLConnection发送GET请求" class="headerlink" title="使用HttpURLConnection发送GET请求"></a>使用HttpURLConnection发送GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL reqURL = <span class="keyword">new</span> URL(url);</span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) reqURL.openConnection();</span><br><span class="line">conn.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"><span class="comment">// 打开网络通信输入流</span></span><br><span class="line">InputStream is = conn.getInputStream(); </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="使用HttpURLConnection发送POST请求"><a href="#使用HttpURLConnection发送POST请求" class="headerlink" title="使用HttpURLConnection发送POST请求"></a>使用HttpURLConnection发送POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">URL reqURL = <span class="keyword">new</span> URL(urlString);</span><br><span class="line">conn = (HttpURLConnection) reqURL.openConnection();  </span><br><span class="line"><span class="comment">// conn设置</span></span><br><span class="line">conn.setRequestMethod(<span class="string">"POST"</span>);                                 </span><br><span class="line">conn.setDoOutput(<span class="keyword">true</span>);                                        </span><br><span class="line"></span><br><span class="line">String param = <span class="string">"email=%xxx&amp;action=%bbb"</span>; </span><br><span class="line"><span class="comment">// 将请求参数发送给服务器</span></span><br><span class="line">DataOutputStream dStream = <span class="keyword">new</span> DataOutputStream(conn.getOutputStream());   </span><br><span class="line">dStream.writeBytes(param); </span><br><span class="line">dStream.close();                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开网络通信输入流</span></span><br><span class="line">InputStream is = conn.getInputStream();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="实例：Downloader-案例结合了流的读入写出"><a href="#实例：Downloader-案例结合了流的读入写出" class="headerlink" title="实例：Downloader(案例结合了流的读入写出)"></a>实例：Downloader(案例结合了流的读入写出)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downloadFromURL</span><span class="params">(String urlString)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(urlString);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection) url</span><br><span class="line">.openConnection();</span><br><span class="line"></span><br><span class="line">String fileName = <span class="string">"D:/"</span></span><br><span class="line">+ urlString.substring(urlString.lastIndexOf(<span class="string">"/"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (InputStream is = connection.getInputStream();</span><br><span class="line">OutputStream bos = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(fileName))) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">connection.disconnect();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>第 17 章　网络编程-图灵社区<br><a href="http://www.ituring.com.cn/book/tupubarticle/17748" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/17748</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java SE提供java.net包，其中包含了网络编程所需要的最基础一些类和接口。这些类和接口面向两个不同的层次：基于Socket的低层次网络编程和基于URL的高层次网络编程，所谓高低层次就是通信协议的高低层次，Socket采用TCP、UDP等协议，这些协议属于低层次的通
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Ant打包安卓apk(3)-ANT打包自动档(基本版)</title>
    <link href="/html/ant/2018/10/15/ant%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk-3-ant%E6%89%93%E5%8C%85%E8%87%AA%E5%8A%A8%E6%A1%A3-%E5%9F%BA%E6%9C%AC%E7%89%88.html"/>
    <id>/html/ant/2018/10/15/ant打包安卓apk-3-ant打包自动档-基本版.html</id>
    <published>2018-10-15T08:31:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<ol><li>ANT支持</li><li><p>配置环境变量(android和ANT都需要)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_HOME=/Users/Stay/Desktop/develop/android-sdk-mac_x86/</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools</span><br><span class="line">export ANT_HOME=/Users/Stay/Desktop/develop/ant/apache-ant-1.8.4</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANT_HOME&#125;/bin</span><br></pre></td></tr></table></figure></li><li><p>生成一个简单的build.xml，本身sdk/tool/ant 下有个完整的build.xml，我们只要基于它创建一个简单的build.xml即可.</p></li></ol><p>首先切换到项目根目录,<br><code>android update project --path . --name XXX</code> –path更新的是local.properties, –name更新的是build.xml<br>否则会(must already have an AndroidManifest.xml)</p><p>最好需要存在project.properties的情况下, 否则会 <code>Error: The project either has no target set or the target is invalid.</code></p><p>project.properties格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Project target.</span><br><span class="line">target=android-22</span><br></pre></td></tr></table></figure></p><p>这样会更新两个文件<br>Updated <code>local.properties</code>  sdk.dir标签指向路径, 此文件不应该包含在vcs中<br>Updated <code>build.xml</code>  ant文件支持, 我觉得该文件可选是否包含在vcs中</p><p>build.xml实例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project name=&quot;TestAnt&quot; default=&quot;help&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- The local.properties file is created and updated by the &apos;android&apos; tool.</span><br><span class="line">         It contains the path to the SDK. It should *NOT* be checked into</span><br><span class="line">         Version Control Systems. --&gt;</span><br><span class="line">    &lt;property file=&quot;local.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- The ant.properties file can be created by you. It is only edited by the</span><br><span class="line">         &apos;android&apos; tool to add properties to it.</span><br><span class="line">         This is the place to change some Ant specific build properties.</span><br><span class="line">         Here are some properties you may want to change/update:</span><br><span class="line"></span><br><span class="line">         source.dir</span><br><span class="line">             The name of the source directory. Default is &apos;src&apos;.</span><br><span class="line">         out.dir</span><br><span class="line">             The name of the output directory. Default is &apos;bin&apos;.</span><br><span class="line"></span><br><span class="line">         For other overridable properties, look at the beginning of the rules</span><br><span class="line">         files in the SDK, at tools/ant/build.xml</span><br><span class="line"></span><br><span class="line">         Properties related to the SDK location or the project target should</span><br><span class="line">         be updated using the &apos;android&apos; tool with the &apos;update&apos; action.</span><br><span class="line"></span><br><span class="line">         This file is an integral part of the build system for your</span><br><span class="line">         application and should be checked into Version Control Systems.</span><br><span class="line"></span><br><span class="line">         --&gt;</span><br><span class="line">    &lt;property file=&quot;ant.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- if sdk.dir was not set from one of the property file, then</span><br><span class="line">         get it from the ANDROID_HOME env var.</span><br><span class="line">         This must be done before we load project.properties since</span><br><span class="line">         the proguard config can use sdk.dir --&gt;</span><br><span class="line">    &lt;property environment=&quot;env&quot; /&gt;</span><br><span class="line">    &lt;condition property=&quot;sdk.dir&quot; value=&quot;$&#123;env.ANDROID_HOME&#125;&quot;&gt;</span><br><span class="line">        &lt;isset property=&quot;env.ANDROID_HOME&quot; /&gt;</span><br><span class="line">    &lt;/condition&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- The project.properties file is created and updated by the &apos;android&apos;</span><br><span class="line">         tool, as well as ADT.</span><br><span class="line"></span><br><span class="line">         This contains project specific properties such as project target, and library</span><br><span class="line">         dependencies. Lower level build properties are stored in ant.properties</span><br><span class="line">         (or in .classpath for Eclipse projects).</span><br><span class="line"></span><br><span class="line">         This file is an integral part of the build system for your</span><br><span class="line">         application and should be checked into Version Control Systems. --&gt;</span><br><span class="line">    &lt;loadproperties srcFile=&quot;project.properties&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- quick check on sdk.dir --&gt;</span><br><span class="line">    &lt;fail</span><br><span class="line">            message=&quot;sdk.dir is missing. Make sure to generate local.properties using &apos;android update project&apos; or to inject it through the ANDROID_HOME environment variable.&quot;</span><br><span class="line">            unless=&quot;sdk.dir&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        Import per project custom build rules if present at the root of the project.</span><br><span class="line">        This is the place to put custom intermediary targets such as:</span><br><span class="line">            -pre-build</span><br><span class="line">            -pre-compile</span><br><span class="line">            -post-compile (This is typically used for code obfuscation.</span><br><span class="line">                           Compiled code location: $&#123;out.classes.absolute.dir&#125;</span><br><span class="line">                           If this is not done in place, override $&#123;out.dex.input.absolute.dir&#125;)</span><br><span class="line">            -post-package</span><br><span class="line">            -post-build</span><br><span class="line">            -pre-clean</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;import file=&quot;custom_rules.xml&quot; optional=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Import the actual build file.</span><br><span class="line"></span><br><span class="line">         To customize existing targets, there are two options:</span><br><span class="line">         - Customize only one target:</span><br><span class="line">             - copy/paste the target into this file, *before* the</span><br><span class="line">               &lt;import&gt; task.</span><br><span class="line">             - customize it to your needs.</span><br><span class="line">         - Customize the whole content of build.xml</span><br><span class="line">             - copy/paste the content of the rules files (minus the top node)</span><br><span class="line">               into this file, replacing the &lt;import&gt; task.</span><br><span class="line">             - customize to your needs.</span><br><span class="line"></span><br><span class="line">         ***********************</span><br><span class="line">         ****** IMPORTANT ******</span><br><span class="line">         ***********************</span><br><span class="line">         In all cases you must update the value of version-tag below to read &apos;custom&apos; instead of an integer,</span><br><span class="line">         in order to avoid having your file be overridden by tools such as &quot;android update project&quot;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- version-tag: 1 --&gt;</span><br><span class="line">    &lt;import file=&quot;$&#123;sdk.dir&#125;/tools/ant/build.xml&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>你可以使用<code>ant -p</code>检测是否输出日志正常, 如果没问题说明你已经可以<code>ant debug</code>或者<code>ant release</code> 进行打包了<br>ant release需要密钥支持, 并在ant.properties里对key进行声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># keystore路径, 绝对/相对路径</span><br><span class="line">key.store=android.keystore</span><br><span class="line">key.store.password=android</span><br><span class="line">key.alias=androiddebugkey</span><br><span class="line">key.alias.password=android</span><br></pre></td></tr></table></figure></li></ol><h2 id="一些常见命令"><a href="#一些常见命令" class="headerlink" title="一些常见命令"></a>一些常见命令</h2><h3 id="jarsigner验证apk是否签名和完整性-不推荐"><a href="#jarsigner验证apk是否签名和完整性-不推荐" class="headerlink" title="jarsigner验证apk是否签名和完整性(不推荐)"></a>jarsigner验证apk是否签名和完整性(不推荐)</h3><p>jarsigner -verify xxx.apk 验证apk</p><ul><li>验证失败(因为我多渠道打包更改了清单文件)<br><code>jarsigner: java.lang.SecurityException: SHA1 digest error for AndroidManifest.xml</code></li><li>验证成功<br><code>jar 已验证。</code></li></ul><h3 id="使用apksigner-jar进行验证-推荐"><a href="#使用apksigner-jar进行验证-推荐" class="headerlink" title="使用apksigner.jar进行验证(推荐)"></a>使用apksigner.jar进行验证(推荐)</h3><p>使用ant格式, 也可改写为java -jar格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;target name=&quot;verifyApk&quot; description=&quot;checking whether signatures of APK files will verify on Android devices.&quot;&gt;</span><br><span class="line">  &lt;!-- execute a jar in non-forked mode. set fork=&apos;true&apos;. --&gt;</span><br><span class="line">  &lt;java jar=&quot;$&#123;apksigner.jar&#125;&quot; fork=&quot;true&quot;&gt;</span><br><span class="line">    &lt;arg value=&quot;verify&quot; /&gt;</span><br><span class="line">    &lt;arg value=&quot;--verbose&quot; /&gt;</span><br><span class="line">    &lt;arg value=&quot;$&#123;appName.apk&#125;&quot; /&gt;</span><br><span class="line">  &lt;/java&gt;</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure></p><h3 id="android-bat下的常用命令"><a href="#android-bat下的常用命令" class="headerlink" title="android.bat下的常用命令"></a>android.bat下的常用命令</h3><p><code>D:\Android\android-sdk\tools\android.bat -h</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">       Usage:</span><br><span class="line">       android [global options] action [action options]</span><br><span class="line">       Global options:</span><br><span class="line">  -s --silent     : Silent mode, shows errors only.</span><br><span class="line">  -v --verbose    : Verbose mode, shows errors, warnings and all messages.</span><br><span class="line">     --clear-cache: Clear the SDK Manager repository manifest cache.</span><br><span class="line">  -h --help       : Help on a specific command.</span><br><span class="line"></span><br><span class="line">                                                                    Valid</span><br><span class="line">                                                                    actions</span><br><span class="line">                                                                    are</span><br><span class="line">                                                                    composed</span><br><span class="line">                                                                    of a verb</span><br><span class="line">                                                                    and an</span><br><span class="line">                                                                    optional</span><br><span class="line">                                                                    direct</span><br><span class="line">                                                                    object:</span><br><span class="line">-    sdk              : Displays the SDK Manager window.</span><br><span class="line">-    avd              : Displays the AVD Manager window.</span><br><span class="line">-   list              : Lists existing targets or virtual devices.</span><br><span class="line">-   list avd          : Lists existing Android Virtual Devices.</span><br><span class="line">-   list target       : Lists existing targets.</span><br><span class="line">-   list device       : Lists existing devices.</span><br><span class="line">-   list sdk          : Lists remote SDK repository.</span><br><span class="line">- create avd          : Creates a new Android Virtual Device.</span><br><span class="line">-   move avd          : Moves or renames an Android Virtual Device.</span><br><span class="line">- delete avd          : Deletes an Android Virtual Device.</span><br><span class="line">- update avd          : Updates an Android Virtual Device to match the folders</span><br><span class="line">                        of a new SDK.</span><br><span class="line">- create project      : Creates a new Android project.</span><br><span class="line">- update project      : Updates an Android project (must already have an</span><br><span class="line">                        AndroidManifest.xml).</span><br><span class="line">- create test-project : Creates a new Android project for a test package.</span><br><span class="line">- update test-project : Updates the Android project for a test package (must</span><br><span class="line">                        already have an AndroidManifest.xml).</span><br><span class="line">- create lib-project  : Creates a new Android library project.</span><br><span class="line">- update lib-project  : Updates an Android library project (must already have</span><br><span class="line">                        an AndroidManifest.xml).</span><br><span class="line">- create uitest-project: Creates a new UI test project.</span><br><span class="line">- update adb          : Updates adb to support the USB devices declared in the</span><br><span class="line">                        SDK add-ons.</span><br><span class="line">- update sdk          : Updates the SDK by suggesting new platforms to install</span><br><span class="line">                        if available.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;ANT支持&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量(android和ANT都需要)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="ant" scheme="/categories/ant/"/>
    
    
  </entry>
  
  <entry>
    <title>13 泛型</title>
    <link href="/html/java/2018/10/11/13-%E6%B3%9B%E5%9E%8B.html"/>
    <id>/html/java/2018/10/11/13-泛型.html</id>
    <published>2018-10-11T14:00:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>Java 5之后提供泛型（Generics）支持，使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。泛型特性对Java影响最大是集合框架的使用。</p><p>对于Java 5之前程序员而言，使用集合经常会面临一个很尴尬的问题：放入一个种特定类型，但是取出时候全部是Object类型，于是在具体使用时候需要将元素转换为特定类型。上述代码第①行取出的元素是Object类型，在代码第②行需要强制类型转换。强制类型转换是有风险的，如果不进行判断就臆断进行类型转换会发生ClassCastException异常。</p><p>而泛型的引入可以将这些运行时异常提前到编译期暴露出来，这增强了类型安全检查。</p><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;                         </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明保存队列元素集合items</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items;                      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法初始化是集合items</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> ArrayList&lt;T&gt;();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 参数需要入队的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queue</span><span class="params">(T item)</span> </span>&#123;                 </span><br><span class="line">        <span class="keyword">this</span>.items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回出队元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">dequeue</span><span class="params">()</span></span>&#123;                         </span><br><span class="line">        <span class="keyword">if</span> (items.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.items.remove(<span class="number">0</span>);        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>自定义泛型接口与自定义泛型类类似，定义的方式完全一样。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在方法中也可以使用泛型，即方法的参数类型或返回值类型，可以用类型参数表示。假设笔者想编写一个能够比较对象大小的方法，实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定类型参数为Number</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(T a, T b)</span> </span>&#123;                          ⑥</span><br><span class="line">    <span class="keyword">return</span> a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外，泛型的类型参数也可以限定一个边界，例如比较方法isEquals()只想用于数值对象大小的比较，实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定类型参数为Number</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isEquals</span><span class="params">(T a, T b)</span> </span>&#123;        ②</span><br><span class="line">    <span class="keyword">return</span> a.equals(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 5之后提供泛型（Generics）支持，使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。泛型特性对Java影响最大是集合框架的使用。&lt;/p&gt;
&lt;p&gt;对于Java 5之前程序员而言，使用集合经常会面临一个很尴尬的问题：放入一个种特定类型，但是取出时候全部
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>12 Java集合</title>
    <link href="/html/java/2018/10/10/12-java%E9%9B%86%E5%90%88.html"/>
    <id>/html/java/2018/10/10/12-java集合.html</id>
    <published>2018-10-10T14:20:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合框架体系概述"><a href="#集合框架体系概述" class="headerlink" title="集合框架体系概述"></a>集合框架体系概述</h2><ol><li><p>为什么出现集合类?<br>方便多个对象的操作,就对对象进行存储,集合就是存储对象最常用的一种方法.</p></li><li><p>数组和集合类同时容器, 有何不可?          </p><ul><li>数组虽然也可存储对象,但长度固定; 而集合长度可变 </li><li>集合只用于存储对象,集合长度是可变的,集合可以存储不同类型的对象.</li></ul></li></ol><p>Java 集合定义了两种基本的数据结构，一种是 <code>Collection</code>，表示一组对象的集合；另一种是<code>Map</code>，表示对象间的一系列映射或关联关系。Java 集合的基本架构如下图。</p><p><img src="http://upload-images.jianshu.io/upload_images/1662509-f4b8b26cdd6913d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集合类及其继承关系"></p><p>在这种架构中，<code>Set</code> 是一种 <code>Collection</code>，不过其中没有重复的对象； <code>List</code> 也是一种<code>Collection</code> ，其中的元素按顺序排列（不过可能有重复）。<br><code>SortedSet</code> 和 <code>SortedMap</code> 是特殊的集和映射，其中的元素按顺序排列。<br><code>Collection</code>、<code>Set</code> 、<code>List</code> 、<code>Map</code> 、<code>SortedSet</code>和 <code>SortedMap</code> 都是接口，不过 java.util 包定义了多个具体实现，例如基于数组和链表的列表，基于哈希表或二叉树的映射和集。除此之外，还有两个重要的接口， Iterator 和 Iterable ，用于遍历集合中的对象，稍后会介绍。</p><h2 id="Collection共性方法"><a href="#Collection共性方法" class="headerlink" title="Collection共性方法"></a>Collection共性方法</h2><blockquote><p>注意: 集合存储的都是对象的引用(地址)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>添加指定的元素<span class="params">(可选操作)</span>     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> 将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。 </span></span><br><span class="line"><span class="function"><span class="title">clear</span><span class="params">()</span>: 清空集合中所有元素     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> 是否包含指定元素     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> 只判断参数中的集合是否都包含在A集合内,最终A集合没有任何变化.     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> 判断是否为空     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   移除单个实例     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>  取差集    </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>  取交集     </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>:返回collection中的元素     </span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span> 这个可以理解     </span></span><br><span class="line"><span class="function">&lt;T&gt; T[]  <span class="title">toArray</span><span class="params">(T[] a)</span>  <span class="comment">//应这么写String[] y =  c.toArray(new String[collection.size()])较好</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建几个集合，供后面的代码使用</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 一个空集</span></span><br><span class="line">Collection&lt;String&gt; d = Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>);</span><br><span class="line">Collection&lt;String&gt; e = Collections.singleton(<span class="string">"three"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向集合中添加一些元素</span></span><br><span class="line"><span class="comment">// 如果集合的内容变化了，这些方法返回true</span></span><br><span class="line"><span class="comment">// 这种表现对不允许重复的Set类型很有用</span></span><br><span class="line">c.add(<span class="string">"zero"</span>);           <span class="comment">// 添加单个元素</span></span><br><span class="line">c.addAll(d);             <span class="comment">// 添加d中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制集合：多数实现都有副本构造方法</span></span><br><span class="line">Collection&lt;String&gt; copy = <span class="keyword">new</span> ArrayList&lt;String&gt;(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把元素从集合中移除。</span></span><br><span class="line"><span class="comment">// 除了clear()方法之外，如果集合的内容变化了，都返回true</span></span><br><span class="line">c.remove(<span class="string">"zero"</span>);        <span class="comment">// 移除单个元素</span></span><br><span class="line">c.removeAll(e);          <span class="comment">// 移除一组元素</span></span><br><span class="line">c.retainAll(d);          <span class="comment">// 移除不在集合d中的所有元素</span></span><br><span class="line">c.clear();               <span class="comment">// 移除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取集合的大小</span></span><br><span class="line"><span class="keyword">boolean</span> b = c.isEmpty(); <span class="comment">// c是空的，所以返回true</span></span><br><span class="line"><span class="keyword">int</span> s = c.size();        <span class="comment">// 现在c的大小是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用前面创建的副本复原集合</span></span><br><span class="line">c.addAll(copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试元素是否在集合中。测试基于equals()方法，而不是==运算符</span></span><br><span class="line">b = c.contains(<span class="string">"zero"</span>);  <span class="comment">// true</span></span><br><span class="line">b = c.containsAll(d);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多数Collection实现都有toString()方法</span></span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用集合中的元素创建一个数组。</span></span><br><span class="line"><span class="comment">// 如果迭代器能保证特定的顺序，数组就有相同的顺序</span></span><br><span class="line"><span class="comment">// 得到的数组是个副本，而不是内部数据结构的引用</span></span><br><span class="line">Object[] elements = c.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想把集合中的元素存入String[]类型的数组，必须在参数中指定这个类型</span></span><br><span class="line">String[] strings = c.toArray(<span class="keyword">new</span> String[c.size()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者传入一个类型为String[]的空数组，指定所需的类型</span></span><br><span class="line"><span class="comment">// toArray()方法会为这个数组分配空间</span></span><br><span class="line">strings = c.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>记住，上述各个方法都能用于 Set、List 或 Queue。这几个子接口可能会对集合中的元素做些限制或有顺序上的约束，但都提供了相同的基本方法。</p><blockquote><p>修改集合的方法，例如 add()、remove()、clear() 和 retainAll()，是可选的 API。不过，这个规则在很久以前就定下了，那时认为如果不提供这些方法，明智的做法是抛出 UnsupportedOperationException 异常。因此，某些实现（尤其是只读方法）可能会抛出未检异常。</p></blockquote><ul><li><code>Collection</code> (集合)和 <code>Map</code>(映射) 及其子接口都没扩展 Cloneable 或 Serializable 接口。不过，在 Java 集合框架中，实现集合和映射的所有类都实现了这两个接口。</li><li>有些集合对其可以包含的元素做了限制。例如，有的集合禁止使用 null 作为元素。EnumSet 要求其中的元素只能是特定的枚举类型。</li><li>如果尝试把禁止使用的元素添加到集合中，会抛出未检异常，例如 <code>NullPointerException</code> 或 <code>ClassCastException</code>。检查集合中是否包含禁止使用的元素，可能也会抛出这种异常，或者仅仅返回 false。</li></ul><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>List 是一组<strong>有序的对象集合</strong>。列表中的每个元素都有特定的位置，而且 List 接口定义了一些方法，用于查询或设定特定位置（或叫索引）的元素。从这个角度来看，List 对象和数组类似，不过列表的大小能按需变化，以适应其中元素的数量。和<code>Set</code>不同，列表允许出现重复的元素。</p><p>除了基于索引的 get() 和 set() 方法之外，List 接口还定义了一些方法，用于把元素添加到特定的索引，把元素从特定的索引移除，或者返回指定值在列表中首次出现或最后出现的索引。从 Collection 接口继承的 add() 和 remove() 方法，前者把元素添加到列表末尾，后者把指定值从列表中首次出现的位置移除。继承的 addAll() 方法把指定集合中的所有元素添加到列表的末尾，或者插入指定的索引。retainAll() 和 removeAll() 方法的表现与其他 Collection 对象一样，如果需要，会保留或删除多个相同的值。</p><p>List 接口没有定义操作索引范围的方法，但是定义了一个 subList() 方法。这个方法返回一个 List 对象，表示原列表指定范围内的元素。子列表会回馈父列表，只要修改了子列表，父列表立即就能察觉到变化。下述代码演示了 subList() 方法和其他操作 List 对象的基本方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建两个列表，供后面的代码使用</span></span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(args));</span><br><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引查询和设定元素</span></span><br><span class="line">String first = l.get(<span class="number">0</span>);        <span class="comment">// 列表的第一个元素</span></span><br><span class="line">String last = l.get(l.size -<span class="number">1</span>); <span class="comment">// 列表的最后一个元素</span></span><br><span class="line">l.set(<span class="number">0</span>, last);                 <span class="comment">// 把最后一个元素变成第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加和插入元素</span></span><br><span class="line"><span class="comment">// add()方法既可以把元素添加到列表末尾，也可以把元素插入指定索引</span></span><br><span class="line">l.add(first);       <span class="comment">// 把第一个词添加到列表末尾</span></span><br><span class="line">l.add(<span class="number">0</span>, first);    <span class="comment">// 再把第一个词添加到列表的开头</span></span><br><span class="line">l.addAll(words);    <span class="comment">// 把一个集合添加到列表末尾</span></span><br><span class="line">l.addAll(<span class="number">1</span>, words); <span class="comment">// 在第一个词之后插入一个集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子列表：回馈原列表</span></span><br><span class="line">List&lt;String&gt; sub = l.subList(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// 第二个和第三个元素</span></span><br><span class="line">sub.set(<span class="number">0</span>, <span class="string">"hi"</span>);                  <span class="comment">// 修改l的第二个元素</span></span><br><span class="line"><span class="comment">// 子列表可以把操作限制在原列表索引的子范围内</span></span><br><span class="line">String s = Collections.min(l.subList(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line">Collections.sort(l.subList(<span class="number">0</span>,<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 子列表的独立副本不影响父列表</span></span><br><span class="line">List&lt;String&gt; subcopy = <span class="keyword">new</span> ArrayList&lt;String&gt;(l.subList(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搜索列表</span></span><br><span class="line"><span class="keyword">int</span> p = l.indexOf(last); <span class="comment">// 最后一个词在哪个位置？</span></span><br><span class="line">p = l.lastIndexOf(last); <span class="comment">// 反向搜索</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印last在l中出现的所有索引。注意，使用了子列表</span></span><br><span class="line"><span class="keyword">int</span> n = l.size();</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个列表，只包含尚未搜索的元素</span></span><br><span class="line">    List&lt;String&gt; list = l.subList(p, n);</span><br><span class="line">    <span class="keyword">int</span> q = list.indexOf(last);</span><br><span class="line">    <span class="keyword">if</span> (q == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    System.out.printf(<span class="string">"Found '%s' at index %d%n"</span>, last, p+q);</span><br><span class="line">    p += q+<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span>(p &lt; n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从列表中删除元素</span></span><br><span class="line">l.remove(last);         <span class="comment">// 把指定元素从首次出现的位置上删除</span></span><br><span class="line">l.remove(<span class="number">0</span>);            <span class="comment">// 删除指定索引对应的元素</span></span><br><span class="line">l.subList(<span class="number">0</span>,<span class="number">2</span>).clear(); <span class="comment">// 使用subList()方法，删除一个范围内的元素</span></span><br><span class="line">l.retainAll(words);     <span class="comment">// 删除所有不在words中的元素</span></span><br><span class="line">l.removeAll(words);     <span class="comment">// 删除所有在words中的元素</span></span><br><span class="line">l.clear();              <span class="comment">// 删除所有元素</span></span><br></pre></td></tr></table></figure></p><p>重点讲讲用于查找的Iterator迭代器接口<br>Iterator it = al.iterator();<br>实际上是集合类在List和Set都包含的iterator方法,返回Iterator对象,具体实现方式是内部类.可以认为是继承了AbstractList,实现了Iterable接口.把取出方式定义成内部类,每个容器的数据结构不同,取出的动作细节也不一样.但是都用共性的判断和取出,可以将共性方法抽取.对外提供了Iterator方法.</p><h5 id="集合中的迭代器"><a href="#集合中的迭代器" class="headerlink" title="集合中的迭代器"></a>集合中的迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写法</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//老外为了节省空间,写成这样</span></span><br><span class="line"><span class="keyword">for</span>(Iterator it = al.iterator(); it.hasNext(); )&#123;</span><br><span class="line">     System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="List共性方法"><a href="#List共性方法" class="headerlink" title="List共性方法"></a>List共性方法</h5><p>(List也被成为序列, 它的对象的元素有序可重复,正因为有序,所以操作角标的方法都是该体系特有的方法)</p><ul><li>增 void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。  </li><li>删 E remove(int index)   移除列表中指定位置的元素（可选操作）。</li><li>改 E set(int index, E element)   用指定元素替换列表中指定位置的元素（可选操作）。      </li><li>查 ListIterator<e> listIterator()  返回此列表元素的列表迭代器（按适当顺序）。</e></li><li>获取 E get(int index)  返回列表中指定位置的元素。  　　　　 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于get(index)方法, list因此多了一种取出所有元素的方法. 但还是常用迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;al.size();i++)&#123;                　　</span><br><span class="line">    输出al.get(i);          　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>获取<e> subList(int fromIndex, int toIndex)  返回列表中指定的 fromIndex(包括)和 toIndex（不包括）之间的部分视图。      </e></p><h5 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h5><p>List有自己更强功能的的ListIterator是Iterator的子接口,是带下标的.</p><p>集合引用和迭代器引用在同时操作元素，通过集合获取到对应的迭代器后，在迭代中，进行集合引用的元素添加，迭代器并不知道，所以会出现ConcurrentModificationException异常情况。ListIterator列表迭代器接口具备了对元素的增、删、改、查的动作。</p><p>原 查 next() 但是 增加了previous()<br>原 删 void remove()<br>增加了特有了           　　</p><ul><li>增void add(E e)            　　</li><li>改 void set(E e)           　　</li><li>和独有的int nextIndex(), int previousIndex() 和 int nextIndex()</li></ul><h5 id="List集合的三个常见子类对象-List有序可重复-因为体系有索引"><a href="#List集合的三个常见子类对象-List有序可重复-因为体系有索引" class="headerlink" title="List集合的三个常见子类对象(List有序可重复,因为体系有索引)"></a>List集合的三个常见子类对象(List有序可重复,因为体系有索引)</h5><ul><li>ArrayList: 底层使用<strong>数组结构</strong>, 查询块,增删稍慢. 线程不同步, JDK1.2以上     </li><li>LinkedList: 底层是<strong>链表结构</strong>, 增删块,查询稍慢, 线程不同步, JDK1.2以上     </li><li>Vector: 底层使用<strong>数组结构</strong>, 查询块,增删慢. 线程同步.被ArrayList替代了. 枚举就是Vector特有的取出方式.</li></ul><p>ArrayList详解:拥有角标的方法是其特有方法<br>可变长度数组的原理 ：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。      </p><ul><li>ArrayList：是按照原数组的 <strong>50%</strong>延长构造一个初始容量为10的空列表。      </li><li>Vector：是按照原数组的 <strong>100%</strong>延长       </li></ul><p>LinkedList详解:<br>特有的add,get,remove方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1.6后新方法        </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span>                </span></span><br><span class="line"><span class="function">在此列表的开头插入指定的元素。      </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span>                </span></span><br><span class="line"><span class="function">在此列表末尾插入指定的元素。 </span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span>           </span></span><br><span class="line"><span class="function">获取但不移除此列表的头（第一个元素）。</span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取但不移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。           </span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span>           </span></span><br><span class="line"><span class="function">获取但不移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。            </span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取并移除此列表的第一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。           </span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span>                </span></span><br><span class="line"><span class="function">获取并移除此列表的最后一个元素；如果此列表为空，则返回 <span class="keyword">null</span>。 </span></span><br><span class="line"><span class="function">```   </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Vector</span><span class="params">(过时)</span>详解          </span></span><br><span class="line"><span class="function">枚举是Vector特有的取出方式<span class="title">hasMoreElements</span><span class="params">()</span>和<span class="title">nextElement</span><span class="params">()</span>方法,发现枚举和迭代器很像.其实枚举和迭代一样的.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&gt; 在List下的ArrayList和LinkedList的contains和remove方法都是使用了Object的**equals**方法. 可以自己重写equals方法判断集合内两对象是否"一致"</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">##### 随机访问列表中的元素</span></span><br><span class="line"><span class="function">我们一般期望实现 List 接口的类能高效迭代，而且所用时间和列表的大小成正比。然而，不是所有列表都能高效地随机访问任意索引上的元素。按顺序访问的列表，例如 LinkedList 类，提供了高效的插入和删除操作，但降低了随机访问性能。提供高效随机访问的类都实现了标记接口 RandomAccess，因此，如果需要确定是否能高效处理列表，可以使用 <span class="keyword">instanceof</span> 运算符测试是否实现了这个接口：</span></span><br><span class="line"><span class="function">``` java</span></span><br><span class="line"><span class="function"><span class="comment">// 随便创建一个列表，供后面的代码处理</span></span></span><br><span class="line"><span class="function">List&lt;?&gt; l </span>= ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试能否高效随机访问</span></span><br><span class="line"><span class="comment">// 如果不能，先使用副本构造方法创建一个支持高效随机访问的副本，然后再处理</span></span><br><span class="line"><span class="keyword">if</span> (!(l <span class="keyword">instanceof</span> RandomAccess)) l = <span class="keyword">new</span> ArrayList&lt;?&gt;(l);</span><br></pre></td></tr></table></figure></p><p>在 List 对象上调用 iterator() 方法会得到一个 Iterator 对象，这个对象按照元素在列表中的顺序迭代各元素。List 实现了 Iterable 接口，因此列表可以像其他集合一样使用遍历循环迭代。</p><p>下表总结了 Java 平台中五种通用的 List 实现。Vector 和 Stack 类已经过时，别再用了。<strong>CopyOnWriteArrayList</strong> 类在 java.util.concurrent 包中，只适合在多线程环境中使用。</p><p><img src="http://upload-images.jianshu.io/upload_images/1662509-a5d8c54b79194c89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现List接口的类"></p><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul><li>Set集合的方法和Collection一致,不用多讲, 但对这些方法做了限制, 是无重复对象组成的集合</li></ul><p>下表列出了实现 Set 接口的类，而且总结了各个类的内部表示方式、排序特性、对成员的限制，以及 add()、remove()、contains 等基本操作和迭代的性能。这些类的详细信息，请参见各自的文档。注意，CopyOnWriteArraySet 类在 java.util.concurrent 包中，其他类则在 java.util 包中。还要注意，java.util.BitSet 类没有实现 Set 接口，这个类过时了，用于紧凑而高效地表示布尔值组成的列表，但不是 Java 集合框架的一部分。</p><p><img src="http://upload-images.jianshu.io/upload_images/1662509-3d428eb64ebde6b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现Set接口的类"></p><h5 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet(接口)"></a>SortedSet(接口)</h5><p>SortedSet 接口提供了多个有趣的方法，这些方法都考虑到了元素是有顺序的，如下述代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSortedSet</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个SortedSet对象</span></span><br><span class="line">    SortedSet&lt;String&gt; s = <span class="keyword">new</span> TreeSet&lt;&gt;(Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代集：元素已经自动排序</span></span><br><span class="line">    <span class="keyword">for</span> (String word : s) &#123;</span><br><span class="line">        System.out.println(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特定的元素</span></span><br><span class="line">    String first = s.first(); <span class="comment">// 第一个元素</span></span><br><span class="line">    String last = s.last();   <span class="comment">// 最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除第一个元素之外的其他所有元素</span></span><br><span class="line">    SortedSet&lt;String&gt; tail = s.tailSet(first + <span class="string">'\0'</span>);</span><br><span class="line">    System.out.println(tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除最后一个元素之外的其他所有元素</span></span><br><span class="line">    SortedSet&lt;String&gt; head = s.headSet(last);</span><br><span class="line">    System.out.println(head);</span><br><span class="line"></span><br><span class="line">    SortedSet&lt;String&gt; middle = s.subSet(first+<span class="string">'\0'</span>, last);</span><br><span class="line">    System.out.println(middle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>　必须加上 \0 字符，因为 tailSet() 等方法要使用某个元素后面的元素，对字符串来说，要在后面加上 NULL 字符（对应于 ASCII 中的 0）。</p></blockquote><h5 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet(类)"></a>TreeSet(类)</h5><p>TreeSet 类使用红黑树数据结构维护集，这个集中的元素按照 Comparable 对象的自然顺序升序迭代，或者按照 Comparator 对象指定的顺序迭代。其实，TreeSet 实现的是 Set 的子接口，SortedSet 接口。</p><p>TreeSet排序               </p><ul><li>第一种方式: 需要比较的对象实现Comparable接口,覆盖int compareTo()方法,让元素自身具备比较性  </li><li>第二种方式:构造实现java.util.Comparator接口,覆盖int compare(T o1, T o2)方法,将比较器对象作为参数传递给TreeSet集合的构造函数.</li></ul><h5 id="HashSet-线程不同步"><a href="#HashSet-线程不同步" class="headerlink" title="HashSet(线程不同步)"></a>HashSet(线程不同步)</h5><ul><li>底层数据结构是哈希表,线程非同步.          </li><li>通过hasHashCode()和equals()来完成          </li><li>如果元素的HashCode相同,才会判断equals是否为true         </li><li>如果元素的HashCode不同,不会调用equals,直接是不等.   </li></ul><blockquote><p>注意,对于判断元素是否存在,以及删除等操作,依赖的方法依次是hashcode和equals方法. 在使用HashSet,一定要覆盖int hashCode()和boolean equals (Object obj)方法.</p></blockquote><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>将键映射到值的对象,一对一对往里存,而且要保证键的唯一性.</p><p>映射（map）是一系列键值对，一个键对应一个值。Map 接口定义了用于定义和查询映射的 API。Map 接口属于 Java 集合框架，但没有扩展 Collection 接口，<strong>因此 Map 只是一种集合</strong>，而<strong>不是 Collection</strong> 类型。Map 是参数化类型，有两个类型变量。类型变量 K 表示映射中键的类型，类型变量 V 表示键对应的值的类型。例如，如果有个映射，其键是 String 类型，对应的值是 Integer 类型，那么这个映射可以表示为 Map&lt;String,Integer&gt;。</p><p>Map 接口定义了几个最有用的方法：put() 方法定义映射中的一个键值对，get() 方法查询指定键对应的值，remove() 方法把指定的键及对应的值从映射中删除。一般来说，实现 Map 接口的类都要能高效执行这三个基本方法：一般应该运行在常数时间中，而且绝不能比在对数时间中运行的性能差。</p><p>Map 的重要特性之一是，可以视作集合。虽然 Map 对象不是 Collection 类型，但映射的键可以看成 Set 对象(因此<strong>不能有重复元素</strong>。)，映射的值可以看成 Collection 对象，而映射的键值对可以看成由 Map.Entry 对象组成的 Set 对象。（Map.Entry 是 Map 接口中定义的嵌套接口，表示一个键值对。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">添加               </span><br><span class="line">    put(K key, V value)               </span><br><span class="line">    putAll(Map&lt;? extends K, ? extends V&gt; m)         </span><br><span class="line">删除                 </span><br><span class="line">    clear()               </span><br><span class="line">    remove(Object key)          </span><br><span class="line">判断               </span><br><span class="line">    containsKey(Object key)               </span><br><span class="line">    containsValue(Object value)               </span><br><span class="line">    isEmpty()          </span><br><span class="line">获取               </span><br><span class="line">    get(Object key)               </span><br><span class="line">    size()               </span><br><span class="line">    values()               </span><br><span class="line">    entrySet()               </span><br><span class="line">    keySet()</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">下述示例代码展示了如何使用 get()、put() 和 remove() 等方法操作 Map 对象，还演示了把 Map 对象视作集合后的一些常见用法：</span><br><span class="line">``` java</span><br><span class="line"><span class="comment">// 新建一个空映射</span></span><br><span class="line">Map&lt;String,Integer&gt; m = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变的映射，只包含一个键值对</span></span><br><span class="line">Map&lt;String,Integer&gt; singleton = Collections.singletonMap(<span class="string">"test"</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，极少使用下述句法显式指定通用方法emptyMap()的参数类型</span></span><br><span class="line"><span class="comment">// 得到的映射不可变</span></span><br><span class="line">Map&lt;String,Integer&gt; empty = Collections.&lt;String,Integer&gt;emptyMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用put()方法填充映射，把数组中的元素映射到元素的索引上</span></span><br><span class="line">String[] words = &#123; <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"test"</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    m.put(words[i], i); <span class="comment">// 注意，int会自动装包成Integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个键只能映射一个值</span></span><br><span class="line"><span class="comment">// 不过，多个键可以映射同一个值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    m.put(words[i].toUpperCase(), i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// putAll()方法从其他映射中复制键值对</span></span><br><span class="line">m.putAll(singleton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get()方法查询映射</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m.get(words[i]) != i) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试映射中是否有指定的键和值</span></span><br><span class="line">m.containsKey(words[<span class="number">0</span>]);       <span class="comment">// true</span></span><br><span class="line">m.containsValue(words.length); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射的键、值和键值对都可以看成集合</span></span><br><span class="line">Set&lt;String&gt; keys = m.keySet();</span><br><span class="line">Collection&lt;Integer&gt; values = m.values();</span><br><span class="line">Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entries = m.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射和上述几个集合都有有用的toString()方法</span></span><br><span class="line">System.out.printf(<span class="string">"Map: %s%nKeys: %s%nValues: %s%nEntries: %s%n"</span>,</span><br><span class="line">                  m, keys, values, entries);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以迭代这些集合</span></span><br><span class="line"><span class="comment">// 多数映射都没定义迭代的顺序（不过SortedMap定义了）</span></span><br><span class="line"><span class="keyword">for</span>(String key : m.keySet()) System.out.println(key);</span><br><span class="line"><span class="keyword">for</span>(Integer value: m.values()) System.out.println(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map.Entry&lt;K,V&gt;类型表示映射中的一个键值对</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; pair : m.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 打印键值对</span></span><br><span class="line">    System.out.printf(<span class="string">"'%s' ==&gt; %d%n"</span>, pair.getKey(), pair.getValue());</span><br><span class="line">    <span class="comment">// 然后把每个Entry对象的值增加1</span></span><br><span class="line">    pair.setValue(pair.getValue() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除键值对</span></span><br><span class="line">m.put(<span class="string">"testing"</span>, <span class="keyword">null</span>);   <span class="comment">// 映射到null上可以“擦除”一个键值对</span></span><br><span class="line">m.get(<span class="string">"testing"</span>);         <span class="comment">// 返回null</span></span><br><span class="line">m.containsKey(<span class="string">"testing"</span>); <span class="comment">// 返回true：键值对仍然存在</span></span><br><span class="line">m.remove(<span class="string">"testing"</span>);      <span class="comment">// 删除键值对</span></span><br><span class="line">m.get(<span class="string">"testing"</span>);         <span class="comment">// 还是返回null</span></span><br><span class="line">m.containsKey(<span class="string">"testing"</span>); <span class="comment">// 这次返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以把映射视作集合，然后再删除</span></span><br><span class="line"><span class="comment">// 不过，向集合中添加键值对时不能这么做</span></span><br><span class="line">m.keySet().remove(words[<span class="number">0</span>]); <span class="comment">// 等同于m.remove(words[0]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个值为2的键值对——这种方式一般效率不高，用途有限</span></span><br><span class="line">m.values().remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 删除所有值为4的键值对</span></span><br><span class="line">m.values().removeAll(Collections.singleton(<span class="number">4</span>));</span><br><span class="line"><span class="comment">// 只保留值为2和3的键值对</span></span><br><span class="line">m.values().retainAll(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以通过迭代器删除</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iter = m.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String,Integer&gt; e = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (e.getValue() == <span class="number">2</span>) iter.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出两个映射中都有的值</span></span><br><span class="line"><span class="comment">// 一般来说，addAll()和retainAll()配合keySet()和values()使用，可以获取交集和并集</span></span><br><span class="line">Set&lt;Integer&gt; v = <span class="keyword">new</span> HashSet&lt;Integer&gt;(m.values());</span><br><span class="line">v.retainAll(singleton.values());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法</span></span><br><span class="line">m.clear();                <span class="comment">// 删除所有键值对</span></span><br><span class="line">m.size();                 <span class="comment">// 返回键值对的数量：目前为0</span></span><br><span class="line">m.isEmpty();              <span class="comment">// 返回true</span></span><br><span class="line">m.equals(empty);          <span class="comment">// true：实现Map接口的类覆盖了equals()方法</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1662509-b110af462059037c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现Map接口的类"></p><p>java.util.concurrent 包中的 ConcurrentHashMap 和 ConcurrentSkipListMap 两个类实现了同一个包中的 ConcurrentMap 接口。ConcurrentMap 接口扩展 Map 接口，而且定义了一些对多线程编程很重要的原子操作方法。例如，putIfAbsent() 方法，它的作用和 put() 方法类似，不过，仅当指定的键没有映射到其他值上时，才会把键值对添加到映射中。</p><p>TreeMap 类实现 SortedMap 接口。这个接口扩展 Map 接口，添加了一些方法，利用这种映射的有序特性。SortedMap 接口和 SortedSet 接口非常相似。firstKey() 和 lastKey() 方法分别返回 keySet() 所得集的第一个和最后一个键。而 headMap()、tailMap() 和 subMap() 方法都返回一个新映射，由原映射特定范围内的键值对组成。</p><h5 id="Map集合的共性方法注意"><a href="#Map集合的共性方法注意" class="headerlink" title="Map集合的共性方法注意"></a>Map集合的共性方法注意</h5><ol><li>添加元素,如果出现相同的键,那么后添加的值会覆盖原有键对应的值, put方法会会返回被覆盖的值     </li><li>可通过get方法的返回值来判断一个键是否存在,通过返回null判断.     </li><li>获取map集合中所有的值</li></ol><p>两个重要的获取方法:  keySet()和entrySet()     </p><ol><li>通过keyset()获取key的Set集合,然后Iterator获取key,最终get(Object key) 获取.     </li><li>通过entryset()获取关系,然后Iterator获取键值对,最终Map.Entry的getKey和getValue方法获取. (其实Map.Entry也是一个接口,它是Map接口中的一个内部接口)</li></ol><blockquote><p>Map和Set很像,其实Set底层就是使用了Map集合. </p></blockquote><p>练习TreeMap</p><ul><li>key: 学生Student, value: 地址addr     </li><li>学生属性:姓名和年龄,注意姓名和年龄相同视为同一个学生,需保证学生的唯一性<br><img src="http://upload-images.jianshu.io/upload_images/1662509-92c52521c7ccf138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><h3 id="Queue接口和BlockingQueue接口"><a href="#Queue接口和BlockingQueue接口" class="headerlink" title="Queue接口和BlockingQueue接口"></a>Queue接口和BlockingQueue接口</h3><p>队列（queue）是一组有序的元素，提取元素时按顺序从队头读取。队列一般按照插入元素的顺序实现，因此分成两类：先进先出（first-in, first-out，FIFO）队列和后进先出（last-in, first-out，LIFO）队列。</p><blockquote><p>LIFO 队列也叫栈（stack），Java 提供了 Stack 类，但强烈不建议使用——应该使用实现 Deque 接口的类。</p></blockquote><p>队列也可以使用其他顺序：优先队列（priority queue）根据外部 Comparator 对象或 Comparable 类型元素的自然顺序排序元素。与 Set 不同的是，Queue 的实现往往允许出现重复的元素。而与 List 不同的是，Queue 接口没有定义处理任意索引位元素的方法，只有队列的头一个元素能访问。Queue 的所有实现都要具有一个固定的容量：队列已满时，不能再添加元素。类似地，队列为空时，不能再删除元素。很多基于队列的算法都会用到满和空这两个状态，所以 Queue 接口定义的方法通过返回值表明这两个状态，而不会抛出异常。具体而言，peek() 和 poll() 方法返回 null 表示队列为空。因此，多数 Queue 接口的实现不允许用 null 作元素。</p><p>阻塞式队列（blocking queue）是一种定义了阻塞式 put() 和 take() 方法的队列。put() 方法的作用是把元素添加到队列中，如果需要，这个方法会一直等待，直到队列中有存储元素的空间为止。而 take() 方法的作用是从队头移除元素，如果需要，这个方法会一直等待，直到队列中有元素可供移除为止。阻塞式队列是很多多线程算法的重要组成部分，因此 BlockingQueue 接口（扩展 Queue 接口）在 java.util.concurrent 包中定义。</p><p>队列不像集、列表和映射那么常用，只在特定的多线程编程风格中会用到。这里，我们不举实例，而是试着厘清一些令人困惑的队列插入和移除操作。</p><p><strong>1. 把元素添加到队列中</strong><br>add()<strong>方法</strong><br>这个方法在 Collection 接口中定义，只是使用常规的方式添加元素。对有界的队列来说，如果队列已满，这个方法可能会抛出异常。</p><p>offer()<strong>方法</strong><br>这个方法在 Queue 接口中定义，但是由于有界的队列已满而无法添加元素时，这个方法返回 false，而不会抛出异常。<br>BlockingQueue 接口定义了一个超时版 offer() 方法，如果队列已满，会在指定的时间内等待空间。这个版本和基本版一样，成功插入元素时返回 true，否则返回 false。</p><p>put()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，会阻塞操作：如果因为队列已满而无法插入元素，put() 方法会一直等待，直到其他线程从队列中移除元素，有空间插入新元素为止。</p><p><strong>2. 把元素从队列中移除</strong><br>remove()<strong>方法</strong><br>Collection 接口中定义了 remove() 方法，把指定的元素从队列中移除。除此之外，Queue接口还定义了一个没有参数的 remove() 方法，移除并返回队头的元素。如果队列为空，这个方法会抛出 NoSuchElementException 异常。</p><p>poll()<strong>方法</strong><br>这个方法在 Queue 接口中定义，作用和 remove() 方法类似，移除并返回队头的元素，不过，如果队列为空，这个方法会返回 null，而不抛出异常。<br>BlockingQueue 接口定义了一个超时版 poll() 方法，在指定的时间内等待元素添加到空队列中。</p><p>take()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，用于删除并返回队头的元素。如果队列为空，这个方法会等待，直到其他线程把元素添加到队列中为止。</p><p>drainTo()<strong>方法</strong><br>这个方法在 BlockingQueue 接口中定义，作用是把队列中的所有元素都移除，然后把这些元素添加到指定的 Collection 对象中。这个方法不会阻塞操作，等待有元素添加到队列中。这个方法有个变体，接受一个参数，指定最多移除多少个元素。</p><p><strong>3. 查询</strong><br>就队列而言，“查询”的意思是访问队头的元素，但不将其从队列中移除。<br>element()<strong>方法</strong><br>这个方法在 Queue 接口中定义，其作用是返回队头的元素，但不将其从队列中移除。如果队列为空，这个方法抛出 NoSuchElementException 异常。</p><p>peek()<strong>方法</strong><br>这个方法在 Queue 接口中定义，作用和 element() 方法类似，但队列为空时，返回 null。</p><blockquote><p>使用队列时，最好选定一种处理失败的方式。例如，如果想在操作成功之前一直阻塞，应该选择 put() 和 take() 方法；如果想检查方法的返回值，判断操作是否成功，应该选择 offer() 和 poll() 方法。</p></blockquote><p>LinkedList 类也实现了 Queue 接口，提供的是无界 FIFO 顺序，插入和移除操作需要常数时间。LinkedList 对象可以使用 null 作元素，不过，当列表用作队列时不建议使用 null。</p><p>java.util 包中还有另外两个 Queue 接口的实现。一个是 PriorityQueue<br> 类，这种队列根据Comparator 对象排序元素，或者根据 Comparable<br> 类型元素的 compareTo() 方法排序元素。PriorityQueue 对象的队头始终是根据指定排序方式得到的最小值。另外一个是 ArrayDeque类，实现的是双端队列，一般在需要用到栈的情况下使用。</p><p>java.util.concurrent 包中也包含一些 BlockingQueue 接口的实现，目的是在多线程编程环境中使用。有些实现很高级，甚至无需使用同步方法。</p><h3 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h3><p>java.util.Collections 类定义了一些静态实用方法，用于处理集合。其中有一类方法很重要，是集合的包装方法：这些方法包装指定的集合，返回特殊的集合。包装集合的目的是把集合本身没有提供的功能绑定到集合上。包装集合能提供的功能有：线程安全性、写保护和运行时类型检查。包装集合都以原来的集合为后盾，因此，在包装集合上调用的方法其实会分派给原集合的等效方法完成。这意味着，通过包装集合修改集合后，改动也会体现在原集合身上；反之亦然。</p><p>第一种包装方法为包装的集合提供线程安全性。java.util 包中的集合实现，除了过时的 Vector 和 Hashtable 类之外，都没有 synchronized 方法，不能禁止多个线程并发访问。如果需要使用线程安全的集合，而且不介意同步带来的额外开销，可以像下面这样创建集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list =</span><br><span class="line">    Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">Set&lt;Integer&gt; set =</span><br><span class="line">    Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">Map&lt;String,Integer&gt; map =</span><br><span class="line">    Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String,Integer&gt;());</span><br></pre></td></tr></table></figure></p><p>第二种包装方法创建的集合对象不能修改底层集合，得到的集合是只读的，只要试图修改集合的内容，就会抛出 UnsupportedOperationException 异常。如果要把集合传入方法，但不允许修改集合，也不允许使用任何方式改变集合的内容，就可以使用这种包装集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;Integer&gt; readonly = Collections.unmodifiableList(primes);</span><br><span class="line"><span class="comment">// 可以修改primes列表</span></span><br><span class="line">primes.addAll(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>));</span><br><span class="line"><span class="comment">// 但不能修改只读的包装集合</span></span><br><span class="line">readonly.add(<span class="number">23</span>); <span class="comment">// 抛出UnsupportedOperationException异常</span></span><br></pre></td></tr></table></figure></p><p>java.util.Collections 类还定义了用来操作集合的方法。其中最值得关注的是排序和搜索集合元素的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br><span class="line"><span class="comment">// 必须先排序列表中的元素</span></span><br><span class="line"><span class="keyword">int</span> pos = Collections.binarySearch(list, <span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p><p>Collections 类中还有些方法值得关注：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把list2中的元素复制到list1中，覆盖list1</span></span><br><span class="line">Collections.copy(list1, list2);</span><br><span class="line"><span class="comment">// 使用对象o填充list</span></span><br><span class="line">Collections.fill(list, o);</span><br><span class="line"><span class="comment">// 找出集合c中最大的元素</span></span><br><span class="line">Collections.max(c);</span><br><span class="line"><span class="comment">// 找出集合c中最小的元素</span></span><br><span class="line">Collections.min(c);</span><br><span class="line"></span><br><span class="line">Collections.reverse(list); <span class="comment">// 反转列表</span></span><br><span class="line">Collections.shuffle(list); <span class="comment">// 打乱列表</span></span><br></pre></td></tr></table></figure></p><p>你最好全面熟悉 Collections 和 Arrays 类中的实用方法，这样遇到常见任务时就不用自己动手实现了。</p><p><strong>特殊的集合</strong><br>除了包装方法之外，java.util.Collections 类还定义了其他实用方法，一些用于创建只包含一个元素的不可变集合实例，一些用于创建空集合。singleton()、singletonList() 和 singletonMap() 方法分别返回不可变的 Set、List 和 Map 对象，而且只包含一个指定的对象或键值对。如果要把单个对象当成集合传入方法，可以使用这些方法。</p><p>Collections 类还定义了一些返回空集合的方法。如果你编写的方法要返回一个集合，遇到没有返回值的情况时，一般最好返回空集合，而不要返回 null 等特殊的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; si = Collections.emptySet();</span><br><span class="line">List&lt;String&gt; ss = Collections.emptyList();</span><br><span class="line">Map&lt;String,Integer&gt; m = Collections.emptyMap();</span><br></pre></td></tr></table></figure></p><p>最后还有个 nCopies() 方法。这个方法返回一个不可变的 List 对象，包含指定数量个指定对象的副本：<br><code>List&lt;Integer&gt; tenzeros = Collections.nCopies(10, 0);</code></p><p><strong>数组和辅助方法</strong><br>由对象组成的数组和集合的作用类似，而且二者之间可以相互转换：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String[] a =&#123; <span class="string">"this"</span>, <span class="string">"is"</span>, <span class="string">"a"</span>, <span class="string">"test"</span> &#125;; <span class="comment">// 一个数组</span></span><br><span class="line"><span class="comment">// 把数组当成大小不可变的列表</span></span><br><span class="line">List&lt;String&gt; l = Arrays.asList(a);</span><br><span class="line"><span class="comment">// 创建一个大小可变的副本</span></span><br><span class="line">List&lt;String&gt; m = <span class="keyword">new</span> ArrayList&lt;String&gt;(l);</span><br><span class="line"></span><br><span class="line"><span class="comment">// asList()是个变长参数方法，所以也可以这么做：</span></span><br><span class="line">Set&lt;Character&gt; abc = <span class="keyword">new</span> HashSet&lt;Character&gt;(Arrays.asList(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>));</span><br><span class="line"><span class="comment">// Collection接口定义了toArray()方法。不传入参数时，这个方法创建</span></span><br><span class="line"><span class="comment">// Object[]类型的数组，把集合中的元素复制到数组中，然后返回这个数组</span></span><br><span class="line"><span class="comment">// 把set中的元素存入数组</span></span><br><span class="line">Object[] members = set.toArray();</span><br><span class="line"><span class="comment">// 把list中的元素存入数组</span></span><br><span class="line">Object[] items = list.toArray();</span><br><span class="line"><span class="comment">// 把map的键存入数组</span></span><br><span class="line">Object[] keys = map.keySet().toArray();</span><br><span class="line"><span class="comment">// 把map的值存入数组</span></span><br><span class="line">Object[] values = map.values().toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想返回Object[]类型的值，可以把一个所需类型的数组传入toArray()方法</span></span><br><span class="line"><span class="comment">// 如果传入的数组不够大，会再创建一个相同类型的数组</span></span><br><span class="line"><span class="comment">// 如果传入的数组太大，复制集合元素后剩余的位置使用null填充</span></span><br><span class="line">String[] c = l.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>除此之外，还有一些有用的辅助方法，用于处理 Java 数组。为了完整性，这里也会介绍。</p><p>java.lang.System 类定义了一个 arraycopy() 方法，作用是把一个数组中的指定元素复制到另一个数组的指定位置。这两个数组的类型必须相同，甚至可以是同一个数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] text = <span class="string">"Now is the time"</span>.toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 从text的第4个元素开始，复制10个字符到copy中</span></span><br><span class="line"><span class="comment">// 这10个字符的位置从copy[0]开始</span></span><br><span class="line">System.arraycopy(text, <span class="number">4</span>, copy, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一些元素向后移，留出位置插入其他元素</span></span><br><span class="line">System.arraycopy(copy, <span class="number">3</span>, copy, <span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></p><p>Arrays 类还定义了一些有用的静态方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intarray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">3</span> &#125;; <span class="comment">// 由整数组成的数组</span></span><br><span class="line">Arrays.sort(intarray);                       <span class="comment">// 原地排序数组</span></span><br><span class="line"><span class="comment">// 在索引2找到值7</span></span><br><span class="line"><span class="keyword">int</span> pos = Arrays.binarySearch(intarray, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 未找到：返回负数</span></span><br><span class="line">pos = Arrays.binarySearch(intarray, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由对象组成的数组也能排序和搜索</span></span><br><span class="line">String[] strarray = <span class="keyword">new</span> String[] &#123; <span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span> &#125;;</span><br><span class="line">Arrays.sort(strarray);  <span class="comment">// 排序的结果：&#123; "is", "now", "the", "time" &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.equals()方法比较两个数组中的所有元素</span></span><br><span class="line">String[] clone = (String[]) strarray.clone();</span><br><span class="line"><span class="keyword">boolean</span> b1 = Arrays.equals(strarray, clone); <span class="comment">// 是的，两个数组相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.fill()方法用于初始化数组的元素</span></span><br><span class="line"><span class="comment">// 一个空数组，所有元素都是0</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 把元素都设为-1</span></span><br><span class="line">Arrays.fill(data, (<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 把第5-9个元素设为-2</span></span><br><span class="line">Arrays.fill(data, <span class="number">5</span>, <span class="number">10</span>, (<span class="keyword">byte</span>) -<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>在 Java 中，数组可以视作对象，也可以按照对象的方法处理。假如有个对象 o，可以使用类似下面的代码判断这个对象是否为数组。如果是，则判断是什么类型的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class type = o.getClass();</span><br><span class="line"><span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">  Class elementType = type.getComponentType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在Java集合框架中使用lambda表达式"><a href="#在Java集合框架中使用lambda表达式" class="headerlink" title="在Java集合框架中使用lambda表达式"></a>在Java集合框架中使用lambda表达式</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></li><li><a href="http://www.ituring.com.cn/book/1554" target="_blank" rel="noopener">Java技术手册: 第6版</a></li><li>第 15 章　对象容器——集合-图灵社区<br><a href="http://www.ituring.com.cn/book/tupubarticle/17746" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/17746</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集合框架体系概述&quot;&gt;&lt;a href=&quot;#集合框架体系概述&quot; class=&quot;headerlink&quot; title=&quot;集合框架体系概述&quot;&gt;&lt;/a&gt;集合框架体系概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么出现集合类?&lt;br&gt;方便多个对象的操作,就对对象进行存储,集合就是存
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>11 Java异常</title>
    <link href="/html/java/2018/10/09/11-java%E5%BC%82%E5%B8%B8.html"/>
    <id>/html/java/2018/10/09/11-java异常.html</id>
    <published>2018-10-09T04:30:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异常指的是程序运行时出现的不正常情况</p></blockquote><p>程序运行过程中难免会发生异常，发生异常并不可怕，程序员应该考虑到有可能发生这些异常，编程时应该捕获并进行处理异常，不能让程序发生终止，这就是健壮的程序。</p><h2 id="异常的层次"><a href="#异常的层次" class="headerlink" title="异常的层次"></a>异常的层次</h2><p>Java的异常类是处理运行时的特殊类,每一种异常对应一种特定的运行错误.所有Java异常类都是系统类库中Exception类的子类<br><img src="https://upload-images.jianshu.io/upload_images/1662509-0c6dd4e9db1d694e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常类继承层次图"></p><h2 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h2><p>所有的异常类都直接或间接地继承于java.lang.Throwable类，在Throwable类有几个非常重要的方法：</p><ul><li>String getMessage()：获得发生异常的详细消息。</li><li>void printStackTrace()：打印异常堆栈跟踪信息。<br><code>printStackTrace(PrintStream s)</code>  通常用该方法将异常内容保存在日志文件中，以便查阅。</li><li>String toString()：获得获取异常类名和异常信息的描述。　　</li></ul><h2 id="Error和Exception"><a href="#Error和Exception" class="headerlink" title="Error和Exception"></a>Error和Exception</h2><p>Throwable有两个直接子类：Error和Exception。</p><ol><li><p>Error<br>Error是程序无法恢复的严重错误，程序员根本无能为力，程序中不能对其编程处理， 对Error一般不编写针对性的代码对其进行处理   只能让程序终止。例如：JVM内部错误、内存溢出和资源耗尽等严重情况。</p></li><li><p>Exception<br>Exception是程序可以恢复的异常，它是程序员所能掌控的。例如：除零异常、空指针访问、网络连接中断和读取不存在的文件等。本章所讨论的异常处理就是对Exception及其子类的异常处理。</p></li></ol><h2 id="受检查异常和运行时异常"><a href="#受检查异常和运行时异常" class="headerlink" title="受检查异常和运行时异常"></a>受检查异常和运行时异常</h2><p>Java 的异常处理机制会区分两种不同的异常类型：已检异常checked和未检异常unchecked(运行时异常)。</p><h3 id="已检异常"><a href="#已检异常" class="headerlink" title="已检异常"></a>已检异常</h3><p>在明确的特定情况下抛出，经常是应用<strong>能部分或完全恢复的情况</strong>。例如，某段代码要在多个可能的目录中寻找配置文件。如果试图打开的文件不在某个目录中，就会抛出 FileNotFoundException 异常。在这个例子中，我们想捕获这个异常，然后在文件可能出现的下一个位置继续尝试。也就是说，虽然文件不存在是异常状况，但可以从中恢复，这是意料之中的失败。</p><h3 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h3><p>在Java 环境中有些失败是无法预料的，这些失败可能是由运行时条件或滥用库代码导致的。例如把无效的 null 传给使用对象或数组的方法，会抛出 NullPointerException 异常。基本上任何方法在任何时候都可能抛出未检异常。这是 Java 环境中的墨菲定律：“会出错的事总会出错。”从未检异常中恢复，虽说不是不可能，但往往很难，因为完全不可预知。运行时异常往往是程序员所犯错误导致的，<strong>健壮的程序不应该发生运行时异常</strong>。</p><p>若想区分已检异常和未检异常，记住两点：异常是 Throwable 对象，而且异常主要分为两类，通过 Error 和 Exception 子类标识。只要异常对象是 Error 类，就是未检异常。Exception 类还有一个子类 RuntimeException ， RuntimeException 类的所有子类都属于未检异常。除此之外，都是已检异常。</p><blockquote><p>提示　对于运行时异常通常不采用抛出或捕获处理方式，而是<strong>应该提前预判</strong>，防止这种发生异常，做到未雨绸缪。例如在进行除法运算之前应该判断除数是非零的，修改代码进行提前预判这样处理要比通过try-catch捕获异常要友好的多。</p></blockquote><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p>Exception类有若干子类,每个子类代表一种特定的运行错误,这些子类有的是系统事先定义好并包含在Java类库中的,成为系统定义的运行异常.</p><ul><li>ClassNotFoundException 未找到要装载的类</li><li>ArrayIndexOutOfBoundsException 数组越界访问</li><li>FileNotFoundException 文件找不到, checked异常</li><li>IOException 输入, 输出错误, checked异常</li><li>NullPointerException 空指针异常, unchecked异常</li><li>ArithmeticException 算术运算错误</li><li>InterruptedException 中断异常, 线程在进行暂停处理时(如睡眠)被调度打断将引发该一场     </li></ul><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><ul><li>对待受检查异常。如果当前方法有能力解决，则捕获异常进行处理；没有能力解决，则抛出给上层调用方法处理。</li><li>涉及了五个关键字<code>try catch finally throw throws</code></li><li><p>try…catch..finally 或者 try-with-resources<strong>(Java7增加)</strong>语句结构进行捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;语句块;&#125; </span><br><span class="line"><span class="keyword">catch</span> (异常类名   参变量名) &#123;语句块;&#125;   </span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">  &#123;语句块;&#125; <span class="comment">//定义一定执行的代码:通常用于关闭资源</span></span><br></pre></td></tr></table></figure></li><li><p>try必须带有 ‘catch’, ‘finally’ 或资源声明才可以使用</p></li><li>一个try可以引导多个catch块。但是不要定义多余的catch块，多个catch块的异常出现继承关系，父类异常catch块放在最后面。</li><li>异常发生后，try块中的剩余语句将不再执行。 </li><li>catch块中的代码要执行的条件是，首先在try块中发生了异常，其次异常的类型与catch要捕捉的一致。 建议声明更为具体的异常，这样处理的可以更具体。当捕获的多个异常类之间存在父子关系时，捕获异常顺序与catch代码块的顺序有关。一般先捕获子类，后捕获父类，否则子类捕获不到。</li><li>可以无finally部分，但如果存在，则无论异常发生否，finally部分的语句均要执行。即便是try或catch块中含有退出方法的语句return，也不能阻止finally代码块的执行; 除非执行System.exit(0)等导致程序停止运行的语句。  </li></ul><blockquote><p>try-catch不仅可以嵌套在try代码块中，还可以嵌套在catch代码块或finally代码块，finally代码块后面会详细介绍。try-catch嵌套会使程序流程变的复杂，<strong>如果能用多catch捕获的异常，尽量不要使用try-catch嵌套</strong>。特别对于初学者不要简单地使用Eclipse的语法提示不加区分地添加try-catch嵌套，要梳理好程序的流程再考虑try-catch嵌套的必要性。</p></blockquote><p>Java 7推出了多重捕获（multi-catch）技术, 可以把这些异常合并处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ParseException e) &#123;</span><br><span class="line">    <span class="comment">//调用方法methodA处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>有时在try-catch语句中会占用一些非Java资源，如：打开文件、网络连接、打开数据库连接和使用数据结果集等，这些资源并非Java资源，不能通过JVM的垃圾收集器回收，需要程序员释放。为了确保这些资源能够被释放可以使用finally代码块或Java 7之后提供自动资源管理（Automatic Resource Management）技术。</p><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>try-catch语句后面还可以跟有一个finally代码块，try-catch-finally语句语法如下</p><blockquote><p>注意　为了代码简洁等目的，可能有的人会将finally代码中的多个嵌套的try-catch语句合并。每一个close()方法对应关闭一个资源，如果某一个close()方法关闭时发生了异常，那么后面的也不会关闭，因此这种代码是有缺陷的。</p></blockquote><h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>使用finally代码块释放资源会导致程序代码大量增加，一个finally代码块往往比正常执行的程序还要多。在Java 7之后提供自动资源管理（Automatic Resource Management）技术，可以替代finally代码块，优化代码结构，提高程序可读性。</p><p>自动资源管理是在try语句上的扩展，语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明或初始化资源语句) &#123;</span><br><span class="line">    <span class="comment">//可能会生成异常语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e1)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e2)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable eN)&#123;</span><br><span class="line">    <span class="comment">//处理异常eN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在try语句后面添加一对小括号“()”，其中是声明或初始化资源语句，可以有多条语句语句之间用分号“;”分隔。</p><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">… …</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = readDate();</span><br><span class="line">        System.out.println(<span class="string">"读取的日期  = "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">readDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动资源管理</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream readfile = <span class="keyword">new</span> FileInputStream(<span class="string">"readme.txt"</span>);     </span><br><span class="line">                InputStreamReader ir = <span class="keyword">new</span> InputStreamReader(readfile);        </span><br><span class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(ir)) &#123;                  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            Date date = df.parse(str);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理IOException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理ParseException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意　所有可以自动管理的资源需要实现AutoCloseable接口，上述代码中三个输入流FileInputStream、InputStreamReader和BufferedReader从Java 7之后实现AutoCloseable接口，具体哪些资源实现AutoCloseable接口需要查询API文档。</p></blockquote><h2 id="throws与声明方法抛出异常"><a href="#throws与声明方法抛出异常" class="headerlink" title="throws与声明方法抛出异常"></a>throws与声明方法抛出异常</h2><p>在一个方法中如果能够处理异常，则需要捕获并处理。但是本方法没有能力处理该异常，捕获它没有任何意义，则需要在方法后面声明抛出该异常，通知上层调用者该方法有可以发生异常。</p><blockquote><p>注意　如果声明抛出的多个异常类之间有父子关系，可以只声明抛出父类。但如果没有父子关系情况下，最好明确声明抛出每一个异常，因为上层调用者会根据这些异常信息进行相应的处理。假如一个方法中有可能抛出IOException和ParseException两个异常，那么声明抛出IOException和ParseException呢？还是只声明抛出Exception呢？因为Exception是IOException和ParseException的父类，只声明抛出Exception从语法是允许的，但是声明抛出IOException和ParseException更好一些。</p></blockquote><ul><li>使用<code>throw</code>抛出异常. 异常的本质是对象,因为<code>throw</code>关键词后跟的是<code>new</code>运算符来创建的一个异常对象.</li><li>使用<code>throws</code>关键字抛出一个或多个异常</li></ul><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>有些公司为了提高代码的可重用性，自己开发了一些Java类库或框架，其中少不了自己编写了一些异常类。实现自定义异常类需要继承Exception类或其子类，如果自定义运行时异常类需继承RuntimeException类或其子类。</p><p>自定义异常就很简单，主要是提供两个构造方法就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="throw与显式抛出异常"><a href="#throw与显式抛出异常" class="headerlink" title="throw与显式抛出异常"></a>throw与显式抛出异常</h2><p>通过throw语句显式抛出异常, 显式抛出异常目的有很多，例如不想某些异常传给上层调用者，可以捕获之后重新显式抛出另外一种异常给调用者。</p><blockquote><p>注意　throw显式抛出的异常与系统生成并抛出的异常，在处理方式上没有区别，就是两种方法：要么捕获自己处理，要么抛出给上层调用者。在本例中是声明抛出，所以在readDate()方法后面要声明抛出MyException异常。</p></blockquote><h2 id="设计良好异常机制"><a href="#设计良好异常机制" class="headerlink" title="设计良好异常机制"></a>设计良好异常机制</h2><ul><li>考虑要在异常中存储什么额外状态——记住，异常也是对象；</li><li>Exception 类有四个公开的构造方法，一般情况下，自定义异常类时这四个构造方法都要实现，可用于初始化额外的状态，或者定制异常消息；</li><li>不要在你的 API 中自定义很多细致的异常类——Java I/O 和反射 API 都因为这么做了而受人诟病，所以别让使用这些包时的情况变得更糟；</li><li>别在一个异常类型中描述太多状况——例如，实现 JavaScript 的 Nashorn 引擎（Java 8新功能）一开始有超多粗制滥造的异常，不过在发布之前修正了。</li></ul><h3 id="异常在子类覆盖中的体现"><a href="#异常在子类覆盖中的体现" class="headerlink" title="异常在子类覆盖中的体现:"></a>异常在子类覆盖中的体现:</h3><ol><li>子类覆盖父类时, 如果父类的方法抛出的异常,那么子类只能抛出父类异常或该异常的子类.          </li><li>如果父类方法抛出多个异常, 那么子类在覆盖方法时,只能抛出父类异常的子集.          </li><li>如果父类或借口的方法中没有异常抛出, 那么子类在覆盖方法时,也不可能抛出异常.如果子类方法发生异常,就必须进行try处理,绝对不能抛.</li></ol><h3 id="避免使用两种处理异常的反模式："><a href="#避免使用两种处理异常的反模式：" class="headerlink" title="避免使用两种处理异常的反模式："></a>避免使用两种处理异常的反模式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要捕获异常而不处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要捕获，记录日志后再重新抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SpecificException e)&#123;</span><br><span class="line">    log(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个反模式直接忽略近乎一定需要处理的异常状况（甚至没有在日志中记录）。这么做会增大系统其他地方出现问题的可能性——出现问题的地方可能会离原来的位置很远。</p><p>第二个反模式只会增加干扰——虽然记录了错误消息，但没真正处理发生的问题——在系统高层的某部分代码中还是要处理这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>第 14 章　异常处理-图灵社区<br><a href="http://www.ituring.com.cn/book/tupubarticle/17745" target="_blank" rel="noopener">http://www.ituring.com.cn/book/tupubarticle/17745</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;异常指的是程序运行时出现的不正常情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行过程中难免会发生异常，发生异常并不可怕，程序员应该考虑到有可能发生这些异常，编程时应该捕获并进行处理异常，不能让程序发生终止，这就是健壮的程序。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>10 嵌套类</title>
    <link href="/html/java/2018/10/08/10-%E5%B5%8C%E5%A5%97%E7%B1%BB.html"/>
    <id>/html/java/2018/10/08/10-嵌套类.html</id>
    <published>2018-10-08T04:30:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>目前，书中见到的类、接口和枚举类型都定义为顶层类型。也就是说，都是包的直接成员，独立于其他类型。不过，类型还可以嵌套在其他类型中定义。这种类型是嵌套类型（nested type），一般称为“内部类”，是 Java 语言的一个强大功能。</p><p>嵌套类型有两个独立的目的，但都和封装有关。</p><ul><li>如果某个类型需要特别深入地访问另一个类型的内部实现，可以嵌套定义这个类型。作为成员类型的嵌套类型，其访问方式与访问成员变量和方法的方式一样，而且能打破封装的规则。</li><li>某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。这个类型应该密封在一个小范围内，因为它其实是实现细节的一部分，应该封装在一个系统的其他部分无法接触到的地方。</li></ul><p>嵌套类型也可以理解为通过某种方式和其他类型绑定在一起的类型，不作为完全独立的实体真实存在。类型能通过<strong>四种</strong>不同的方式嵌套在其他类型中。</p><blockquote><p>提示　内部类编译成功后生成的字节码文件是“外部类$内部类.class”。</p></blockquote><ul><li><p><strong>静态成员类型</strong><br>静态成员类型是定义为其他类型静态成员的类型。<strong>嵌套的接口、枚举和注解</strong>始终都是静态成员类型（就算不使用 static 关键字也是）。</p></li><li><p><strong>非静态成员类</strong><br>“非静态成员类型”就是没使用 <code>static</code> 声明的成员类型。只有类才能作为非静态成员类型。</p></li><li><p><strong>局部类</strong><br>局部类是在 Java 代码块中定义的类，只在这个块中可见。接口、枚举和注解不能定义为局部类型。</p></li><li><p><strong>匿名局部(内部)类</strong><br>匿名类也是一种<strong>局部类</strong>，但对 Java 语言来说没有有意义的名称。因此没有名字。接口、枚举和注解不能定义为匿名类型。</p></li></ul><p>“嵌套类型”这个术语虽然正确且准确，但开发者并没有普遍使用，大多数 Java 程序员使用的是一个意义模糊的术语——“内部类”。根据语境的不同，这个术语可以指代非静态成员类、局部类或匿名类，但不能指代静态成员类型，因此使用“内部类”这个术语时无法区分指代的是哪种嵌套类型。</p><p>虽然表示各种嵌套类型的术语并不总是那么明确，但幸运的是，从语境中一般都能确定应该使用哪种句法。</p><p>下面详细介绍这四种嵌套类型。每种类型都用单独的一节介绍其特性，使用时的限制，以及专用的 Java 句法。</p><p>局部类在一个 Java 代码块中声明，不是类的成员。只有类才能局部定义，接口、枚举类型和注解类型都必须是顶层类型或静态成员类型。局部类往往在方法中定义，但也可以在类的静态初始化程序或实例初始化程序中定义。</p><p>因为所有 Java 代码块都在类中，所以局部类都嵌套在外层类中。因此，局部类和成员类有很多共同的特性。局部类往往更适合看成完全不同的嵌套类型。</p><ol><li>局部类的特性<br>局部类有如下两个有趣的特性：<br>和成员类一样，局部类和外层实例关联，而且<strong>能访问外层类的任何成员，包括私有成员</strong>；<br>除了能访问外层类定义的字段之外，局部类还能访问局部方法的作用域中声明为 final 的任何局部变量、方法参数和异常参数。</li><li>局部类的限制<br>局部类有如下限制。</li></ol><ul><li>局部类的名称只存在于定义它的块中，在块的外部不能使用。（但是要注意，在类的作用域中创建的局部类实例，在这个作用域之外仍能使用。稍后本节会详细说明这种情况。）</li><li>局部类不能声明为 public、protected、private 或 static。</li><li>与成员类的原因一样，局部类不能包含静态字段、方法或类。唯一的例外是同时使用 static 和 final 声明的常量。</li><li>接口、枚举类型和注解类型不能局部定义。</li><li>局部类和成员类一样，不能与任何外层类同名。</li><li>前面说过，局部类能使用同一个作用域中的局部变量、方法参数和异常参数，但这些变量或参数必须声明为 final。这是因为，局部类实例的生命周期可能比定义它的方法的执行时间长很多。<blockquote><p>局部类用到的每个局部变量都有一个私有内部副本（这些副本由 javac 自动生成）。只有把局部变量声明为 final 才能保证局部变量和私有副本始终保持一致。</p></blockquote></li></ul><p>这一点从下述代码中可以看出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weird</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态成员接口，下面会用到</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntHolder</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntHolder[] holders = <span class="keyword">new</span> IntHolder[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> fi = i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 局部类</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">MyIntHolder</span> <span class="keyword">implements</span> <span class="title">IntHolder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用前面定义的final变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> fi; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      holders[i] = <span class="keyword">new</span> MyIntHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部类不在作用域中了，因此不能使用</span></span><br><span class="line">    <span class="comment">// 但是在数组中保存有这个类的10个有效实例</span></span><br><span class="line">    <span class="comment">// 局部变量fi现在已经不在作用域中了</span></span><br><span class="line">    <span class="comment">// 但仍然在那10个对象getValue()方法的作用域中</span></span><br><span class="line">    <span class="comment">// 因此，可以在每个对象上调用getValue()方法，打印fi的值</span></span><br><span class="line">    <span class="comment">// 下述代码打印数字 0 到 9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(holders[i].getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前，书中见到的类、接口和枚举类型都定义为顶层类型。也就是说，都是包的直接成员，独立于其他类型。不过，类型还可以嵌套在其他类型中定义。这种类型是嵌套类型（nested type），一般称为“内部类”，是 Java 语言的一个强大功能。&lt;/p&gt;
&lt;p&gt;嵌套类型有两个独立的目的
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Win7下Ant打包安卓apk</title>
    <link href="/html/ant/2018/09/16/win7%E4%B8%8Bant%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93apk.html"/>
    <id>/html/ant/2018/09/16/win7下ant打包安卓apk.html</id>
    <published>2018-09-16T14:48:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>接着上文, 直接上ant脚本<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">default</span>=<span class="string">"package resources"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">安卓构建脚本</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"project-dir"</span> <span class="attr">location</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- JAVA目录(获取操作系统环境变量JAVA_HOME的值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"java_home"</span> <span class="attr">value</span>=<span class="string">"$&#123;env.JAVA_HOME&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SDK目录(获取操作系统环境变量ANDROID_SDK_HOME的值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sdk-folder"</span> <span class="attr">value</span>=<span class="string">"$&#123;env.ANDROID_HOME&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SDK指定平台目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sdk-platform-folder"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-folder&#125;/platforms/android-22"</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 指定平台对应的android.jar --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"android-jar"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-platform-folder&#125;/android.jar"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SDK中tools目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sdk-tools"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-folder&#125;/tools"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SDK中build_tools目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build-tools"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-folder&#125;/build-tools/25.0.2"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SDK指定平台中tools目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sdk-platform-tools"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-platform-folder&#125;/tools"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 使用到的命令(当前系统为mac) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"aapt"</span> <span class="attr">value</span>=<span class="string">"$&#123;build-tools&#125;/aapt"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"aidl"</span> <span class="attr">value</span>=<span class="string">"$&#123;build-tools&#125;/aidl"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dx"</span> <span class="attr">value</span>=<span class="string">"$&#123;build-tools&#125;/dx.bat"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"zipalign"</span> <span class="attr">value</span>=<span class="string">"$&#123;build-tools&#125;/zipalign"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"apkbuilder"</span> <span class="attr">value</span>=<span class="string">"$&#123;sdk-tools&#125;/apkbuilder"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jarsigner"</span> <span class="attr">value</span>=<span class="string">"$&#123;java_home&#125;/bin/jarsigner"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 基本编译路径设置 可定义多个classpath--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"compile.classpath"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"libs"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Create the build directory structure used by compile --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"gen"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"bin/classes"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"generate R"</span> <span class="attr">depends</span>=<span class="string">"init"</span> <span class="attr">description</span>=<span class="string">"Package the android resources得到R.java文件"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"$&#123;aapt&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"package"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-f"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-m"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-M"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"AndroidManifest.xml"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-I"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;android-jar&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-S"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"res"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-J"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"gen"</span> /&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 覆盖资源 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"--auto-add-overlay"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile javac"</span> <span class="attr">depends</span>=<span class="string">"generate R"</span> <span class="attr">description</span>=<span class="string">"Javac编译(包含src和gen目录)java文件"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javac</span> <span class="attr">encoding</span>=<span class="string">"utf-8"</span> <span class="attr">source</span>=<span class="string">"1.6"</span> <span class="attr">target</span>=<span class="string">"1.6"</span> <span class="attr">bootclasspath</span>=<span class="string">"$&#123;android-jar&#125;"</span> <span class="attr">destdir</span>=<span class="string">"bin/classes"</span> <span class="attr">includeantruntime</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">classpath</span> <span class="attr">refid</span>=<span class="string">"compile.classpath"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">src</span> <span class="attr">path</span>=<span class="string">"src"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">src</span> <span class="attr">path</span>=<span class="string">"gen"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"dx"</span> <span class="attr">depends</span>=<span class="string">"compile javac"</span> <span class="attr">description</span>=<span class="string">"打包class文件和jar包dx为classes.dex"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"$&#123;dx&#125;"</span> <span class="attr">failonerror</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"--dex"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"--output=bin/classes.dex"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">path</span>=<span class="string">"bin/classes"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">path</span>=<span class="string">"libs/*.jar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"package resources"</span> <span class="attr">depends</span>=<span class="string">"dx"</span> <span class="attr">description</span>=<span class="string">"打包assets和res资源为资源压缩包(例如res.zip"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"$&#123;aapt&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"package"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-f"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-M"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"AndroidManifest.xml"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-I"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"$&#123;android-jar&#125;"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-A"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"assets"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-S"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"res"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-F"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/resources.ap_"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"--auto-add-overlay"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"apkbuilder"</span> <span class="attr">depends</span>=<span class="string">"package resources"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java</span> <span class="attr">classname</span>=<span class="string">"com.android.sdklib.build.ApkBuilderMain"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">classpath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pathelement</span> <span class="attr">path</span>=<span class="string">"D:\Android\android-sdk\tools\lib\sdklib.jar "</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">classpath</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/unsigned.apk"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-u"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-z"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/resources.ap_"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-f"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/classes.dex"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-rf"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"src"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-rj"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"libs"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-nf"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"libs"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"jarsigner"</span> <span class="attr">depends</span>=<span class="string">"apkbuilder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"$&#123;jarsigner&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-keystore"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"C:\Users\hp\Desktop\保全_其他文档\密钥\android.keystore"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-storepass"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"android"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-keypass"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"android"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-signedjar"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/signed.apk"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/unsigned.apk"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"androiddebugkey"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"zipalign"</span> <span class="attr">depends</span>=<span class="string">"jarsigner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec</span> <span class="attr">executable</span>=<span class="string">"$&#123;zipalign&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"-v"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"4"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/signed.apk"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">value</span>=<span class="string">"bin/signed_aligned.apk"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exec</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span> <span class="attr">description</span>=<span class="string">"clean up"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Delete directory trees --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"gen"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"bin/classes"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>由于我的项目中用到了BuildConfig.java文件, 在第一个生成R文件后我手动拷贝到了R.java的同级目录, 否则接下来的操作会报错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Automatically generated file. DO NOT MODIFY */</span></span><br><span class="line"><span class="keyword">package</span> com.nci.insprotection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>先手动编译通过在调整ant脚本, 否则很容易出错</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/kevin_nazgul/article/details/48767101" target="_blank" rel="noopener">https://blog.csdn.net/kevin_nazgul/article/details/48767101</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/50579416" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/50579416</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接着上文, 直接上ant脚本&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
      <category term="ant" scheme="/categories/ant/"/>
    
    
  </entry>
  
  <entry>
    <title>Ant简介</title>
    <link href="/html/ant/2018/09/15/ant%E7%AE%80%E4%BB%8B.html"/>
    <id>/html/ant/2018/09/15/ant简介.html</id>
    <published>2018-09-15T03:30:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apache Ant 是由 Java 语言开发的工具，由 Apache 软件基金会所提供。Apache Ant 的配置文件写成 XML 容易维护和书写，而且结构很清晰。本教程将以简单的方式会向你展示如何利用 Apache ANT 来自动地构建和部署过程。</p></blockquote><ol><li>找到安装路径<code>C:\L_Executable\apache-ant-1.10.5</code></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANT_HOME C:\L_Executable\apache-ant-1.10.5</span><br><span class="line">Path %ANT_HOME%\bin</span><br></pre></td></tr></table></figure></li><li><p>运行<code>ant -version</code>查看是否安装成功<code>Apache Ant(TM) version 1.10.5 compiled on July 10 2018</code></p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- copy --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拷贝文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">".\build.xml"</span> <span class="attr">tofile</span>=<span class="string">"newBuild.xml"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 拷贝文件夹 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"build/dest_dir"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"origin_dir"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- delete --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除单个文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"test.txt"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 删除整个目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"someDir"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- zip --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将当前目录包含文件压缩 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">zip</span> <span class="attr">destfile</span>=<span class="string">"project.zip"</span> <span class="attr">basedir</span>=<span class="string">"."</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插播Java教程"><a href="#插播Java教程" class="headerlink" title="插播Java教程"></a>插播Java教程</h2><h3 id="javac的官方说法："><a href="#javac的官方说法：" class="headerlink" title="javac的官方说法："></a>javac的官方说法：</h3><p><code>-classpath:</code><br>设置用户类路径，它将覆盖CLASSPATH 环境变量中的用户类路径。若既未指定CLASSPATH 又未指定-classpath，则用户类路径由当前目录构成。<br><code>-sourcepath:</code><br>指定用以查找类或接口定义的源代码路径。与用户类路径一样，源路径项用分号 (;)进行分隔，它们可以是目录、JAR 归档文件或 ZIP 归档文件。如果使用包，那么目录或归档文件中的本地路径名必须反映包名。</p><blockquote><p>注意：通过类路径查找的类，如果找到了其源文件，则可能会自动被重新编译。</p></blockquote><p><code>-d</code>用于指定.class文件的生成目录, 将目录 <code>src/com/tt</code>下Hello.Java类编译到<code>bin</code>目录下<br>美中不足的是-d需要指定已经存在的目录，不能自动创建。<br><code>javac -sourcepath src -classpath . -d bin src/com/tt/Hello.java</code><br>如果没什么其他类的依赖可简写为 <code>javac -d bin src/com/tt/Hello.java</code>   </p><p>java会基于提供的classpath（缩写成cp）路径去搜索。<br><code>java -classpath bin com.tt.Hello</code></p><p>将 <code>bin/</code>目录中的所有文件归档到 ‘classes.jar’ 中:</p><ul><li><p>方法一: 指定<code>MANIFEST.MF</code>文件的命令:  <code>jar vcfm classes.jar MANIFEST.MF -C bin/ .</code></p></li><li><p>方法二: 先直接生成<br><code>jar vcf classes.jar -C bin/ .</code><br>再winRAR直接修改<code>MANIFEST.MF</code><img src="https://upload-images.jianshu.io/upload_images/1662509-1948d6b4264b6e63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>或者拿出<code>MANIFEST.MF</code>文件后命令<code>jar vufm classes.jar MANIFEST.MF</code>, 这里注意要空两个空行, 如果遇到<code>Duplicate name in Manifest: Created-By.</code>这种语句直接忽略就好, 因为字段有重名而已。</p></li></ul><blockquote><p>之所以加’v’是为了生成详细输出</p></blockquote><h3 id="关于Classpath一些笔记"><a href="#关于Classpath一些笔记" class="headerlink" title="关于Classpath一些笔记"></a>关于Classpath一些笔记</h3><p><code>Classpath</code>可以用3种不同的方式设置：</p><ul><li>如果没有设置——那么classpath参数就会被忽略，环境变量中的CLASSPATH就会被使用到</li><li>如果环境变量CLASSPATH没找到，那么就是默认使用当前目录（”.”）</li><li>如果classpath作为命令行参数显示设置了，那么它就是覆盖所有其他的值。 当设置覆盖默认值（当前目录）时，classpath会造成不可预料的结果。 所以要么省略, 要么<code>-cp .;lib/aaa.jar</code>例如为<code>javac -cp .;lib/aaa.jar bbb.java</code></li></ul><p>入门小案例<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"MyProject"</span> <span class="attr">default</span>=<span class="string">"dist"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">simple example build file</span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">file</span>=<span class="string">"build.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- set global properties for this build --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">location</span>=<span class="string">"src"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build"</span> <span class="attr">location</span>=<span class="string">"build/classes"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist"</span> <span class="attr">location</span>=<span class="string">"dist"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Create the time stamp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tstamp</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span> <span class="attr">property</span>=<span class="string">"DSTAMP"</span> <span class="attr">pattern</span>=<span class="string">"yyMMdd"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tstamp</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Create the build directory structure used by compile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span></span></span><br><span class="line"><span class="tag"><span class="attr">description</span>=<span class="string">"compile the source"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Compile the Java code from $&#123;src&#125; into $&#123;build&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build&#125;"</span> <span class="attr">includeantruntime</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"dist"</span> <span class="attr">depends</span>=<span class="string">"compile"</span></span></span><br><span class="line"><span class="tag"><span class="attr">description</span>=<span class="string">"generate the distribution"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Create the distribution directory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist&#125;/lib"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Put everything in $&#123;build&#125; into the jar file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jar</span> <span class="attr">jarfile</span>=<span class="string">"$&#123;dist&#125;/lib/$&#123;jar.filename&#125;-$&#123;DSTAMP&#125;.jar"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;build&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"Main-class"</span> <span class="attr">value</span>=<span class="string">"$&#123;jar.manifest.main-class&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clean"</span> <span class="attr">description</span>=<span class="string">"clean up"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Delete the $&#123;build&#125; and $&#123;dist&#125; directory trees --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Apache Ant 是由 Java 语言开发的工具，由 Apache 软件基金会所提供。Apache Ant 的配置文件写成 XML 容易维护和书写，而且结构很清晰。本教程将以简单的方式会向你展示如何利用 Apache ANT 来自动地构建和部署
      
    
    </summary>
    
      <category term="ant" scheme="/categories/ant/"/>
    
    
  </entry>
  
  <entry>
    <title>09 Java异常</title>
    <link href="/html/java/2018/09/09/09-java%E5%BC%82%E5%B8%B8.html"/>
    <id>/html/java/2018/09/09/09-java异常.html</id>
    <published>2018-09-09T14:00:00.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>异常指的是程序运行时出现的不正常情况</p></blockquote><p>程序运行过程中难免会发生异常，发生异常并不可怕，程序员应该考虑到有可能发生这些异常，编程时应该捕获并进行处理异常，不能让程序发生终止，这就是健壮的程序。</p><h2 id="异常的层次"><a href="#异常的层次" class="headerlink" title="异常的层次"></a>异常的层次</h2><p>Java的异常类是处理运行时的特殊类,每一种异常对应一种特定的运行错误.所有Java异常类都是系统类库中Exception类的子类<br><img src="https://upload-images.jianshu.io/upload_images/1662509-0c6dd4e9db1d694e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常类继承层次图"></p><h2 id="Throwable类"><a href="#Throwable类" class="headerlink" title="Throwable类"></a>Throwable类</h2><p>所有的异常类都直接或间接地继承于java.lang.Throwable类，在Throwable类有几个非常重要的方法：</p><ul><li>String getMessage()：获得发生异常的详细消息。</li><li>void printStackTrace()：打印异常堆栈跟踪信息。<br><code>printStackTrace(PrintStream s)</code>  通常用该方法将异常内容保存在日志文件中，以便查阅。</li><li>String toString()：获得获取异常类名和异常信息的描述。　　</li></ul><h2 id="Error和Exception"><a href="#Error和Exception" class="headerlink" title="Error和Exception"></a>Error和Exception</h2><p>Throwable有两个直接子类：Error和Exception。</p><ol><li><p>Error<br>Error是程序无法恢复的严重错误，程序员根本无能为力，程序中不能对其编程处理， 对Error一般不编写针对性的代码对其进行处理   只能让程序终止。例如：JVM内部错误、内存溢出和资源耗尽等严重情况。</p></li><li><p>Exception<br>Exception是程序可以恢复的异常，它是程序员所能掌控的。例如：除零异常、空指针访问、网络连接中断和读取不存在的文件等。本章所讨论的异常处理就是对Exception及其子类的异常处理。</p></li></ol><h2 id="受检查异常和运行时异常"><a href="#受检查异常和运行时异常" class="headerlink" title="受检查异常和运行时异常"></a>受检查异常和运行时异常</h2><p>Java 的异常处理机制会区分两种不同的异常类型：已检异常checked和未检异常unchecked(运行时异常)。</p><h3 id="已检异常"><a href="#已检异常" class="headerlink" title="已检异常"></a>已检异常</h3><p>在明确的特定情况下抛出，经常是应用<strong>能部分或完全恢复的情况</strong>。例如，某段代码要在多个可能的目录中寻找配置文件。如果试图打开的文件不在某个目录中，就会抛出 FileNotFoundException 异常。在这个例子中，我们想捕获这个异常，然后在文件可能出现的下一个位置继续尝试。也就是说，虽然文件不存在是异常状况，但可以从中恢复，这是意料之中的失败。</p><h3 id="非受检异常"><a href="#非受检异常" class="headerlink" title="非受检异常"></a>非受检异常</h3><p>在Java 环境中有些失败是无法预料的，这些失败可能是由运行时条件或滥用库代码导致的。例如把无效的 null 传给使用对象或数组的方法，会抛出 NullPointerException 异常。基本上任何方法在任何时候都可能抛出未检异常。这是 Java 环境中的墨菲定律：“会出错的事总会出错。”从未检异常中恢复，虽说不是不可能，但往往很难，因为完全不可预知。运行时异常往往是程序员所犯错误导致的，<strong>健壮的程序不应该发生运行时异常</strong>。</p><p>若想区分已检异常和未检异常，记住两点：异常是 Throwable 对象，而且异常主要分为两类，通过 Error 和 Exception 子类标识。只要异常对象是 Error 类，就是未检异常。Exception 类还有一个子类 RuntimeException ， RuntimeException 类的所有子类都属于未检异常。除此之外，都是已检异常。</p><blockquote><p>提示　对于运行时异常通常不采用抛出或捕获处理方式，而是<strong>应该提前预判</strong>，防止这种发生异常，做到未雨绸缪。例如在进行除法运算之前应该判断除数是非零的，修改代码进行提前预判这样处理要比通过try-catch捕获异常要友好的多。</p></blockquote><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><p>Exception类有若干子类,每个子类代表一种特定的运行错误,这些子类有的是系统事先定义好并包含在Java类库中的,成为系统定义的运行异常.</p><ul><li>ClassNotFoundException 未找到要装载的类</li><li>ArrayIndexOutOfBoundsException 数组越界访问</li><li>FileNotFoundException 文件找不到, checked异常</li><li>IOException 输入, 输出错误, checked异常</li><li>NullPointerException 空指针异常, unchecked异常</li><li>ArithmeticException 算术运算错误</li><li>InterruptedException 中断异常, 线程在进行暂停处理时(如睡眠)被调度打断将引发该一场     </li></ul><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><ul><li>对待受检查异常。如果当前方法有能力解决，则捕获异常进行处理；没有能力解决，则抛出给上层调用方法处理。</li><li>涉及了五个关键字<code>try catch finally throw throws</code></li><li><p>try…catch..finally 或者 try-with-resources<strong>(Java7增加)</strong>语句结构进行捕获</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;语句块;&#125; </span><br><span class="line"><span class="keyword">catch</span> (异常类名   参变量名) &#123;语句块;&#125;   </span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">  &#123;语句块;&#125; <span class="comment">//定义一定执行的代码:通常用于关闭资源</span></span><br></pre></td></tr></table></figure></li><li><p>try必须带有 ‘catch’, ‘finally’ 或资源声明才可以使用</p></li><li>一个try可以引导多个catch块。但是不要定义多余的catch块，多个catch块的异常出现继承关系，父类异常catch块放在最后面。</li><li>异常发生后，try块中的剩余语句将不再执行。 </li><li>catch块中的代码要执行的条件是，首先在try块中发生了异常，其次异常的类型与catch要捕捉的一致。 建议声明更为具体的异常，这样处理的可以更具体。当捕获的多个异常类之间存在父子关系时，捕获异常顺序与catch代码块的顺序有关。一般先捕获子类，后捕获父类，否则子类捕获不到。</li><li>可以无finally部分，但如果存在，则无论异常发生否，finally部分的语句均要执行。即便是try或catch块中含有退出方法的语句return，也不能阻止finally代码块的执行; 除非执行System.exit(0)等导致程序停止运行的语句。  </li></ul><blockquote><p>try-catch不仅可以嵌套在try代码块中，还可以嵌套在catch代码块或finally代码块，finally代码块后面会详细介绍。try-catch嵌套会使程序流程变的复杂，<strong>如果能用多catch捕获的异常，尽量不要使用try-catch嵌套</strong>。特别对于初学者不要简单地使用Eclipse的语法提示不加区分地添加try-catch嵌套，要梳理好程序的流程再考虑try-catch嵌套的必要性。</p></blockquote><p>Java 7推出了多重捕获（multi-catch）技术, 可以把这些异常合并处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ParseException e) &#123;</span><br><span class="line">    <span class="comment">//调用方法methodA处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>有时在try-catch语句中会占用一些非Java资源，如：打开文件、网络连接、打开数据库连接和使用数据结果集等，这些资源并非Java资源，不能通过JVM的垃圾收集器回收，需要程序员释放。为了确保这些资源能够被释放可以使用finally代码块或Java 7之后提供自动资源管理（Automatic Resource Management）技术。</p><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p>try-catch语句后面还可以跟有一个finally代码块，try-catch-finally语句语法如下</p><blockquote><p>注意　为了代码简洁等目的，可能有的人会将finally代码中的多个嵌套的try-catch语句合并。每一个close()方法对应关闭一个资源，如果某一个close()方法关闭时发生了异常，那么后面的也不会关闭，因此这种代码是有缺陷的。</p></blockquote><h4 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h4><p>使用finally代码块释放资源会导致程序代码大量增加，一个finally代码块往往比正常执行的程序还要多。在Java 7之后提供自动资源管理（Automatic Resource Management）技术，可以替代finally代码块，优化代码结构，提高程序可读性。</p><p>自动资源管理是在try语句上的扩展，语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明或初始化资源语句) &#123;</span><br><span class="line">    <span class="comment">//可能会生成异常语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e1)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e2)&#123;</span><br><span class="line">    <span class="comment">//处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable eN)&#123;</span><br><span class="line">    <span class="comment">//处理异常eN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在try语句后面添加一对小括号“()”，其中是声明或初始化资源语句，可以有多条语句语句之间用分号“;”分隔。</p><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">… …</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = readDate();</span><br><span class="line">        System.out.println(<span class="string">"读取的日期  = "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">readDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动资源管理</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream readfile = <span class="keyword">new</span> FileInputStream(<span class="string">"readme.txt"</span>);     </span><br><span class="line">                InputStreamReader ir = <span class="keyword">new</span> InputStreamReader(readfile);        </span><br><span class="line">                BufferedReader in = <span class="keyword">new</span> BufferedReader(ir)) &#123;                  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            Date date = df.parse(str);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理IOException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"处理ParseException..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意　所有可以自动管理的资源需要实现AutoCloseable接口，上述代码中三个输入流FileInputStream、InputStreamReader和BufferedReader从Java 7之后实现AutoCloseable接口，具体哪些资源实现AutoCloseable接口需要查询API文档。</p></blockquote><h2 id="throws与声明方法抛出异常"><a href="#throws与声明方法抛出异常" class="headerlink" title="throws与声明方法抛出异常"></a>throws与声明方法抛出异常</h2><p>在一个方法中如果能够处理异常，则需要捕获并处理。但是本方法没有能力处理该异常，捕获它没有任何意义，则需要在方法后面声明抛出该异常，通知上层调用者该方法有可以发生异常。</p><blockquote><p>注意　如果声明抛出的多个异常类之间有父子关系，可以只声明抛出父类。但如果没有父子关系情况下，最好明确声明抛出每一个异常，因为上层调用者会根据这些异常信息进行相应的处理。假如一个方法中有可能抛出IOException和ParseException两个异常，那么声明抛出IOException和ParseException呢？还是只声明抛出Exception呢？因为Exception是IOException和ParseException的父类，只声明抛出Exception从语法是允许的，但是声明抛出IOException和ParseException更好一些。</p></blockquote><ul><li>使用<code>throw</code>抛出异常. 异常的本质是对象,因为<code>throw</code>关键词后跟的是<code>new</code>运算符来创建的一个异常对象.</li><li>使用<code>throws</code>关键字抛出一个或多个异常</li></ul><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>有些公司为了提高代码的可重用性，自己开发了一些Java类库或框架，其中少不了自己编写了一些异常类。实现自定义异常类需要继承Exception类或其子类，如果自定义运行时异常类需继承RuntimeException类或其子类。</p><p>自定义异常就很简单，主要是提供两个构造方法就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="throw与显式抛出异常"><a href="#throw与显式抛出异常" class="headerlink" title="throw与显式抛出异常"></a>throw与显式抛出异常</h2><p>通过throw语句显式抛出异常, 显式抛出异常目的有很多，例如不想某些异常传给上层调用者，可以捕获之后重新显式抛出另外一种异常给调用者。</p><blockquote><p>注意　throw显式抛出的异常与系统生成并抛出的异常，在处理方式上没有区别，就是两种方法：要么捕获自己处理，要么抛出给上层调用者。在本例中是声明抛出，所以在readDate()方法后面要声明抛出MyException异常。</p></blockquote><h2 id="设计良好异常机制"><a href="#设计良好异常机制" class="headerlink" title="设计良好异常机制"></a>设计良好异常机制</h2><ul><li>考虑要在异常中存储什么额外状态——记住，异常也是对象；</li><li>Exception 类有四个公开的构造方法，一般情况下，自定义异常类时这四个构造方法都要实现，可用于初始化额外的状态，或者定制异常消息；</li><li>不要在你的 API 中自定义很多细致的异常类——Java I/O 和反射 API 都因为这么做了而受人诟病，所以别让使用这些包时的情况变得更糟；</li><li>别在一个异常类型中描述太多状况——例如，实现 JavaScript 的 Nashorn 引擎（Java 8新功能）一开始有超多粗制滥造的异常，不过在发布之前修正了。</li></ul><h3 id="异常在子类覆盖中的体现"><a href="#异常在子类覆盖中的体现" class="headerlink" title="异常在子类覆盖中的体现:"></a>异常在子类覆盖中的体现:</h3><ol><li>子类覆盖父类时, 如果父类的方法抛出的异常,那么子类只能抛出父类异常或该异常的子类.          </li><li>如果父类方法抛出多个异常, 那么子类在覆盖方法时,只能抛出父类异常的子集.          </li><li>如果父类或借口的方法中没有异常抛出, 那么子类在覆盖方法时,也不可能抛出异常.如果子类方法发生异常,就必须进行try处理,绝对不能抛.</li></ol><h3 id="避免使用两种处理异常的反模式："><a href="#避免使用两种处理异常的反模式：" class="headerlink" title="避免使用两种处理异常的反模式："></a>避免使用两种处理异常的反模式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要捕获异常而不处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要捕获，记录日志后再重新抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    someMethodThatMightThrow();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SpecificException e)&#123;</span><br><span class="line">    log(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个反模式直接忽略近乎一定需要处理的异常状况（甚至没有在日志中记录）。这么做会增大系统其他地方出现问题的可能性——出现问题的地方可能会离原来的位置很远。</p><p>第二个反模式只会增加干扰——虽然记录了错误消息，但没真正处理发生的问题——在系统高层的某部分代码中还是要处理这个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;异常指的是程序运行时出现的不正常情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序运行过程中难免会发生异常，发生异常并不可怕，程序员应该考虑到有可能发生这些异常，编程时应该捕获并进行处理异常，不能让程序发生终止，这就是健壮的程序。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>08 抽象类与接口</title>
    <link href="/html/java/2018/09/09/08-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.html"/>
    <id>/html/java/2018/09/09/08-抽象类与接口.html</id>
    <published>2018-09-09T12:49:50.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote><p><strong>抽象类</strong>代表了一种优化了的概念组织方式,来描述事物的一般状态和行为,然后在子类中去实现这些状态和行为,以适应对象的多样性. </p></blockquote><h3 id="抽象类声明和实现"><a href="#抽象类声明和实现" class="headerlink" title="抽象类声明和实现"></a>抽象类声明和实现</h3><p>在Java中抽象类和抽象方法的修饰符是<code>abstract</code>, 注意抽象方法中只有方法的声明，没有方法的实现</p><ul><li>抽象类不能被实例化,只有具体类才能被实例化。</li><li>抽象类中是有默认的构造函数, 只供子类实例化调用。 </li><li>抽象类中可以包含具体方法和抽象方法</li></ul><pre><code class="java"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名称</span>{               member var;      method（）{…}       <span class="comment">//一般方法</span>    <span class="function"><span class="keyword">abstract</span> <span class="title">method</span><span class="params">()</span>；  <span class="comment">//抽象方法, 抽象方法在后直接跟分号          </span></span><span class="function">  }</span></code></pre><p>普通类加上abstract关键字就变成了抽象类,没有任何条件限制.但是有抽象方法的类必须定义为抽象类,否则会提示<strong><code>The type XXX must be an abstract class to define abstract methods</code> </strong><br>　　<br>Q: 抽象关键字abstract不可以和哪些关键字共存？ 　　　　<br>A: <code>private</code>  私有内容子类继承不到，所以，不能重写. 但是，abstract修饰的方法，要求被重写。两者冲突。<br><code>final</code>   final修饰的方法不能被重写。而abstract修饰的方法，要求被重写。两者冲突。<br><code>static</code> 假如一个抽象方法能通过static修饰，那么这个方法，就可以直接通过类名调用。而抽象方法是没有方法体的，这样的调用无意义。所以，不能用static修饰。 </p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>比抽象类更加抽象的是接口，在接口中所有的方法都是抽象的。</p><blockquote><p>提示　Java 8之后接口中新增加了默认方法，因此“接口中所有的方法都是抽象的”这个提法在Java 8之后是有待商榷。</p></blockquote><ul><li>Java中不支持多继承,而是通过接口实现比多重继承更强的功能,java通过接口可以使出于不同层次,甚至不相关的类具有相同的行为.</li><li>接口可以认为是特殊的抽象类, 不能用于直接创建对象.接口的作用在于规定一些功能框架,具体功能的实现则通过该接口约束的类完成. </li></ul><p>接口的定义:由常量和抽象方法组成  </p><pre><code class="java">[public] interface 接口名 [extends 父接口名列表 ]  {                     [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 域类型 域名 = 常量值 ;                     [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 返回值 方法名(参数列表) [<span class="keyword">throw</span> 异常列表]；            }</code></pre><ol><li>声明接口可给出访问控制符；  </li><li>一个接口还可以继承多个父接口，父接口间用逗号分隔。   </li><li>系统默认接口中所有属性的修饰都是public static final,毕老师说的全局常量.   </li><li>系统默认接口中所有方法的修饰都是public abstract;即抽象方法.  </li></ol><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><ul><li>定义了一套行为规范,一个类实现这个接口就是要遵守接口的定义规范,要实现接口中定义的所有方法.          </li><li>一个类可以实现多个接口。接口间用逗号分隔；  </li><li>如果实现某接口的类不是抽象类,则在类的定义部分必须实现指定接口的所有抽象方法;否则编译时会指示该类只能为抽象类是不能创建对象的.   </li><li>接口的抽象方法的访问限制符默认为public</li></ul><h3 id="Java-8新特性默认方法和静态方法"><a href="#Java-8新特性默认方法和静态方法" class="headerlink" title="Java 8新特性默认方法和静态方法"></a>Java 8新特性默认方法和静态方法</h3><p>Java 8在接口中提供了声明默认方法和静态方法的能力。接口示例代码如下：<br><code>`</code> java</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;抽象类&lt;/strong&gt;代表了一种优化了的概念组织方式,来描述事物的一般状态和行为,然后在
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>07 Java的继承与多态</title>
    <link href="/html/java/2018/09/09/07-java%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81.html"/>
    <id>/html/java/2018/09/09/07-java的继承与多态.html</id>
    <published>2018-09-09T12:48:50.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java继承的实现(只支持单继承,而不是多继承,称为接口的多实现)<br>　　　　<br>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类. 定义类时直接通过extends关键字指明要继承的父类.<br>子类对象除了可以访问子类中直接定义的成员外,可直接访问父类的所有非私有成员.　　</p><h3 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h3><ul><li>继承提高了代码的复用性。</li><li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li><li>不要仅为了获取其他类中某个功能而去继承,  类与类之间要有所属( “ is a “ )关系)。　　<h3 id="How-如何使用一个继承体系中的功能"><a href="#How-如何使用一个继承体系中的功能" class="headerlink" title="How 如何使用一个继承体系中的功能:　　　　"></a>How 如何使用一个继承体系中的功能:　　　　</h3></li><li>查阅父类功能(定义了共性的功能)　　　　</li><li>创建子类对象使用功能(因为父类可能不能创建对象, 而且子类提供了更丰富的功能)</li><li>继承中自子类变量的特点:如果子类出现非私有的同名变量时, 子类访问本类变量用this, 子类访问父类中的同名变量用super.</li></ul><h3 id="成员变量隐藏"><a href="#成员变量隐藏" class="headerlink" title="成员变量隐藏"></a>成员变量隐藏</h3><p>子类成员变量与父类一样，会屏蔽父类中的成员变量，称为“成员变量隐藏”。</p><h3 id="方法的覆盖（Override）"><a href="#方法的覆盖（Override）" class="headerlink" title="方法的覆盖（Override）"></a>方法的覆盖（Override）</h3><p>如果子类方法完全与父类方法相同，即：相同的方法名、相同的参数列表和相同的返回值，只是方法体不同，这称为子类覆盖（Override）父类方法。</p><p>在声明方法时最后添加<code>@Override</code>注解，<code>@Override</code>注解不是方法覆盖必须的，它只是锦上添花，但添加@Override注解有两个好处：</p><ul><li>提高程序的可读性。</li><li>编译器检查@Override注解的方法在父类中是否存在，如果不存在则报错。</li></ul><h4 id="方法覆盖时应遵循的原则："><a href="#方法覆盖时应遵循的原则：" class="headerlink" title="方法覆盖时应遵循的原则："></a>方法覆盖时应遵循的原则：</h4><blockquote><ol><li>覆盖后的方法不能比原方法有更严格的访问控制（可以相同）。例如将代码第②行访问控制public修改private，那么会发生编译错误，因为父类原方法是protected。</li><li>覆盖后的方法不能比原方法产生更多的异常。</li><li>父类中的私有方法不可以被覆盖。</li></ol></blockquote><h4 id="覆盖的应用："><a href="#覆盖的应用：" class="headerlink" title="覆盖的应用："></a>覆盖的应用：</h4><ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以复写父类中的方法，这样也沿袭了父类的功能</li><li>构造方法在类继承中的作用<br> 构造方法不能继承.由于子类对象要对来自父类的成员进行初始化,因此,在创建子类对象时除了执行子类的构造方法外,还需要调用父类的构造方法.具体遵循如下原则:<ol><li>当子类未定义构造方法时,创建对象时将无条件地调用父类的空构造方法,以为每行第一条super(); </li><li>对于父类的含参数构造方法,子类可以在自己构造方法中使用关键字super来调用它, 但super调用语句必须是子类构造方法中的<strong>第一个</strong>可执行语句； </li><li>子类在自己定义构造方法中如果没有用super明确调用父类的构造方法，则在创建对象时,将自动先执行父类的无参构造方法,然后再执行自己定义的构造方法。<br>所以在一个类的设计时如果有构造方法,最好提供一个无参构造方法.因此,系统类库中的类大多提供了无参构造方法,用户编程时最好也要养成此习惯.     <blockquote><p>【注意】使用this查找匹配的方法时首先在本类查找，找不到时再到其父类和祖先类查找；使用 super 查找匹配方法时，首先到直接父类查找，如果不存在，则继续到其祖先类逐级往高层查找。</p></blockquote></li></ol></li></ul><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>体现在父类或者接口的引用指向或者接收自己的子类对象<br>作用：多态的存在提高了程序的扩展性和后期可维护性.</p><p>发生多态要有三个前提条件：</p><ol><li>继承。多态发生一定要子类和父类之间。</li><li>覆盖。子类覆盖了父类的方法。</li><li>声明的变量类型是父类类型，但实例则指向子类实例。</li></ol><h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><p>并不是所有的引用类型都能互相转换，只有属于同一棵继承层次树中的引用类型才可以转换。</p><p>类型转换有两个方向：</p><ul><li>将父类引用类型变量转换为子类类型，这种转换称为向下转型（downcast）；</li><li>将子类引用类型变量转换为父类类型，这种转换称为向上转型（upcast）。向下转型需要强制转换，而<strong>向上转型是自动的</strong>。</li></ul><p>将父类引用赋值给子类变量时要进行强制转换，强制转换在编译时总是认可的，但运行时的情况取决于对象的值.如果父类对象引用指向的就是该子类的一个对象,则转换是成功的.否则会抛出<code>ClassCastException</code>. 如果不能确定实例是哪一种类型，可以在转型之前使用<code>instanceof</code>运算符判断一下。</p><h2 id="UML图简介"><a href="#UML图简介" class="headerlink" title="UML图简介"></a>UML图简介</h2><blockquote><p>UML是Unified Modeling Language的缩写，即统一标准建模语言。它集成了各种优秀的建模方法学发展而来的。UML图常用的有例图、协作图、活动图、序列图、部署图、构件图、类图、状态图。</p></blockquote><p>面向对象分析与设计（OOAD）时，会用到UML图，其中类图非常重要，用来描述系统静态结构。Student继承Person的类图如图12-1所示。类图中的各个元素说明如图12-2所示，类用矩形表示，一般分为上、中、下三个部分，上部分是类名，中部分是成员变量，下部分是成员方法。实线+空心箭头表示继承关系，箭头指向父类，箭头末端是子类。UML类图中还有很多关系，如图12-3所示，如图虚线＋空心箭头表示实线关系，箭头指向接口，箭头末端是实线类。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-a3e3088cc59363cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图中的元素"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;Java继承的实现(只支持单继承,而不是多继承,称为接口的多实现)&lt;br&gt;　　　　&lt;br&gt;多个类中存在相同属性和行为时，将这些内容抽取到单独
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>06 常用Java类</title>
    <link href="/html/java/2018/09/09/06-%E5%B8%B8%E7%94%A8java%E7%B1%BB.html"/>
    <id>/html/java/2018/09/09/06-常用java类.html</id>
    <published>2018-09-09T12:43:50.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>Java中的字符串是由双引号括起来的多个字符，下面示例都是表示<strong>字符串常量</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello World"</span>                                                             </span><br><span class="line"><span class="string">"\u0048\u0065\u006c\u006c\u006f\u0020\u0057\u006f\u0072\u006c\u0064"</span>      </span><br><span class="line"><span class="string">"世界你好"</span>                                                                 </span><br><span class="line"><span class="string">"A"</span>                                                                       </span><br><span class="line"><span class="string">""</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Java中的字符采用Unicode编码，所以Java字符串可以包含中文等亚洲字符<br>字符串还有一个极端情况，就代码第⑤行的””表示空字符串，双引号中没有任何内容，空字符串不是null，空字符串是分配内存空间，而null是没有分配内存空间。</p></blockquote><p>Java SE提供了三个字符串类：String、StringBuffer和StringBuilder。String是不可变字符串，StringBuffer和StringBuilder是可变字符串。</p><h3 id="String常用的构造方法"><a href="#String常用的构造方法" class="headerlink" title="String常用的构造方法"></a>String常用的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String()：使用空字符串创建并初始化一个新的String对象。</span><br><span class="line"></span><br><span class="line">String(String original)：使用另外一个字符串创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(StringBuffer buffer)：使用可变字符串对象（StringBuffer）创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(StringBuilder builder)：使用可变字符串对象（StringBuilder）创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes)：使用平台的默认字符集解码指定的<span class="keyword">byte</span>数组，通过<span class="keyword">byte</span>数组创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">char</span>[] value)：通过字符数组创建并初始化一个新的 String 对象。</span><br><span class="line"></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)：通过字符数组的子数组创建并初始化一个新的 String 对象；offset参数是子数组第一个字符的索引，count参数指定子数组的长度。</span><br></pre></td></tr></table></figure><h3 id="String的查找"><a href="#String的查找" class="headerlink" title="String的查找"></a>String的查找</h3><p>在给定的字符串中查找字符或字符串是比较常见的操作。在String类中提供了indexOf和lastIndexOf方法用于查找字符或字符串，返回值是查找的字符或字符串所在的位置，-1表示没有找到。这两个方法有多个重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>：从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从前往后搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从前往后搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span>：从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从后往前搜索字符ch，返回第一次找到字符ch所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：从指定的索引开始从后往前搜索字符串str，返回第一次找到字符串所在处的索引。</span></span><br></pre></td></tr></table></figure></p><h3 id="String的比较"><a href="#String的比较" class="headerlink" title="String的比较"></a>String的比较</h3><ol><li>比较相等<br>String提供的比较字符串相等的方法：</li></ol><ul><li>boolean equals(Object anObject)：比较两个字符串中内容是否相等。</li><li>boolean equalsIgnoreCase(String anotherString)：类似equals方法，只是忽略大小写。</li></ul><ol start="2"><li>比较大小<br>有时不仅需要知道是否相等，还要知道大小，String提供的比较大小的方法：</li></ol><ul><li>int compareTo(String anotherString)：按字典顺序比较两个字符串(字典中顺序事实上就<strong>它的Unicode编码</strong>)。如果参数字符串等于此字符串，则返回值 0；如果此字符串小于字符串参数，则返回一个小于 0 的值；如果此字符串大于字符串参数，则返回一个大于 0 的值。</li><li>int compareToIgnoreCase(String str)：类似compareTo，只是忽略大小写。</li></ul><ol start="3"><li>比较前缀和后缀</li></ol><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li></ul><h3 id="String的字符串截取方法"><a href="#String的字符串截取方法" class="headerlink" title="String的字符串截取方法"></a>String的字符串截取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：从指定索引beginIndex开始截取一直到字符串结束的子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span>：从指定索引beginIndex开始截取直到索引endIndex - 1处的字符，注意包括索引为beginIndex处的字符，但不包括索引为endIndex处的字符。</span></span><br></pre></td></tr></table></figure><p>另外，String还提供了字符串分割方法<code>split(&quot; &quot;)</code>方法，参数是分割字符串，返回值String[]。</p><h2 id="可变字符串-StringBuffer和StringBuilder"><a href="#可变字符串-StringBuffer和StringBuilder" class="headerlink" title="可变字符串 StringBuffer和StringBuilder"></a>可变字符串 StringBuffer和StringBuilder</h2><blockquote><p>Java提供了两个可变字符串类StringBuffer和StringBuilder，中文翻译为“字符串缓冲区”。<br>StringBuffer是线程安全的，它的方法是支持线程同步，线程同步会操作串行顺序执行，在单线程环境下会影响效率。StringBuilder是StringBuffer单线程版本，Java 5之后发布的，它不是线程安全的，但它的执行效率很高。</p></blockquote><p>StringBuffer和StringBuilder具有完全相同的API，即构造方法和方法等内容一样。StringBuilder的中构造方法有4个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder()：创建字符串内容是空的StringBuilder对象，初始容量默认为<span class="number">16</span>个字符。</span><br><span class="line"></span><br><span class="line">StringBuilder(CharSequence seq)：指定CharSequence字符串创建StringBuilder对象。CharSequence接口类型，它的实现类有：String、StringBuffer和StringBuilder等，所以参数seq可以是String、StringBuffer和StringBuilder等类型。</span><br><span class="line"></span><br><span class="line">StringBuilder(<span class="keyword">int</span> capacity)：创建字符串内容是空的StringBuilder对象，初始容量由参数capacity指定的。</span><br><span class="line"></span><br><span class="line">StringBuilder(String str)：指定String字符串创建StringBuilder对象。</span><br></pre></td></tr></table></figure></p><h3 id="StringBuffer的追加、插入、删除和替换"><a href="#StringBuffer的追加、插入、删除和替换" class="headerlink" title="StringBuffer的追加、插入、删除和替换"></a>StringBuffer的追加、插入、删除和替换</h3><ul><li>字符串追加方法是append，append有很多重载方法，可以追加任何类型数据。</li><li>StringBuilder insert(int offset, String str)：在字符串缓冲区中索引为offset的字符位置之前插入str，insert有很多重载方法，可以插入任何类型数据。</li><li>StringBuffer delete(int start, int end)：在字符串缓冲区中删除子字符串，要删除的子字符串从指定索引start开始直到索引end - 1处的字符。start和end两个参数与substring(int beginIndex, int endIndex)方法中的两个参数含义一样。</li><li>StringBuffer replace(int start, int end, String str)字符串缓冲区中用str替换子字符串，子字符串从指定索引start开始直到索引end - 1处的字符。start和end同delete(int start, int end)方法。</li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>所有Java类的最终祖先,编译系统默认继承Object类,Object类包含了所有Java类的公共属性和方法</p><p>按道理应该熟悉Object的每个方法<br><code>getClass():Class&lt;?&gt;</code><br><code>public boolean equals(Object obj)</code> :该方法本意用于两个对象的“深度”比较，也就是比较两对象封装的数据是否相等；而比较运算符“==”在比较两对象变量时，只有当两个对象引用指向同一对象时才为真值。但在Object类中，equals方法是采用“==”运算进行比较；<br><code>hashCode()</code><br><code>public String toString()</code>:该方法返回对象的字符串描述,<strong>建议所有子类都重写此方法</strong>。<br><code>notify(), notifyAll, wait(), wait(long), wait(long, int),</code>       </p><p><code>protected  Object clone()</code>: 克隆<br><code>protected  void  finalize()</code>: 该方法Java垃圾回收程序在删除对象前自动执行。目前不建议开发者直接调用.      </p><h2 id="java-lang-Math"><a href="#java-lang-Math" class="headerlink" title="java.lang.Math"></a>java.lang.Math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">的主要方法 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ceil</span><span class="params">(<span class="keyword">int</span> i1,<span class="keyword">int</span> i2)</span>      大于等于d的最大整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> d)</span> 小于等于d的最大整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">random</span><span class="params">()</span>         返回大于等于 0.0 且小于 1.0的 <span class="keyword">double</span> 值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span>   <span class="title">round</span><span class="params">(<span class="keyword">double</span> d)</span>  最靠近d的长整数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> d)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">(<span class="keyword">double</span> x)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> a)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br></pre></td></tr></table></figure><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p> /<em>由于让系统产生随机数使用<br>0~9的随机数 (int)(Math.random()</em>10);<br>0~999的随机数 (int)(Math.random()<em>1000);<br>a~b的随机数 (int)(Math.random()</em>(b-a));<br>其实Math的random方法用的就是util包中的Random类<br>因此可以Random.nextDouble()替换Math.random()<br>*/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String类&quot;&gt;&lt;a href=&quot;#String类&quot; class=&quot;headerlink&quot; title=&quot;String类&quot;&gt;&lt;/a&gt;String类&lt;/h2&gt;&lt;p&gt;Java中的字符串是由双引号括起来的多个字符，下面示例都是表示&lt;strong&gt;字符串常量&lt;/stro
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>05 类和对象</title>
    <link href="/html/java/2018/09/09/05-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.html"/>
    <id>/html/java/2018/09/09/05-类和对象.html</id>
    <published>2018-09-09T12:30:25.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象是Java最重要的特性。Java是彻底的、纯粹的面向对象语言，在Java中“一切都是对象”。本章将介绍面向对象基础知识。</p></blockquote><p>面向对象</p><ul><li>相对面向过程而言, 面向对象和面向过程都是一种思想</li><li>将功能封装进对象，强调具备了功能的对象。</li><li>是一种符合人们思考习惯的思想, 可以将复杂的事情简单化, 将程序员从执行者转换成了指挥者.</li></ul><p>面向对象的开发过程: 其实就是不断的创建对象，使用对象，指挥对象做事情。<br>面向对象的设计过程: 其实就是在管理和维护对象之间的关系。</p><p>面向对象的特征：</p><ul><li>封装(encapsulation): 封装能够使外部访问者不能随意存取对象的内部数据，隐藏了对象的内部细节，只保留有限的对外接口。外部访问者不用关心对象的内部细节，使得操作对象变得简单。</li><li>继承(inheritance)</li><li>多态(polymorphism): 指在父类中成员变量和成员方法被子类继承之后，可以具有不同的状态或表现行为。</li></ul><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>Java中用类<code>Class</code>来描述事物.是具体事物的抽象，概念上的定义。</p><ul><li>属性：对应类中的成员变量。</li><li>行为：对应类中的成员函数。</li></ul><p>类定义包括类声明和类体两部分,类定义的语法格式如下:<br><code>[public][abstract|final] class className [extends superclassName] [implements interfaceNameList]  {类体}</code></p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>创建对象及访问对象成员　　</p><ol><li>声明对象与声明普通变量没有区别 ，格式：<code>type objectName;</code>　<br>声明并不为对象分配内存空间，而只是<strong>分配一个引用</strong></li><li>实例化对象。分为两个阶段：为对象分配内存空间和初始化对象，首先使用<strong>new运算符</strong>为对象分配内存空间，然后再<strong>调用构造方法</strong>初始化对象。格式如下：<code>new 类的构造方法();</code>             </li><li>通过引用变量访问对象成员               </li></ol><ul><li>引用变量名.属性               </li><li>引用变量名.方法名（实参表）  </li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法　"></a>构造方法　</h3><p>作用: 给对象进行初始化</p><h4 id="构造方法的特点"><a href="#构造方法的特点" class="headerlink" title="构造方法的特点"></a>构造方法的特点</h4><ul><li>构造方法的名称必须与类名同名；                     </li><li>构造方法没有返回类型, 包括void, 所以不可以写return语句; </li><li>构造方法只能与new运算符结合使用;</li><li>通常一个类可提供多个构造方法，这些方法的参数不同。在创建对象<br>时，系统自动调用参数匹配的构造方法为对象初始化</li><li>如果一个类未指定构造方法，则系统自动提供的无参构造方法，但如果自定义了构造方法，则系统不再提供无参构造方法。<br>无参构造方法形式如下： public Person() { } , 所以自己最好还要默默的加入无参构造方法 </li><li>什么时候定义构造方法: 当分析事物时, 该事物具备一定特性或行为, 可以将这些内容定义在构造方法中.</li></ul><blockquote><p>一个类默认有一个空参数的构造函数,这个构造函数的权限与所属类一致. 如果类被public修饰,则默认的构造函数也被public修饰.总之<strong>默认构造函数的权限是随着类</strong>而变化.</p></blockquote><h4 id="对象的初始化和构造方法"><a href="#对象的初始化和构造方法" class="headerlink" title="对象的初始化和构造方法"></a>对象的初始化和构造方法</h4><p>在创建对象时，要给对象的属性成员分配内存空间，同时进行初始化。 </p><ol><li>如果定义属性成员时没有指定初值，则系统自动指定初值.在定义属性成员时也可以指定初值.public class Point {private int x=10;    ……</li><li>指定初值的另一种办法是通过初始化块来设置对象的初值(也叫做构造代码块,它是给所有对象进行统一初始化)。<br>//注意首先是按照属性定义的初值,然后是初始化块,</li><li>最后是构造方法:构造方法是给对相关设置初值的规范方法,构造方法是根据方法参数给对象属性赋不同的值</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>声明类体中成员变量语法格式如下：<br><code>[public | protected | private ] [static] [final] type variableName;    //成员变量</code></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p><code>[public | protected | private ] [static] [final | abstract] [native] [synchronized] type methodName([paramList]) [throws exceptionList] {                         //方法体}</code></p><h3 id="静态-static-方法"><a href="#静态-static-方法" class="headerlink" title="静态(static)方法"></a>静态(static)方法</h3><p>用static修饰的属性是属于类的静态属性, 相应的成员变量为类变量         </p><ol><li><p>类变量的访问形式               </p><ul><li>在本类中直接访问：count </li><li>通过类名访问：User.count                </li><li>不建议通过类的一个对象访问，如：x1.count, 实际上还是通过类名的方式访问</li></ul></li><li><p>给类变量赋初值<br>默认赋值即可,也可以用静态初始化代码块 static{count=100;}<br>//静态初始化代码的执行是在main方法执行前完成。　　　</p></li><li>被static修饰的类成员特点：是共享数据, 随着类的加载而加载, 优先于对象存在, 被所有对象所共享, 可以直接被类名调用.</li></ol><h3 id="静态方法-当功能内部没访问对象特有数据时使用"><a href="#静态方法-当功能内部没访问对象特有数据时使用" class="headerlink" title="静态方法 (当功能内部没访问对象特有数据时使用)"></a>静态方法 (当功能内部没访问对象特有数据时使用)</h3><p>用 static修饰的方法称为静态方法，也叫类方法. 在static方法中只能处理类变量，也可访问其它static方法，但绝不能直接访问任何归属对象空间的变量或方法.　</p><ul><li>静态方法中不可以写this，super关键字</li><li>主函数是静态方法. </li></ul><p>tip: 创建某个工具类, 只提供相应的静态方法, 为了让某个类不能创建对象, 可以私有化构造函数.</p><h2 id="理解this和super"><a href="#理解this和super" class="headerlink" title="理解this和super"></a>理解this和super</h2><p>出现在类的实例方法或构造方法中，this代表所在函数所属对象的引用 .用this作前缀可访问当前对象的实例变量或成员方法.          </p><ol><li>this.实例变量;          </li><li>this.成员方法;          </li><li>this(参数),用来调用同类其他构造方法.注意this语句只能定义在构造函数的第一行,因为初始化要先执行.</li></ol><p>而super和this差不多,都是一个引用指向自身和上一级父类罢了  </p><h3 id="对象初始化过程总结"><a href="#对象初始化过程总结" class="headerlink" title="对象初始化过程总结　　"></a>对象初始化过程总结　　</h3><ol><li>new 用到了class文件,所以先回找到class文件并加载到内存　　</li><li>执行类的static {}代码块　　</li><li>在堆内存中开辟空间,分配内存地址　　</li><li>在堆内存中建立对象的特有属性,病默认初始化　</li><li>对属性显示初始化;　　</li><li>构造代码快初始化{};　　</li><li>构造函数初始化;　　</li><li>将内存地址赋给栈内存变量.</li></ol><h2 id="使用包组织类"><a href="#使用包组织类" class="headerlink" title="使用包组织类"></a>使用包组织类</h2><blockquote><p>在Java中为了防止类、接口、枚举和注释等命名冲突引用了包（package）概念，包本质上命名空间（namespace）。在包中可以定义一组相关的类型（类、接口、枚举和注释），并为它们提供访问保护和命名空间管理。</p></blockquote><p>package语句定义包，package语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句，并且package语句适用于所有类型（类、接口、枚举和注释）的文件。定义包语法格式如下：<code>package pkg1[.pkg2[.pkg3…]];</code></p><p>Java API简介: Java中按包来组织类.包的组织采用分层结构,与文件系统中的目录的组织对应一致.通常将逻辑相关的类放在同一个包中.<br>包将类的命名空间进行有效划分,同一包中不能有两个同名的类. Java系统提供的类库也成为Java API, 是系统提供的已实现的标准类的集合.  </p><h3 id="建立包"><a href="#建立包" class="headerlink" title="建立包"></a>建立包</h3><p>创建包就是在指定目录路径下创建一个 子文件夹 ,这个包中所有类的字节码文件将存放在该文件夹下.</p><p>方法1: 创建一个test子目录，将源程序文件存放到该目录，在该目录下利用javac编译源代码，或者在别处编译完程序后将字节码文件拷贝到该目录即可。<br>方法2: 采用带路径指示的编译命令： 格式：<code>javac –d  destpath Point.java</code>  </p><p>编译器将自动在destpath指定的目录下建一个test子目录，并将产生的字节码文件保存到该子目录下 </p><p>典型用法是源程序放在当前目录下,<br>用如下命令编译 <code>javac –d . Point.java</code><br>编译后将在当前目录自动创建test子目录</p><h3 id="包的引用"><a href="#包的引用" class="headerlink" title="包的引用"></a>包的引用</h3><ol><li>在引用类时使用包名作前缀例 ：new java.util.Date() </li><li>用import语句加载需要使用的类。例:import java.util.Date; 然后在程序中可以直接通过类名创建对象, 如：new Date(); </li><li>用import语句加载整个包, 用<code>*</code>号代替类名位置。 它将加载包中的所有的类。例：<code>import java.util.*;</code></li></ol><blockquote><p>小知识:使用javadoc制作帮助文档　<br><code>javadoc -d destpath -version -author Tools.java</code></p></blockquote><h2 id="封装性与访问控制"><a href="#封装性与访问控制" class="headerlink" title="封装性与访问控制"></a>封装性与访问控制</h2><p>Java面向对象的封装性是通过对成员变量和方法进行访问控制实现的，访问控制分为4个等级：私有、默认、保护和公有<br><img src="https://upload-images.jianshu.io/upload_images/1662509-496751fa2a911c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java类成员的访问控制"></p><ul><li>公有级别的关键字是public，公有级别的成员变量和方法可以在任何场合被直接访问，是最宽松的一种访问控制等级。</li><li>保护级别的关键字是protected，保护级别在同一包中完全与默认访问级别一样，但是不同包中子类能够继承父类中的protected变量和方法，这就是所谓的保护级别，“保护”就是保护某个类的子类都能继承该类的变量和方法。</li><li>默认级别没有关键字，也就是没有访问修饰符，默认级别的成员变量和方法，可以在其所在类内部和同一个包的其他类中被直接访问，但在不同包的类中则不允许直接访问。</li><li>私有级别的关键字是private，私有级别的成员变量和方法只能在其所在类的内部自由使用，在其他的类中则不允许直接访问。</li></ul><blockquote><p>提示　访问类成员时，在能满足使用的前提下，应尽量限制类中成员的可见性，访问级别顺序是：私有级别→默认级别→保护级别→公有级别。</p></blockquote><h2 id="对象销毁"><a href="#对象销毁" class="headerlink" title="对象销毁"></a>对象销毁</h2><p>对象不再使用时应该销毁。C++语言对象是通过delete语句手动释放，Java语言对象是由垃圾回收器（Garbage Collection）收集然后释放，程序员不用关心释放的细节。自动内存管理是现代计算机语言发展趋势，例如：C#语言的垃圾回收，Objective-C和Swift语言的ARC（内存自动引用计数管理）。</p><p>垃圾回收器（Garbage Collection）的工作原理是：当一个对象的引用不存在时，认为该对象不再需要，垃圾回收器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;面向对象是Java最重要的特性。Java是彻底的、纯粹的面向对象语言，在Java中“一切都是对象”。本章将介绍面向对象基础知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相对面向过程而言, 面向对象和面向过程都
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>04 Java数组</title>
    <link href="/html/java/2018/09/09/04-java%E6%95%B0%E7%BB%84.html"/>
    <id>/html/java/2018/09/09/04-java数组.html</id>
    <published>2018-09-09T12:18:36.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机语言中数组是非常重要的集合类型，大部分计算机语言中数组具有如下三个基本特性：</p><ol><li>一致性：数组只能保存<strong>相同数据类型</strong>元素，元素的数据类型可以是任何相同的数据类型。</li><li>有序性：数组中的元素是有序的，通过下标访问。</li><li><p>不可变性：数组一旦初始化，则<strong>长度（数组中预分配的元素个数）不可变</strong>。</p><h2 id="一维数组-声明数组-创建数组空间-初始化三步"><a href="#一维数组-声明数组-创建数组空间-初始化三步" class="headerlink" title="一维数组: 声明数组,创建数组空间,初始化三步."></a>一维数组: 声明数组,创建数组空间,初始化三步.</h2></li></ol><p>格式1： 元素类型[]  数组名(推荐采用) ;<br>格式2： 元素类型  数组名[] ;<br> 其中，数组元素的类型可以是基本类型，也可以是类或接口。   </p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><p>声明完成就要对数组进行初始化，数组初始化的过程就是为数组每一个元素分配内存空间，并为每一个元素提供初始值。初始化之后数组的长度就确定下来不能再变化了。 </p><p>数组初始化可以分为静态初始化和动态初始化。</p><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>静态初始化就是<strong>将数组的元素放到大括号中</strong>，元素之间用逗号（,）分隔。<br>使用场景: 在已知数组的每一个元素内容情况下使用的，这样一次到位。<br>示例代码如下：<code>String[] strArray = {&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;}; //静态初始化Stirng数组</code></p><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>动态初始化使用new运算符分配指定长度的内存空间，<br>语法如下：<code>new 元素数据类型[数组长度] ;</code></p><p>new分配数组内存空间后，不同类型都会有默认值，如下图。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-4087e8f4537c5156.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据类型默认值"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组声明"><a href="#二维数组声明" class="headerlink" title="二维数组声明"></a>二维数组声明</h3><p>当数组中每个元素又可以带有多个下标时，这种数组就是“多维数组”。<br>Java中声明二维数组需要有两个中括号，具体有三种语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">元素数据类型[][] 数组变量名;</span><br><span class="line">元素数据类型 数组变量名[][];</span><br><span class="line">元素数据类型[] 数组变量名[];</span><br></pre></td></tr></table></figure></p><h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>二维数组的初始化也可以分为静态初始化和动态初始化。</p><h4 id="静态初始化-1"><a href="#静态初始化-1" class="headerlink" title="静态初始化"></a>静态初始化</h4><p><code>int intArray[][] = { { 1, 2, 3 }, { 11, 12, 13 }, { 21, 22, 23 }, { 31, 32, 33 } };</code></p><blockquote><p>提示　严格意义上说Java中并不存在真正意义上的多维数组，只是一维数组，不过数组中的元素也是数组，以此类推三维数组就是数组的数组的数组了，例如{ { {1, 2}, {3} }, { {21}, {22, 23} } }表示一个三维数组。</p></blockquote><h4 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>语法: <code>new 元素数据类型[高维数组长度] [低维数组长度] ;</code></p><h2 id="3-不规则数组"><a href="#3-不规则数组" class="headerlink" title="3. 不规则数组"></a>3. 不规则数组</h2><p>由于Java多维数组是数组的数组，因此会衍生出一种不规则数组<br>动态初始化不规则数组比较麻烦，不能使用new int[4][3]语句，而是先初始化高维数组，然后再分别逐个初始化低维数组。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intArray[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][]; <span class="comment">//先初始化高维数组为4</span></span><br><span class="line"><span class="comment">//逐一初始化低维数组</span></span><br><span class="line">intArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">intArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">intArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">intArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1662509-e1054034bc816264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="4-其它"><a href="#4-其它" class="headerlink" title="4. 其它"></a>4. 其它</h2><p> <img src="http://upload-images.jianshu.io/upload_images/1662509-961f0a169874ae4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数组的内存结构"></p><p>数组中常见的Exception:</p><ul><li>访问到不存在的角标: ArrayIndexOutOfBoundsException　　</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计算机语言中数组是非常重要的集合类型，大部分计算机语言中数组具有如下三个基本特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一致性：数组只能保存&lt;strong&gt;相同数据类型&lt;/strong&gt;元素，元素的数据类型可以是任何相同的数据类型。&lt;/li&gt;
&lt;li&gt;有序性：数组中的元素是有序的，
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>03 Java流程控制语句</title>
    <link href="/html/java/2018/09/09/03-java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html"/>
    <id>/html/java/2018/09/09/03-java流程控制语句.html</id>
    <published>2018-09-09T04:48:50.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的控制语句有以下三类：</p><ol><li>分支语句：if和switch</li><li>循环语句：while、do-while和for</li><li>跳转语句：break、continue、return和throw</li></ol><h2 id="条件选择语句"><a href="#条件选择语句" class="headerlink" title="条件选择语句:"></a>条件选择语句:</h2><h3 id="if型-if-else型-if-else嵌套型-之间可以相互嵌套"><a href="#if型-if-else型-if-else嵌套型-之间可以相互嵌套" class="headerlink" title="if型,if else型,if else嵌套型 (之间可以相互嵌套)"></a>if型,if else型,if else嵌套型 (之间可以相互嵌套)</h3><p>如果条件体只有一句话,大括号可以省略但不建议, 极短的可以写成一行, 例如<code>if (flag) doSomeThing();</code></p><blockquote><p>else-if结构实际上是if-else结构的多层嵌套，它明显的特点就是在多个分支中只执行一个语句组，而其他分支都不执行，所以这种结构可以用于有多种判断结果的分支中。</p></blockquote><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><ul><li>其中expression必须为<code>byte</code>,<code>short</code>,<code>char</code>, <code>int</code>, JDK1.5新增<code>enum</code>枚举,  JDK1.5新增<code>String</code>类型 </li><li>default实现所有case都没捕获到的情况 </li><li>case 0: case 1: case 2: { } 实现了多个case对应一种情况. </li></ul><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><ul><li>共3种while, do while, for</li><li>for和while循环是在执行循环体之前测试循环条件</li><li>Java 5之后推出for-each循环语句，for-each循环是for循环的变形，它是专门为集合遍历而设计的，注意for-each并不是一个关键字。</li><li>循环体内部必须通过语句更改循环变量的值，否则将会发生死循环。</li></ul><h3 id="while-和-do-while"><a href="#while-和-do-while" class="headerlink" title="while 和 do while"></a>while 和 do while</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">while</span> (循环条件) &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do while</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125; <span class="keyword">while</span> (循环条件);</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for语句是应用最广泛、功能最强的一种循环语句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 循环条件; 迭代) &#123;</span><br><span class="line">    语句组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个无限循环</span></span><br><span class="line"><span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>提示　初始化、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。代码如下：</p></blockquote><h3 id="for-each语句"><a href="#for-each语句" class="headerlink" title="for-each语句"></a>for-each语句</h3><p>Java 5之后提供了一种专门用于遍历集合的for循环——for-each循环。使用for-each循环不必按照for的标准套路编写代码，只需要提供一个<strong>集合</strong>或<strong>数组</strong>就可以遍历。</p><blockquote><p>item不是循环变量，它保存了集合中的元素, 他只是一个临时变量, 因此不能做删除元素和替换元素的工作</p></blockquote><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>break、continue、throw和return。本节重点介绍break和continue语句的使用。</p><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>break语句可用于上一节介绍的while、repeat-while和for循环结构，它的作用是强行退出循环体，不再执行循环体中剩余的语句。</p><p>在循环体中使用break语句有两种方式：带有标签和不带标签。语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;           <span class="comment">//不带标签</span></span><br><span class="line"><span class="keyword">break</span> label;     <span class="comment">//带标签，label是标签名, 例如 label: for循环</span></span><br></pre></td></tr></table></figure></p><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><p>continue语句用来结束本次循环，跳过循环体中尚未执行的语句，接着进行终止条件的判断，以决定是否继续循环。对于for语句，在进行终止条件的判断前，还要先执行迭代语句。</p><p>在循环体中使用continue语句有两种方式可以带有标签，也可以不带标签。语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;          <span class="comment">//不带标签</span></span><br><span class="line"><span class="keyword">continue</span> label;    <span class="comment">//带标签，label是标签名 , 例如 label: while循环</span></span><br></pre></td></tr></table></figure></p><blockquote><p>break添加标签的意义，添加标签对于多层嵌套循环是很有必要的，适当使用可以提高程序的执行效率。</p></blockquote><blockquote><p>break和continue关键字比较:</p><ul><li>break既用在循环语句中,也可用在条件选择语句中的switch语句. </li><li>contine只用在循环语句中,作用是结束本次循环,接着继续进行条件判断</li><li>break只会跳出最近的内循环</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的控制语句有以下三类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分支语句：if和switch&lt;/li&gt;
&lt;li&gt;循环语句：while、do-while和for&lt;/li&gt;
&lt;li&gt;跳转语句：break、continue、return和throw&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>02 Java的运算符、表达式</title>
    <link href="/html/java/2018/09/09/02-java%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>/html/java/2018/09/09/02-java的运算符、表达式.html</id>
    <published>2018-09-09T01:10:25.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java语言中的运算符（也称操作符）在风格和功能上都与C 和C++极为相似。</p></blockquote><ul><li>按操作数分为一元,二元和三元</li><li>按照功能: 包含算术,关系,逻辑,位,赋值组合等几种运算符.</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1662509-e82822fe9eda987f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运算符优先级从高到低"></p><blockquote><p>总结　运算符优先级大体顺序，从高到低是：算术运算符→位运算符→关系运算符→逻辑运算符→赋值运算符。</p></blockquote><ul><li>==和!=可以应用于基本数据类型和引用数据类型。当用于引用数据类型比较时，比较的是两个引用是否指向同一个对象，但在当时实际开发过程中多数情况下，只是比较对象的内容是否相当，不需要比较是否为同一个对象。</li><li>提示　短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程时，应该优先考虑使用短路与和短路或。</li><li>有符号右移n位，相当于操作数除以2n。另外，左位移n位，相当于操作数乘以2n。</li><li>比较运算符得到的结果是true or false布尔常量</li><li>位运算符注意 <strong>异或</strong> <code>^</code>是不同为真，相同为假。<code>10为1</code> <code>11为0</code>; 若一个数异或2次或2次的倍数有还原的效果</li><li>三元运算符格式: <code>(条件表达式) ? 表达式1 : 表达式2;</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1662509-484dff3540e98375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="位运算符"></p><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><ul><li>除了前面介绍的主要运算符，Java还有一些其他运算符。<br>三元运算符（? :）。例如x?y:z;，其中x、y和z都为表达式。</li><li>小括号。起到改变表达式运算顺序的作用，它的优先级最高。<br>中括号。数组下标。</li><li>引用号（.）。对象调用实例变量或实例方法的操作符，也是类调用静态变量或静态方法的操作符。</li><li>赋值号（=）。赋值是用等号运算符（=）进行的。</li><li>instanceof。判断某个对象是否为属于某个类。</li><li>new。对象内存分配运算符。</li><li>箭头（-&gt;）。Java 8新增加的，用来声明Lambda表达式。</li><li>双冒号（::）。Java 8新增加的，用于Lambda表达式中方法的引用。</li></ul><h2 id="考考你"><a href="#考考你" class="headerlink" title="考考你"></a>考考你</h2><p>Q: “6+6”+6+6 的输出结果<br>A: 是 6+666, 这是”+”字符连接符导致.</p><p>Q: -2%5<br>A: 为-2(算术运算符中除法符号看左边就行。)</p><p>关于<code>instance of</code>关键字<br><code>(Integer)null</code>编译和运行完美通过, 结果为null<br><code>null instanceof 任意类</code> 都为false</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Java语言程序设计》华东交大版 丁振凡 主编</p><p>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></p><p>Java从小白到大牛-图书-图灵社区<br><a href="http://www.ituring.com.cn/book/2480" target="_blank" rel="noopener">http://www.ituring.com.cn/book/2480</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Java语言中的运算符（也称操作符）在风格和功能上都与C 和C++极为相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按操作数分为一元,二元和三元&lt;/li&gt;
&lt;li&gt;按照功能: 包含算术,关系,逻辑,位,赋值组合等几种运算符.&lt;/li
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>01 Java的数据类型</title>
    <link href="/html/java/2018/09/08/01-java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <id>/html/java/2018/09/08/01-java的数据类型.html</id>
    <published>2018-09-08T15:41:24.000Z</published>
    <updated>2020-03-04T15:59:09.120Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在声明变量或常量时会用到数据类型，在前面已经用到一些数据类型，例如int、double和String等。Java语言的数据类型分为：八种基本类型和三种引用类型(数组, class, interface)。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1662509-ee14eb10d52d0d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="几种数据类型"><a href="#几种数据类型" class="headerlink" title="几种数据类型"></a>几种数据类型</h2><h3 id="整型-整数类型"><a href="#整型-整数类型" class="headerlink" title="整型(整数类型)"></a>整型(整数类型)</h3><ul><li>整型分为long、int、short和byte四种类型</li><li><strong>默认为int</strong>, byte、short、int和long ，它们之间的区别仅仅是<strong>宽度和范围</strong>的不同。</li><li>Java中整数都是有符号，与C不同没有无符号的整数类型。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-fe7aad922e691e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><h3 id="浮点型-小数类型"><a href="#浮点型-小数类型" class="headerlink" title="浮点型(小数类型)"></a>浮点型(小数类型)</h3><ul><li>浮点型常量后面加后缀修饰, Float类型以F/f结尾，double类型以D/d结尾。</li><li>如果浮点常量不带后缀，则默认为<strong>双精度</strong>常量<br><img src="https://upload-images.jianshu.io/upload_images/1662509-1fa1a7780e9f9ff2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li></ul><h4 id="数字表示方式"><a href="#数字表示方式" class="headerlink" title="数字表示方式"></a>数字表示方式</h4><h5 id="进制数字表示"><a href="#进制数字表示" class="headerlink" title="进制数字表示"></a>进制数字表示</h5><p>Java中对整型数据的表示有以下三种形式：  </p><pre><code>- 二进制：数据以`0b`或`0B`开头，例如：`4`，`-15`- 八进制：数据以`0`开头，例如：`054`，`012`- 十六进制：数据以`0x`或`0X`开头，例如：`0x11`，`0xAD00 `</code></pre><h5 id="指数表示"><a href="#指数表示" class="headerlink" title="指数表示"></a>指数表示</h5><p>进行数学计算时往往会用到指数表示的数值。如果采用<strong>十进制</strong>表示指数，需要使用大写或小写的e表示幂，e2表示102。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> myMoney = <span class="number">3.36e2</span>;</span><br><span class="line"><span class="keyword">double</span> interestRate = <span class="number">1.56e-2</span>;</span><br></pre></td></tr></table></figure></p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>Java中char声明字符类型</li><li>必须用单引号括起来的单个字符</li><li>双字节国际统一标准Unicode编码，占两个字节（16位），因而可用十六进制（无符号的）编码形式表示, 所以’A’字符也可以用Unicode编码’\u0041’表示<blockquote><p>提示　字符类型也属于是数值类型，可以与<strong>int等数值类型</strong>进行数学计算或进行转换。这是因为字符类型在计算机中保存的是Unicode编码，双字节Unicode的存储范围在\u0000~\uFFFF，所以char类型取值范围<code>0 ~ 65535</code>。</p></blockquote></li></ul><p>在Java中，为了表示一些特殊字符，前面要加上反斜杠（\），这称为字符转义。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-2e0d430b87f4873f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>在Java语言中声明布尔类型的关键字是boolean，它只有两个值：true和false。     </p><p><img src="http://upload-images.jianshu.io/upload_images/1662509-fd7793bd9fe09607.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="取值范围"></p><h2 id="数值类型相互转换"><a href="#数值类型相互转换" class="headerlink" title="数值类型相互转换"></a>数值类型相互转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>自动类型转换就是需要类型之间转换是自动的，不需要采取其他手段，总的原则是小范围数据类型可以自动转换为大范围数据类型，列类型转换顺序如图所示，从左到右是自动。<br><img src="https://upload-images.jianshu.io/upload_images/1662509-5bcdc9e4501cb800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><blockquote><p>注意　如图所示，char类型比较特殊，char自动转换为int、long、float和double，但byte和short不能自动转换为char，而且char也不能自动转换为byte或short。</p></blockquote><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在数值类型转换过程中，除了需要自动类型转换外，有时还需要强制类型转换，强制类型转换是在变量或常量之前加上“(目标类型)”实现。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>变量和常量是构成表达式的重要部分，变量所代表的内部是可以被修改的。</p><ul><li>一定要注意变量属于哪个类型和它的取值范围                  </li><li>强制类型转换(小能默认转大,大转小要用强转) </li><li>强转可以取某个实数的整数部分(int a = (int)12.34)</li></ul></blockquote><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li>定义在类中，在整个类中都可以被访问。</li><li>成员变量随着对象的建立而建立，存在于对象所在的<strong>堆内存</strong>中。</li><li>成员变量有默认初始化值。</li></ul><h3 id="静态成员变量-类变量"><a href="#静态成员变量-类变量" class="headerlink" title="静态成员变量(类变量)"></a>静态成员变量(类变量)</h3><p>加了static关键字</p><h3 id="局部变量-自动变量-："><a href="#局部变量-自动变量-：" class="headerlink" title="局部变量(自动变量) ："></a>局部变量(自动变量) ：</h3><ul><li>局部变量只定义在局部范围内，如：方法内，语句内等。 </li><li>局部变量存在于<strong>栈内存</strong>中。</li><li>作用的范围结束，变量空间会自动释放。</li><li>局部变量<strong>没有默认初始化值</strong></li><li>在方法体内可以定义本方法所使用的变量，这种变量是局部变量，它的生存期与作用域是在本方法内。</li><li>方法体内定义变量时，变量前不能加修饰符。</li><li>局部变量在使用前必须明确赋值，因为它没有默认值，否则编译时会出错。</li><li>在语句块中定义的变量它只在语句块中有效；</li><li>方法参数:作用域是整个方法.</li><li>异常处理参数:catch跟随的异常处理块.</li></ul><h3 id="变量的作用域总结"><a href="#变量的作用域总结" class="headerlink" title="变量的作用域总结"></a>变量的作用域总结</h3><p>变量的作用域也称变量的有效范围，它是程序的一个区域，变量在其作用域内可以通过它的名字来引用。作用域也决定系统什么时候为变量创建和清除内存。根据变量在程序声明的位置，可以将变量分为4类情形。</p><ul><li>成员变量 / 类变量(静态成员变量)<br>成员变量可添加修饰符，包括访问权限修饰符<code>public</code>、<code>private</code>、<code>protected</code>和非访问权限修饰符<code>static</code>、<code>final</code>、<code>native</code>等。</li><li>如果没有给对象属性赋初值，则对象属性的初始值由相应数据类型的默认值决定，如数值型数据的默认值为0，boolean的默认值为false，字符串的默认值为null。成员变量的作用域是在类的范围。 </li></ul><h3 id="成员变量和静态成员变量-类变量-的区别"><a href="#成员变量和静态成员变量-类变量-的区别" class="headerlink" title="成员变量和静态成员变量(类变量)的区别"></a>成员变量和静态成员变量(类变量)的区别</h3><ol><li>两个变量的生命周期不同。  　　<br>成员变量随着对象的创建而存在，随着对象的被回收而释放。   　　<br>静态变量随着类的加载而存在，随着类的消失而消失。　</li><li>调用方式不同。　　     <ul><li>成员变量只能被对象调用。　　     </li><li>静态变量可以被对象调用，还可以被类名调用。　　</li></ul></li><li>数据存储位置不同。     　　<ul><li>成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据  　　</li><li>静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据. </li></ul></li></ol><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量事实上是那些内容不能被修改的变量，常量与变量类似也需要初始化，即在声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。它的声明格式为：<code>final 数据类型 变量名 = 初始值;</code></p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>Java编码规范命名方法采用驼峰法，下面分类说明一下。</p><ul><li>包名：包名是全小写字母，中间可以由点分隔开。作为命名空间，包名应该具有唯一性，推荐采用公司或组织域名的倒置，如com.apple.quicktime.v2。但Java核心库包名不采用域名的倒置命名，如java.awt.event。</li><li>类和接口名：采用大驼峰法，如SplitViewController。</li><li>文件名：采用大驼峰法，如BlockOperation.java。</li><li>变量：采用小驼峰法，如studentNumber。</li><li>常量名：全大写，如果是由多个单词构成，可以用下划线隔开，如YEAR和WEEK_OF_MONTH。</li><li>方法名：采用小驼峰法，如balanceAccount、isButtonPressed等。</li></ul><p>命名规范示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gitee.kailee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Date</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">valueOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> YEAR_LENGTH = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MONTH_LENGTH = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstDash;</span><br><span class="line">        <span class="keyword">int</span> secondDash;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="keyword">super</span>.getYear() + <span class="number">1900</span>;</span><br><span class="line">        <span class="keyword">int</span> month = <span class="keyword">super</span>.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="keyword">super</span>.getDate();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>免费公开课_传智播客和黑马程序员免费公开课<br><a href="http://yun.itheima.com/open" target="_blank" rel="noopener">http://yun.itheima.com/open</a></p><p>Java从小白到大牛-图书-图灵社区<br><a href="http://www.ituring.com.cn/book/2480" target="_blank" rel="noopener">http://www.ituring.com.cn/book/2480</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在声明变量或常量时会用到数据类型，在前面已经用到一些数据类型，例如int、double和String等。Java语言的数据类型分为：八种基本类型和三种引用类型(数组, class, interface)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
  </entry>
  
</feed>
